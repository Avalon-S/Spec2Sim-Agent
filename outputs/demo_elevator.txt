Logging output to: outputs\demo_elevator.txt
--- Starting Spec2Sim-Agent Pipeline ---

[1] Analyst Agent: Extracting Spec...

 ### Created new session: debug_session_id

User > System: Elevator Control System
States: Idle, MovingUp, MovingDown, DoorOpen

1. Idle -> MovingUp when request_floor > current_floor.
2. Idle -> MovingDown when request_floor < current_floor.
3. MovingUp -> DoorOpen when current_floor == request_floor.
4. MovingDown -> DoorOpen when current_floor == request_floor.
5. DoorOpen -> Idle after 5s if no requests.
6. DoorOpen -> MovingUp after 5s if request_floor > current_floor.
7. DoorOpen -> MovingDown after 5s if request_floor < current_floor.

Note:
- The system tracks `current_floor` (starts at 1) and `request_floor`.
- When in `MovingUp`, `current_floor` increases by 1 every 2s.
- When in `MovingDown`, `current_floor` decreases by 1 every 2s.

analyst_agent > ```json
{
  "states": [
    {"name": "Idle"},
    {"name": "MovingUp"},
    {"name": "MovingDown"},
    {"name": "DoorOpen"}
  ],
  "transitions": [
    {
      "from": "Idle",
      "to": "MovingUp",
      "condition": "request_floor > current_floor"
    },
    {
      "from": "Idle",
      "to": "MovingDown",
      "condition": "request_floor < current_floor"
    },
    {
      "from": "MovingUp",
      "to": "DoorOpen",
      "condition": "current_floor == request_floor"
    },
    {
      "from": "MovingDown",
      "to": "DoorOpen",
      "condition": "current_floor == request_floor"
    },
    {
      "from": "DoorOpen",
      "to": "Idle",
      "condition": "no requests"
    },
    {
      "from": "DoorOpen",
      "to": "MovingUp",
      "condition": "request_floor > current_floor"
    },
    {
      "from": "DoorOpen",
      "to": "MovingDown",
      "condition": "request_floor < current_floor"
    }
  ],
  "constraints": [
    {"param": "DoorOpen_duration", "value": 5},
    {"param": "MovingUp_increment_time", "value": 2},
    {"param": "MovingDown_decrement_time", "value": 2}
  ]
}
```
    Spec: {'states': [{'name': 'Idle'}, {'name': 'MovingUp'}, {'name': 'MovingDown'}, {'name': 'DoorOpen'}], 'transitions': [{'from': 'Idle', 'to': 'MovingUp', 'condition': 'request_floor > current_floor'}, {'from': 'Idle', 'to': 'MovingDown', 'condition': 'request_floor < current_floor'}, {'from': 'MovingUp', 'to': 'DoorOpen', 'condition': 'current_floor == request_floor'}, {'from': 'MovingDown', 'to': 'DoorOpen', 'condition': 'current_floor == request_floor'}, {'from': 'DoorOpen', 'to': 'Idle', 'condition': 'no requests'}, {'from': 'DoorOpen', 'to': 'MovingUp', 'condition': 'request_floor > current_floor'}, {'from': 'DoorOpen', 'to': 'MovingDown', 'condition': 'request_floor < current_floor'}], 'constraints': [{'param': 'DoorOpen_duration', 'value': 5}, {'param': 'MovingUp_increment_time', 'value': 2}, {'param': 'MovingDown_decrement_time', 'value': 2}]}

[1.5] Generating Mermaid Diagram...

[2] Architect Agent: Generating Code (Attempt 1)...

 ### Created new session: debug_session_id

User > Specification:
{'states': [{'name': 'Idle'}, {'name': 'MovingUp'}, {'name': 'MovingDown'}, {'name': 'DoorOpen'}], 'transitions': [{'from': 'Idle', 'to': 'MovingUp', 'condition': 'request_floor > current_floor'}, {'from': 'Idle', 'to': 'MovingDown', 'condition': 'request_floor < current_floor'}, {'from': 'MovingUp', 'to': 'DoorOpen', 'condition': 'current_floor == request_floor'}, {'from': 'MovingDown', 'to': 'DoorOpen', 'condition': 'current_floor == request_floor'}, {'from': 'DoorOpen', 'to': 'Idle', 'condition': 'no requests'}, {'from': 'DoorOpen', 'to': 'MovingUp', 'condition': 'request_floor > current_floor'}, {'from': 'DoorOpen', 'to': 'MovingDown', 'condition': 'request_floor < current_floor'}], 'constraints': [{'param': 'DoorOpen_duration', 'value': 5}, {'param': 'MovingUp_increment_time', 'value': 2}, {'param': 'MovingDown_decrement_time', 'value': 2}]}
architect_agent > ```python
import simpy

class StateMachine:
    def __init__(self, env, constraints):
        self.env = env
        self.current_state = 'Idle'
        self.constraints = constraints
        self.current_floor = 0  # Default starting floor
        self.request_floor = 0  # Default requested floor
        self.elevator_moving = False

        # Initialize default values for constraints if they are None or missing
        if 'DoorOpen_duration' not in self.constraints or self.constraints['DoorOpen_duration'] is None:
            self.constraints['DoorOpen_duration'] = 5
        if 'MovingUp_increment_time' not in self.constraints or self.constraints['MovingUp_increment_time'] is None:
            self.constraints['MovingUp_increment_time'] = 2
        if 'MovingDown_decrement_time' not in self.constraints or self.constraints['MovingDown_decrement_time'] is None:
            self.constraints['MovingDown_decrement_time'] = 2

        print("[SIM] Starting simulation")

    def _log_state_change(self, from_state, to_state, condition):
        print(f"[SIM][t={self.env.now:.2f}] TRANSITION {from_state} -> {to_state} (reason={condition})")

    def _log_wait(self, duration, event_name):
        print(f"[SIM][t={self.env.now:.2f}] WAIT {duration}s for {event_name}")

    def _log_state_entry(self, state_name):
        print(f"[SIM][t={self.env.now:.2f}] ENTER state={state_name}")

    def _log_end_state(self, final_state):
        print(f"[SIM][t={self.env.now:.2f}] END state={final_state}")

    def idle(self):
        self._log_state_entry('Idle')
        while True:
            # Check transitions from Idle
            if self.request_floor > self.current_floor:
                self._log_state_change('Idle', 'MovingUp', 'request_floor > current_floor')
                self.current_state = 'MovingUp'
                return
            elif self.request_floor < self.current_floor:
                self._log_state_change('Idle', 'MovingDown', 'request_floor < current_floor')
                self.current_state = 'MovingDown'
                return
            else:
                # Stay in Idle, simulate a small wait to allow other processes to run
                yield self.env.timeout(0.001) # Smallest possible timeout to avoid infinite loops

    def moving_up(self):
        self._log_state_entry('MovingUp')
        self.elevator_moving = True
        move_duration = self.constraints.get('MovingUp_increment_time', 2) # Default to 2s

        # Simulate moving up, floor by floor until request_floor is reached
        while self.current_floor < self.request_floor:
            self._log_wait(move_duration, f"moving to floor {self.current_floor + 1}")
            yield self.env.timeout(move_duration)
            self.current_floor += 1
            print(f"[SIM][t={self.env.now:.2f}] Elevator at floor {self.current_floor}")

        self.elevator_moving = False
        # Transition to DoorOpen when current_floor == request_floor
        self._log_state_change('MovingUp', 'DoorOpen', 'current_floor == request_floor')
        self.current_state = 'DoorOpen'
        return

    def moving_down(self):
        self._log_state_entry('MovingDown')
        self.elevator_moving = True
        move_duration = self.constraints.get('MovingDown_decrement_time', 2) # Default to 2s

        # Simulate moving down, floor by floor until request_floor is reached
        while self.current_floor > self.request_floor:
            self._log_wait(move_duration, f"moving to floor {self.current_floor - 1}")
            yield self.env.timeout(move_duration)
            self.current_floor -= 1
            print(f"[SIM][t={self.env.now:.2f}] Elevator at floor {self.current_floor}")

        self.elevator_moving = False
        # Transition to DoorOpen when current_floor == request_floor
        self._log_state_change('MovingDown', 'DoorOpen', 'current_floor == request_floor')
        self.current_state = 'DoorOpen'
        return

    def door_open(self):
        self._log_state_entry('DoorOpen')
        door_duration = self.constraints.get('DoorOpen_duration', 5) # Default to 5s
        self._log_wait(door_duration, "door closing or next request")
        yield self.env.timeout(door_duration)

        # Check transitions from DoorOpen
        if self.request_floor > self.current_floor:
            self._log_state_change('DoorOpen', 'MovingUp', 'request_floor > current_floor')
            self.current_state = 'MovingUp'
            return
        elif self.request_floor < self.current_floor:
            self._log_state_change('DoorOpen', 'MovingDown', 'request_floor < current_floor')
            self.current_state = 'MovingDown'
            return
        elif 'no requests': # This condition implies no further pending requests
            self._log_state_change('DoorOpen', 'Idle', 'no requests')
            self.current_state = 'Idle'
            return
        else:
            # If no other condition met, and door is considered closed, transition to Idle
            # This case might need refinement based on a more explicit "door closed" event/state
            self._log_state_change('DoorOpen', 'Idle', 'no specific request, assume idle')
            self.current_state = 'Idle'
            return


    def run(self):
        while True:
            if self.current_state == 'Idle':
                yield from self.idle()
            elif self.current_state == 'MovingUp':
                yield from self.moving_up()
            elif self.current_state == 'MovingDown':
                yield from self.moving_down()
            elif self.current_state == 'DoorOpen':
                yield from self.door_open()
            else:
                # Should not happen if all states are covered
                print(f"[SIM][t={self.env.now:.2f}] ERROR: Unknown state {self.current_state}")
                break
            # Small delay to prevent potential tight loops if transitions are immediate and no yield is in state logic
            if self.current_state in ['Idle', 'DoorOpen']: # States that might loop without explicit timeout in their logic
                 yield self.env.timeout(0.001)


def run_simulation():
    env = simpy.Environment()
    constraints = {
        'DoorOpen_duration': 5,
        'MovingUp_increment_time': 2,
        'MovingDown_decrement_time': 2
    }
    state_machine = StateMachine(env, constraints)

    env.process(state_machine.run())
    
    # This is a time-driven system, so we don't need a separate test_scenarios process
    # The state machine's internal logic and state transitions will drive the simulation based on time and internal variables.
    
    env.run(until=30) # Run simulation for 30 seconds
    state_machine._log_end_state(state_machine.current_state)
    print("[SIM] END simulation")

if __name__ == '__main__':
    run_simulation()
```
    Code Generated.
    --- Generated Code ---
import simpy

class StateMachine:
    def __init__(self, env, constraints):
        self.env = env
        self.current_state = 'Idle'
        self.constraints = constraints
        self.current_floor = 0  # Default starting floor
        self.request_floor = 0  # Default requested floor
        self.elevator_moving = False

        # Initialize default values for constraints if they are None or missing
        if 'DoorOpen_duration' not in self.constraints or self.constraints['DoorOpen_duration'] is None:
            self.constraints['DoorOpen_duration'] = 5
        if 'MovingUp_increment_time' not in self.constraints or self.constraints['MovingUp_increment_time'] is None:
            self.constraints['MovingUp_increment_time'] = 2
        if 'MovingDown_decrement_time' not in self.constraints or self.constraints['MovingDown_decrement_time'] is None:
            self.constraints['MovingDown_decrement_time'] = 2

        print("[SIM] Starting simulation")

    def _log_state_change(self, from_state, to_state, condition):
        print(f"[SIM][t={self.env.now:.2f}] TRANSITION {from_state} -> {to_state} (reason={condition})")

    def _log_wait(self, duration, event_name):
        print(f"[SIM][t={self.env.now:.2f}] WAIT {duration}s for {event_name}")

    def _log_state_entry(self, state_name):
        print(f"[SIM][t={self.env.now:.2f}] ENTER state={state_name}")

    def _log_end_state(self, final_state):
        print(f"[SIM][t={self.env.now:.2f}] END state={final_state}")

    def idle(self):
        self._log_state_entry('Idle')
        while True:
            # Check transitions from Idle
            if self.request_floor > self.current_floor:
                self._log_state_change('Idle', 'MovingUp', 'request_floor > current_floor')
                self.current_state = 'MovingUp'
                return
            elif self.request_floor < self.current_floor:
                self._log_state_change('Idle', 'MovingDown', 'request_floor < current_floor')
                self.current_state = 'MovingDown'
                return
            else:
                # Stay in Idle, simulate a small wait to allow other processes to run
                yield self.env.timeout(0.001) # Smallest possible timeout to avoid infinite loops

    def moving_up(self):
        self._log_state_entry('MovingUp')
        self.elevator_moving = True
        move_duration = self.constraints.get('MovingUp_increment_time', 2) # Default to 2s

        # Simulate moving up, floor by floor until request_floor is reached
        while self.current_floor < self.request_floor:
            self._log_wait(move_duration, f"moving to floor {self.current_floor + 1}")
            yield self.env.timeout(move_duration)
            self.current_floor += 1
            print(f"[SIM][t={self.env.now:.2f}] Elevator at floor {self.current_floor}")

        self.elevator_moving = False
        # Transition to DoorOpen when current_floor == request_floor
        self._log_state_change('MovingUp', 'DoorOpen', 'current_floor == request_floor')
        self.current_state = 'DoorOpen'
        return

    def moving_down(self):
        self._log_state_entry('MovingDown')
        self.elevator_moving = True
        move_duration = self.constraints.get('MovingDown_decrement_time', 2) # Default to 2s

        # Simulate moving down, floor by floor until request_floor is reached
        while self.current_floor > self.request_floor:
            self._log_wait(move_duration, f"moving to floor {self.current_floor - 1}")
            yield self.env.timeout(move_duration)
            self.current_floor -= 1
            print(f"[SIM][t={self.env.now:.2f}] Elevator at floor {self.current_floor}")

        self.elevator_moving = False
        # Transition to DoorOpen when current_floor == request_floor
        self._log_state_change('MovingDown', 'DoorOpen', 'current_floor == request_floor')
        self.current_state = 'DoorOpen'
        return

    def door_open(self):
        self._log_state_entry('DoorOpen')
        door_duration = self.constraints.get('DoorOpen_duration', 5) # Default to 5s
        self._log_wait(door_duration, "door closing or next request")
        yield self.env.timeout(door_duration)

        # Check transitions from DoorOpen
        if self.request_floor > self.current_floor:
            self._log_state_change('DoorOpen', 'MovingUp', 'request_floor > current_floor')
            self.current_state = 'MovingUp'
            return
        elif self.request_floor < self.current_floor:
            self._log_state_change('DoorOpen', 'MovingDown', 'request_floor < current_floor')
            self.current_state = 'MovingDown'
            return
        elif 'no requests': # This condition implies no further pending requests
            self._log_state_change('DoorOpen', 'Idle', 'no requests')
            self.current_state = 'Idle'
            return
        else:
            # If no other condition met, and door is considered closed, transition to Idle
            # This case might need refinement based on a more explicit "door closed" event/state
            self._log_state_change('DoorOpen', 'Idle', 'no specific request, assume idle')
            self.current_state = 'Idle'
            return


    def run(self):
        while True:
            if self.current_state == 'Idle':
                yield from self.idle()
            elif self.current_state == 'MovingUp':
                yield from self.moving_up()
            elif self.current_state == 'MovingDown':
                yield from self.moving_down()
            elif self.current_state == 'DoorOpen':
                yield from self.door_open()
            else:
                # Should not happen if all states are covered
                print(f"[SIM][t={self.env.now:.2f}] ERROR: Unknown state {self.current_state}")
                break
            # Small delay to prevent potential tight loops if transitions are immediate and no yield is in state logic
            if self.current_state in ['Idle', 'DoorOpen']: # States that might loop without explicit timeout in their logic
                 yield self.env.timeout(0.001)


def run_simulation():
    env = simpy.Environment()
    constraints = {
        'DoorOpen_duration': 5,
        'MovingUp_increment_time': 2,
        'MovingDown_decrement_time': 2
    }
    state_machine = StateMachine(env, constraints)

    env.process(state_machine.run())
    
    # This is a time-driven system, so we don't need a separate test_scenarios process
    # The state machine's internal logic and state transitions will drive the simulation based on time and internal variables.
    
    env.run(until=30) # Run simulation for 30 seconds
    state_machine._log_end_state(state_machine.current_state)
    print("[SIM] END simulation")

if __name__ == '__main__':
    run_simulation()
    ----------------------

[3] Verifier Agent: Executing & Verifying via MCP...

 ### Created new session: debug_session_id

User > 
        Specification:
        {
  "states": [
    {
      "name": "Idle"
    },
    {
      "name": "MovingUp"
    },
    {
      "name": "MovingDown"
    },
    {
      "name": "DoorOpen"
    }
  ],
  "transitions": [
    {
      "from": "Idle",
      "to": "MovingUp",
      "condition": "request_floor > current_floor"
    },
    {
      "from": "Idle",
      "to": "MovingDown",
      "condition": "request_floor < current_floor"
    },
    {
      "from": "MovingUp",
      "to": "DoorOpen",
      "condition": "current_floor == request_floor"
    },
    {
      "from": "MovingDown",
      "to": "DoorOpen",
      "condition": "current_floor == request_floor"
    },
    {
      "from": "DoorOpen",
      "to": "Idle",
      "condition": "no requests"
    },
    {
      "from": "DoorOpen",
      "to": "MovingUp",
      "condition": "request_floor > current_floor"
    },
    {
      "from": "DoorOpen",
      "to": "MovingDown",
      "condition": "request_floor < current_floor"
    }
  ],
  "constraints": [
    {
      "param": "DoorOpen_duration",
      "value": 5
    },
    {
      "param": "MovingUp_increment_time",
      "value": 2
    },
    {
      "param": "MovingDown_decrement_time",
      "value": 2
    }
  ]
}
        
        Simulation Code:
        ```python
        import simpy

class StateMachine:
    def __init__(self, env, constraints):
        self.env = env
        self.current_state = 'Idle'
        self.constraints = constraints
        self.current_floor = 0  # Default starting floor
        self.request_floor = 0  # Default requested floor
        self.elevator_moving = False

        # Initialize default values for constraints if they are None or missing
        if 'DoorOpen_duration' not in self.constraints or self.constraints['DoorOpen_duration'] is None:
            self.constraints['DoorOpen_duration'] = 5
        if 'MovingUp_increment_time' not in self.constraints or self.constraints['MovingUp_increment_time'] is None:
            self.constraints['MovingUp_increment_time'] = 2
        if 'MovingDown_decrement_time' not in self.constraints or self.constraints['MovingDown_decrement_time'] is None:
            self.constraints['MovingDown_decrement_time'] = 2

        print("[SIM] Starting simulation")

    def _log_state_change(self, from_state, to_state, condition):
        print(f"[SIM][t={self.env.now:.2f}] TRANSITION {from_state} -> {to_state} (reason={condition})")

    def _log_wait(self, duration, event_name):
        print(f"[SIM][t={self.env.now:.2f}] WAIT {duration}s for {event_name}")

    def _log_state_entry(self, state_name):
        print(f"[SIM][t={self.env.now:.2f}] ENTER state={state_name}")

    def _log_end_state(self, final_state):
        print(f"[SIM][t={self.env.now:.2f}] END state={final_state}")

    def idle(self):
        self._log_state_entry('Idle')
        while True:
            # Check transitions from Idle
            if self.request_floor > self.current_floor:
                self._log_state_change('Idle', 'MovingUp', 'request_floor > current_floor')
                self.current_state = 'MovingUp'
                return
            elif self.request_floor < self.current_floor:
                self._log_state_change('Idle', 'MovingDown', 'request_floor < current_floor')
                self.current_state = 'MovingDown'
                return
            else:
                # Stay in Idle, simulate a small wait to allow other processes to run
                yield self.env.timeout(0.001) # Smallest possible timeout to avoid infinite loops

    def moving_up(self):
        self._log_state_entry('MovingUp')
        self.elevator_moving = True
        move_duration = self.constraints.get('MovingUp_increment_time', 2) # Default to 2s

        # Simulate moving up, floor by floor until request_floor is reached
        while self.current_floor < self.request_floor:
            self._log_wait(move_duration, f"moving to floor {self.current_floor + 1}")
            yield self.env.timeout(move_duration)
            self.current_floor += 1
            print(f"[SIM][t={self.env.now:.2f}] Elevator at floor {self.current_floor}")

        self.elevator_moving = False
        # Transition to DoorOpen when current_floor == request_floor
        self._log_state_change('MovingUp', 'DoorOpen', 'current_floor == request_floor')
        self.current_state = 'DoorOpen'
        return

    def moving_down(self):
        self._log_state_entry('MovingDown')
        self.elevator_moving = True
        move_duration = self.constraints.get('MovingDown_decrement_time', 2) # Default to 2s

        # Simulate moving down, floor by floor until request_floor is reached
        while self.current_floor > self.request_floor:
            self._log_wait(move_duration, f"moving to floor {self.current_floor - 1}")
            yield self.env.timeout(move_duration)
            self.current_floor -= 1
            print(f"[SIM][t={self.env.now:.2f}] Elevator at floor {self.current_floor}")

        self.elevator_moving = False
        # Transition to DoorOpen when current_floor == request_floor
        self._log_state_change('MovingDown', 'DoorOpen', 'current_floor == request_floor')
        self.current_state = 'DoorOpen'
        return

    def door_open(self):
        self._log_state_entry('DoorOpen')
        door_duration = self.constraints.get('DoorOpen_duration', 5) # Default to 5s
        self._log_wait(door_duration, "door closing or next request")
        yield self.env.timeout(door_duration)

        # Check transitions from DoorOpen
        if self.request_floor > self.current_floor:
            self._log_state_change('DoorOpen', 'MovingUp', 'request_floor > current_floor')
            self.current_state = 'MovingUp'
            return
        elif self.request_floor < self.current_floor:
            self._log_state_change('DoorOpen', 'MovingDown', 'request_floor < current_floor')
            self.current_state = 'MovingDown'
            return
        elif 'no requests': # This condition implies no further pending requests
            self._log_state_change('DoorOpen', 'Idle', 'no requests')
            self.current_state = 'Idle'
            return
        else:
            # If no other condition met, and door is considered closed, transition to Idle
            # This case might need refinement based on a more explicit "door closed" event/state
            self._log_state_change('DoorOpen', 'Idle', 'no specific request, assume idle')
            self.current_state = 'Idle'
            return


    def run(self):
        while True:
            if self.current_state == 'Idle':
                yield from self.idle()
            elif self.current_state == 'MovingUp':
                yield from self.moving_up()
            elif self.current_state == 'MovingDown':
                yield from self.moving_down()
            elif self.current_state == 'DoorOpen':
                yield from self.door_open()
            else:
                # Should not happen if all states are covered
                print(f"[SIM][t={self.env.now:.2f}] ERROR: Unknown state {self.current_state}")
                break
            # Small delay to prevent potential tight loops if transitions are immediate and no yield is in state logic
            if self.current_state in ['Idle', 'DoorOpen']: # States that might loop without explicit timeout in their logic
                 yield self.env.timeout(0.001)


def run_simulation():
    env = simpy.Environment()
    constraints = {
        'DoorOpen_duration': 5,
        'MovingUp_increment_time': 2,
        'MovingDown_decrement_time': 2
    }
    state_machine = StateMachine(env, constraints)

    env.process(state_machine.run())
    
    # This is a time-driven system, so we don't need a separate test_scenarios process
    # The state machine's internal logic and state transitions will drive the simulation based on time and internal variables.
    
    env.run(until=30) # Run simulation for 30 seconds
    state_machine._log_end_state(state_machine.current_state)
    print("[SIM] END simulation")

if __name__ == '__main__':
    run_simulation()
        ```
        
        Please execute this code and verify the results.
        
[DEBUG] Sessions dict keys: ['InMemoryRunner']
[DEBUG] Session value type for key 'InMemoryRunner': <class 'dict'>
[DEBUG] Nested keys: ['debug_user_id']
[DEBUG] Nested value type for key 'debug_user_id': <class 'dict'>
[DEBUG] Triple nested keys: ['debug_session_id']
[DEBUG] Found session from triple nested dict: debug_session_id
[DEBUG] Session events count: 4
[DEBUG] Session events count: 4
[DEBUG] Response length: 3
[DEBUG] Event 0 type: <class 'google.adk.events.event.Event'>
[DEBUG] Event content parts: 1
[DEBUG] Part type: <class 'google.genai.types.Part'>
[DEBUG] Part text (snippet): None
[DEBUG] Part function_response: Yes
[DEBUG] Event 1 type: <class 'google.adk.events.event.Event'>
[DEBUG] Event content parts: 1
[DEBUG] Part type: <class 'google.genai.types.Part'>
[DEBUG] Part text (snippet): None
[DEBUG] Part function_response: Yes
[DEBUG] Event 2 type: <class 'google.adk.events.event.Event'>
[DEBUG] Event content parts: 0
    Verification: {'status': 'FAIL', 'reason': 'Empty response from Verifier Agent', 'retry': True, 'logs': '[SIM] Starting simulation\n[SIM][t=0.00] ENTER state=Idle\n[SIM][t=30.00] END state=Idle\n[SIM] END simulation\n'}
    Retrying...

[2] Architect Agent: Generating Code (Attempt 2)...

 ### Created new session: debug_session_id

User > Specification:
{'states': [{'name': 'Idle'}, {'name': 'MovingUp'}, {'name': 'MovingDown'}, {'name': 'DoorOpen'}], 'transitions': [{'from': 'Idle', 'to': 'MovingUp', 'condition': 'request_floor > current_floor'}, {'from': 'Idle', 'to': 'MovingDown', 'condition': 'request_floor < current_floor'}, {'from': 'MovingUp', 'to': 'DoorOpen', 'condition': 'current_floor == request_floor'}, {'from': 'MovingDown', 'to': 'DoorOpen', 'condition': 'current_floor == request_floor'}, {'from': 'DoorOpen', 'to': 'Idle', 'condition': 'no requests'}, {'from': 'DoorOpen', 'to': 'MovingUp', 'condition': 'request_floor > current_floor'}, {'from': 'DoorOpen', 'to': 'MovingDown', 'condition': 'request_floor < current_floor'}], 'constraints': [{'param': 'DoorOpen_duration', 'value': 5}, {'param': 'MovingUp_increment_time', 'value': 2}, {'param': 'MovingDown_decrement_time', 'value': 2}]}

FEEDBACK FROM PREVIOUS ATTEMPT (FIX THESE ERRORS):
Verification Failed: Empty response from Verifier Agent
Logs/Errors:
[SIM] Starting simulation
[SIM][t=0.00] ENTER state=Idle
[SIM][t=30.00] END state=Idle
[SIM] END simulation

architect_agent > ```python
import simpy

class StateMachine:
    def __init__(self, env):
        self.env = env
        self.current_state = 'Idle'
        self.request_floor = 0
        self.current_floor = 0
        self.door_open_duration = 5
        self.moving_up_increment_time = 2
        self.moving_down_decrement_time = 2
        self.log_state_change = True  # Flag to control logging for state transitions

        # Initialize constraints with sensible defaults if not provided
        self.door_open_duration = self.constraints.get('DoorOpen_duration', 5)
        self.moving_up_increment_time = self.constraints.get('MovingUp_increment_time', 2)
        self.moving_down_decrement_time = self.constraints.get('MovingDown_decrement_time', 2)

    def log_transition(self, from_state, to_state, condition):
        if self.log_state_change:
            print(f"[SIM][t={self.env.now:.2f}] TRANSITION {from_state} -> {to_state} (reason={condition})")

    def enter_state(self, state_name):
        self.current_state = state_name
        print(f"[SIM][t={self.env.now:.2f}] ENTER state={state_name}")

    def wait_for_event(self, duration, event_name):
        print(f"[SIM][t={self.env.now:.2f}] WAIT {duration}s for {event_name}")
        yield self.env.timeout(duration)

    def idle(self):
        self.enter_state('Idle')
        # In Idle state, we wait indefinitely until a request comes.
        # For simulation purposes, we might yield a small timeout or wait for an external event.
        # Since this is a time-driven simulation, we'll rely on the main loop to transition.
        # We need at least one yield to make it a generator.
        yield self.env.timeout(0.001) # Minimal timeout to make it a generator

    def moving_up(self):
        self.enter_state('MovingUp')
        # Simulate moving up, incrementing floor over time
        travel_time = self.moving_up_increment_time
        yield self.wait_for_event(travel_time, "MovingUp")
        self.current_floor += 1
        # This state might transition immediately or after a timeout depending on logic.
        # Here, we assume it checks conditions and transitions.
        # We need to yield to yield control back to the main simulation loop.
        yield self.env.timeout(0.001) # Minimal timeout to make it a generator

    def moving_down(self):
        self.enter_state('MovingDown')
        # Simulate moving down, decrementing floor over time
        travel_time = self.moving_down_decrement_time
        yield self.wait_for_event(travel_time, "MovingDown")
        self.current_floor -= 1
        # Similar to moving_up, yield to yield control.
        yield self.env.timeout(0.001) # Minimal timeout to make it a generator

    def door_open(self):
        self.enter_state('DoorOpen')
        # Stay in DoorOpen state for a fixed duration
        yield self.wait_for_event(self.door_open_duration, "DoorOpen")
        # After the duration, transition back to Idle if no requests, or to moving states.
        # The main run loop will handle the transition logic based on conditions.
        # Need to yield to make it a generator.
        yield self.env.timeout(0.001) # Minimal timeout to make it a generator

    def run(self):
        while True:
            if self.current_state == 'Idle':
                yield from self.idle()
            elif self.current_state == 'MovingUp':
                yield from self.moving_up()
            elif self.current_state == 'MovingDown':
                yield from self.moving_down()
            elif self.current_state == 'DoorOpen':
                yield from self.door_open()

            # Transition logic after a state completes its yield
            # This part needs to check conditions and decide the next state.
            # It's placed here to evaluate transitions after a state's yield/timeout.

            # Check transitions from Idle
            if self.current_state == 'Idle':
                if self.request_floor > self.current_floor:
                    self.log_transition('Idle', 'MovingUp', 'request_floor > current_floor')
                    self.current_state = 'MovingUp' # Transition directly
                elif self.request_floor < self.current_floor:
                    self.log_transition('Idle', 'MovingDown', 'request_floor < current_floor')
                    self.current_state = 'MovingDown' # Transition directly
                # If no condition met, it stays in Idle, loop continues

            # Check transitions from MovingUp
            elif self.current_state == 'MovingUp':
                if self.current_floor == self.request_floor:
                    self.log_transition('MovingUp', 'DoorOpen', 'current_floor == request_floor')
                    self.current_state = 'DoorOpen' # Transition directly
                # If floor not reached, it stays in MovingUp, loop continues

            # Check transitions from MovingDown
            elif self.current_state == 'MovingDown':
                if self.current_floor == self.request_floor:
                    self.log_transition('MovingDown', 'DoorOpen', 'current_floor == request_floor')
                    self.current_state = 'DoorOpen' # Transition directly
                # If floor not reached, it stays in MovingDown, loop continues

            # Check transitions from DoorOpen
            elif self.current_state == 'DoorOpen':
                # After DoorOpen_duration, check for new requests or stay Idle
                if self.request_floor > self.current_floor:
                    self.log_transition('DoorOpen', 'MovingUp', 'request_floor > current_floor')
                    self.current_state = 'MovingUp'
                elif self.request_floor < self.current_floor:
                    self.log_transition('DoorOpen', 'MovingDown', 'request_floor < current_floor')
                    self.current_state = 'MovingDown'
                elif self.request_floor == self.current_floor: # Implicitly, no further requests pending
                    self.log_transition('DoorOpen', 'Idle', 'no requests')
                    self.current_state = 'Idle'
                # If none of the above, it implies it should re-evaluate, but the loop handles it.
                # If request_floor == current_floor, it should transition to Idle if no new requests.
                # The condition 'no requests' is implicitly handled by the request_floor == current_floor check
                # and the lack of new requests triggering MovingUp/MovingDown.

            # Ensure loop yields control if no transition occurred immediately
            # This prevents tight loops if no state change happens
            if self.current_state not in ['MovingUp', 'MovingDown'] and self.current_state != 'DoorOpen':
                 yield self.env.timeout(0.001)
            elif self.current_state == 'DoorOpen' and self.env.now % self.door_open_duration != 0:
                 yield self.env.timeout(0.001) # Prevent tight loop in DoorOpen if not timed out
            elif self.current_state == 'MovingUp' and self.current_floor != self.request_floor:
                yield self.env.timeout(0.001)
            elif self.current_state == 'MovingDown' and self.current_floor != self.request_floor:
                yield self.env.timeout(0.001)



def run_simulation():
    print("[SIM] Starting simulation")
    env = simpy.Environment()
    state_machine = StateMachine(env)
    env.process(state_machine.run())

    # This is a time-driven system, so we don't need an explicit test_scenarios process.
    # We will run the simulation for a fixed duration.
    # Based on the constraints and transitions, we need to ensure enough time for movements and door opening.
    # Let's assume a few cycles of operation.
    simulation_duration = 30 # seconds

    # To trigger transitions, we need to set request_floor at certain times.
    # Since this is a time-driven system, we don't have an input loop.
    # We will manually set requests at specific times for demonstration.

    def request_simulator(env, sm):
        # Example scenario:
        yield env.timeout(1)
        sm.request_floor = 3
        print(f"[INPUT] Setting request_floor to {sm.request_floor} at t={env.now:.2f}")
        yield env.timeout(10) # Wait for elevator to potentially reach floor 3
        sm.request_floor = 1
        print(f"[INPUT] Setting request_floor to {sm.request_floor} at t={env.now:.2f}")
        yield env.timeout(15) # Wait for elevator to potentially reach floor 1
        sm.request_floor = 5
        print(f"[INPUT] Setting request_floor to {sm.request_floor} at t={env.now:.2f}")
        yield env.timeout(20) # Wait for elevator to potentially reach floor 5

    env.process(request_simulator(env, state_machine))
    env.run(until=simulation_duration)
    print(f"[SIM][t={env.now:.2f}] END state={state_machine.current_state}")
    print("[SIM] END simulation")

if __name__ == "__main__":
    run_simulation()
```
    Code Generated.
    --- Generated Code ---
import simpy

class StateMachine:
    def __init__(self, env):
        self.env = env
        self.current_state = 'Idle'
        self.request_floor = 0
        self.current_floor = 0
        self.door_open_duration = 5
        self.moving_up_increment_time = 2
        self.moving_down_decrement_time = 2
        self.log_state_change = True  # Flag to control logging for state transitions

        # Initialize constraints with sensible defaults if not provided
        self.door_open_duration = self.constraints.get('DoorOpen_duration', 5)
        self.moving_up_increment_time = self.constraints.get('MovingUp_increment_time', 2)
        self.moving_down_decrement_time = self.constraints.get('MovingDown_decrement_time', 2)

    def log_transition(self, from_state, to_state, condition):
        if self.log_state_change:
            print(f"[SIM][t={self.env.now:.2f}] TRANSITION {from_state} -> {to_state} (reason={condition})")

    def enter_state(self, state_name):
        self.current_state = state_name
        print(f"[SIM][t={self.env.now:.2f}] ENTER state={state_name}")

    def wait_for_event(self, duration, event_name):
        print(f"[SIM][t={self.env.now:.2f}] WAIT {duration}s for {event_name}")
        yield self.env.timeout(duration)

    def idle(self):
        self.enter_state('Idle')
        # In Idle state, we wait indefinitely until a request comes.
        # For simulation purposes, we might yield a small timeout or wait for an external event.
        # Since this is a time-driven simulation, we'll rely on the main loop to transition.
        # We need at least one yield to make it a generator.
        yield self.env.timeout(0.001) # Minimal timeout to make it a generator

    def moving_up(self):
        self.enter_state('MovingUp')
        # Simulate moving up, incrementing floor over time
        travel_time = self.moving_up_increment_time
        yield self.wait_for_event(travel_time, "MovingUp")
        self.current_floor += 1
        # This state might transition immediately or after a timeout depending on logic.
        # Here, we assume it checks conditions and transitions.
        # We need to yield to yield control back to the main simulation loop.
        yield self.env.timeout(0.001) # Minimal timeout to make it a generator

    def moving_down(self):
        self.enter_state('MovingDown')
        # Simulate moving down, decrementing floor over time
        travel_time = self.moving_down_decrement_time
        yield self.wait_for_event(travel_time, "MovingDown")
        self.current_floor -= 1
        # Similar to moving_up, yield to yield control.
        yield self.env.timeout(0.001) # Minimal timeout to make it a generator

    def door_open(self):
        self.enter_state('DoorOpen')
        # Stay in DoorOpen state for a fixed duration
        yield self.wait_for_event(self.door_open_duration, "DoorOpen")
        # After the duration, transition back to Idle if no requests, or to moving states.
        # The main run loop will handle the transition logic based on conditions.
        # Need to yield to make it a generator.
        yield self.env.timeout(0.001) # Minimal timeout to make it a generator

    def run(self):
        while True:
            if self.current_state == 'Idle':
                yield from self.idle()
            elif self.current_state == 'MovingUp':
                yield from self.moving_up()
            elif self.current_state == 'MovingDown':
                yield from self.moving_down()
            elif self.current_state == 'DoorOpen':
                yield from self.door_open()

            # Transition logic after a state completes its yield
            # This part needs to check conditions and decide the next state.
            # It's placed here to evaluate transitions after a state's yield/timeout.

            # Check transitions from Idle
            if self.current_state == 'Idle':
                if self.request_floor > self.current_floor:
                    self.log_transition('Idle', 'MovingUp', 'request_floor > current_floor')
                    self.current_state = 'MovingUp' # Transition directly
                elif self.request_floor < self.current_floor:
                    self.log_transition('Idle', 'MovingDown', 'request_floor < current_floor')
                    self.current_state = 'MovingDown' # Transition directly
                # If no condition met, it stays in Idle, loop continues

            # Check transitions from MovingUp
            elif self.current_state == 'MovingUp':
                if self.current_floor == self.request_floor:
                    self.log_transition('MovingUp', 'DoorOpen', 'current_floor == request_floor')
                    self.current_state = 'DoorOpen' # Transition directly
                # If floor not reached, it stays in MovingUp, loop continues

            # Check transitions from MovingDown
            elif self.current_state == 'MovingDown':
                if self.current_floor == self.request_floor:
                    self.log_transition('MovingDown', 'DoorOpen', 'current_floor == request_floor')
                    self.current_state = 'DoorOpen' # Transition directly
                # If floor not reached, it stays in MovingDown, loop continues

            # Check transitions from DoorOpen
            elif self.current_state == 'DoorOpen':
                # After DoorOpen_duration, check for new requests or stay Idle
                if self.request_floor > self.current_floor:
                    self.log_transition('DoorOpen', 'MovingUp', 'request_floor > current_floor')
                    self.current_state = 'MovingUp'
                elif self.request_floor < self.current_floor:
                    self.log_transition('DoorOpen', 'MovingDown', 'request_floor < current_floor')
                    self.current_state = 'MovingDown'
                elif self.request_floor == self.current_floor: # Implicitly, no further requests pending
                    self.log_transition('DoorOpen', 'Idle', 'no requests')
                    self.current_state = 'Idle'
                # If none of the above, it implies it should re-evaluate, but the loop handles it.
                # If request_floor == current_floor, it should transition to Idle if no new requests.
                # The condition 'no requests' is implicitly handled by the request_floor == current_floor check
                # and the lack of new requests triggering MovingUp/MovingDown.

            # Ensure loop yields control if no transition occurred immediately
            # This prevents tight loops if no state change happens
            if self.current_state not in ['MovingUp', 'MovingDown'] and self.current_state != 'DoorOpen':
                 yield self.env.timeout(0.001)
            elif self.current_state == 'DoorOpen' and self.env.now % self.door_open_duration != 0:
                 yield self.env.timeout(0.001) # Prevent tight loop in DoorOpen if not timed out
            elif self.current_state == 'MovingUp' and self.current_floor != self.request_floor:
                yield self.env.timeout(0.001)
            elif self.current_state == 'MovingDown' and self.current_floor != self.request_floor:
                yield self.env.timeout(0.001)



def run_simulation():
    print("[SIM] Starting simulation")
    env = simpy.Environment()
    state_machine = StateMachine(env)
    env.process(state_machine.run())

    # This is a time-driven system, so we don't need an explicit test_scenarios process.
    # We will run the simulation for a fixed duration.
    # Based on the constraints and transitions, we need to ensure enough time for movements and door opening.
    # Let's assume a few cycles of operation.
    simulation_duration = 30 # seconds

    # To trigger transitions, we need to set request_floor at certain times.
    # Since this is a time-driven system, we don't have an input loop.
    # We will manually set requests at specific times for demonstration.

    def request_simulator(env, sm):
        # Example scenario:
        yield env.timeout(1)
        sm.request_floor = 3
        print(f"[INPUT] Setting request_floor to {sm.request_floor} at t={env.now:.2f}")
        yield env.timeout(10) # Wait for elevator to potentially reach floor 3
        sm.request_floor = 1
        print(f"[INPUT] Setting request_floor to {sm.request_floor} at t={env.now:.2f}")
        yield env.timeout(15) # Wait for elevator to potentially reach floor 1
        sm.request_floor = 5
        print(f"[INPUT] Setting request_floor to {sm.request_floor} at t={env.now:.2f}")
        yield env.timeout(20) # Wait for elevator to potentially reach floor 5

    env.process(request_simulator(env, state_machine))
    env.run(until=simulation_duration)
    print(f"[SIM][t={env.now:.2f}] END state={state_machine.current_state}")
    print("[SIM] END simulation")

if __name__ == "__main__":
    run_simulation()
    ----------------------

[3] Verifier Agent: Executing & Verifying via MCP...

 ### Created new session: debug_session_id

User > 
        Specification:
        {
  "states": [
    {
      "name": "Idle"
    },
    {
      "name": "MovingUp"
    },
    {
      "name": "MovingDown"
    },
    {
      "name": "DoorOpen"
    }
  ],
  "transitions": [
    {
      "from": "Idle",
      "to": "MovingUp",
      "condition": "request_floor > current_floor"
    },
    {
      "from": "Idle",
      "to": "MovingDown",
      "condition": "request_floor < current_floor"
    },
    {
      "from": "MovingUp",
      "to": "DoorOpen",
      "condition": "current_floor == request_floor"
    },
    {
      "from": "MovingDown",
      "to": "DoorOpen",
      "condition": "current_floor == request_floor"
    },
    {
      "from": "DoorOpen",
      "to": "Idle",
      "condition": "no requests"
    },
    {
      "from": "DoorOpen",
      "to": "MovingUp",
      "condition": "request_floor > current_floor"
    },
    {
      "from": "DoorOpen",
      "to": "MovingDown",
      "condition": "request_floor < current_floor"
    }
  ],
  "constraints": [
    {
      "param": "DoorOpen_duration",
      "value": 5
    },
    {
      "param": "MovingUp_increment_time",
      "value": 2
    },
    {
      "param": "MovingDown_decrement_time",
      "value": 2
    }
  ]
}
        
        Simulation Code:
        ```python
        import simpy

class StateMachine:
    def __init__(self, env):
        self.env = env
        self.current_state = 'Idle'
        self.request_floor = 0
        self.current_floor = 0
        self.door_open_duration = 5
        self.moving_up_increment_time = 2
        self.moving_down_decrement_time = 2
        self.log_state_change = True  # Flag to control logging for state transitions

        # Initialize constraints with sensible defaults if not provided
        self.door_open_duration = self.constraints.get('DoorOpen_duration', 5)
        self.moving_up_increment_time = self.constraints.get('MovingUp_increment_time', 2)
        self.moving_down_decrement_time = self.constraints.get('MovingDown_decrement_time', 2)

    def log_transition(self, from_state, to_state, condition):
        if self.log_state_change:
            print(f"[SIM][t={self.env.now:.2f}] TRANSITION {from_state} -> {to_state} (reason={condition})")

    def enter_state(self, state_name):
        self.current_state = state_name
        print(f"[SIM][t={self.env.now:.2f}] ENTER state={state_name}")

    def wait_for_event(self, duration, event_name):
        print(f"[SIM][t={self.env.now:.2f}] WAIT {duration}s for {event_name}")
        yield self.env.timeout(duration)

    def idle(self):
        self.enter_state('Idle')
        # In Idle state, we wait indefinitely until a request comes.
        # For simulation purposes, we might yield a small timeout or wait for an external event.
        # Since this is a time-driven simulation, we'll rely on the main loop to transition.
        # We need at least one yield to make it a generator.
        yield self.env.timeout(0.001) # Minimal timeout to make it a generator

    def moving_up(self):
        self.enter_state('MovingUp')
        # Simulate moving up, incrementing floor over time
        travel_time = self.moving_up_increment_time
        yield self.wait_for_event(travel_time, "MovingUp")
        self.current_floor += 1
        # This state might transition immediately or after a timeout depending on logic.
        # Here, we assume it checks conditions and transitions.
        # We need to yield to yield control back to the main simulation loop.
        yield self.env.timeout(0.001) # Minimal timeout to make it a generator

    def moving_down(self):
        self.enter_state('MovingDown')
        # Simulate moving down, decrementing floor over time
        travel_time = self.moving_down_decrement_time
        yield self.wait_for_event(travel_time, "MovingDown")
        self.current_floor -= 1
        # Similar to moving_up, yield to yield control.
        yield self.env.timeout(0.001) # Minimal timeout to make it a generator

    def door_open(self):
        self.enter_state('DoorOpen')
        # Stay in DoorOpen state for a fixed duration
        yield self.wait_for_event(self.door_open_duration, "DoorOpen")
        # After the duration, transition back to Idle if no requests, or to moving states.
        # The main run loop will handle the transition logic based on conditions.
        # Need to yield to make it a generator.
        yield self.env.timeout(0.001) # Minimal timeout to make it a generator

    def run(self):
        while True:
            if self.current_state == 'Idle':
                yield from self.idle()
            elif self.current_state == 'MovingUp':
                yield from self.moving_up()
            elif self.current_state == 'MovingDown':
                yield from self.moving_down()
            elif self.current_state == 'DoorOpen':
                yield from self.door_open()

            # Transition logic after a state completes its yield
            # This part needs to check conditions and decide the next state.
            # It's placed here to evaluate transitions after a state's yield/timeout.

            # Check transitions from Idle
            if self.current_state == 'Idle':
                if self.request_floor > self.current_floor:
                    self.log_transition('Idle', 'MovingUp', 'request_floor > current_floor')
                    self.current_state = 'MovingUp' # Transition directly
                elif self.request_floor < self.current_floor:
                    self.log_transition('Idle', 'MovingDown', 'request_floor < current_floor')
                    self.current_state = 'MovingDown' # Transition directly
                # If no condition met, it stays in Idle, loop continues

            # Check transitions from MovingUp
            elif self.current_state == 'MovingUp':
                if self.current_floor == self.request_floor:
                    self.log_transition('MovingUp', 'DoorOpen', 'current_floor == request_floor')
                    self.current_state = 'DoorOpen' # Transition directly
                # If floor not reached, it stays in MovingUp, loop continues

            # Check transitions from MovingDown
            elif self.current_state == 'MovingDown':
                if self.current_floor == self.request_floor:
                    self.log_transition('MovingDown', 'DoorOpen', 'current_floor == request_floor')
                    self.current_state = 'DoorOpen' # Transition directly
                # If floor not reached, it stays in MovingDown, loop continues

            # Check transitions from DoorOpen
            elif self.current_state == 'DoorOpen':
                # After DoorOpen_duration, check for new requests or stay Idle
                if self.request_floor > self.current_floor:
                    self.log_transition('DoorOpen', 'MovingUp', 'request_floor > current_floor')
                    self.current_state = 'MovingUp'
                elif self.request_floor < self.current_floor:
                    self.log_transition('DoorOpen', 'MovingDown', 'request_floor < current_floor')
                    self.current_state = 'MovingDown'
                elif self.request_floor == self.current_floor: # Implicitly, no further requests pending
                    self.log_transition('DoorOpen', 'Idle', 'no requests')
                    self.current_state = 'Idle'
                # If none of the above, it implies it should re-evaluate, but the loop handles it.
                # If request_floor == current_floor, it should transition to Idle if no new requests.
                # The condition 'no requests' is implicitly handled by the request_floor == current_floor check
                # and the lack of new requests triggering MovingUp/MovingDown.

            # Ensure loop yields control if no transition occurred immediately
            # This prevents tight loops if no state change happens
            if self.current_state not in ['MovingUp', 'MovingDown'] and self.current_state != 'DoorOpen':
                 yield self.env.timeout(0.001)
            elif self.current_state == 'DoorOpen' and self.env.now % self.door_open_duration != 0:
                 yield self.env.timeout(0.001) # Prevent tight loop in DoorOpen if not timed out
            elif self.current_state == 'MovingUp' and self.current_floor != self.request_floor:
                yield self.env.timeout(0.001)
            elif self.current_state == 'MovingDown' and self.current_floor != self.request_floor:
                yield self.env.timeout(0.001)



def run_simulation():
    print("[SIM] Starting simulation")
    env = simpy.Environment()
    state_machine = StateMachine(env)
    env.process(state_machine.run())

    # This is a time-driven system, so we don't need an explicit test_scenarios process.
    # We will run the simulation for a fixed duration.
    # Based on the constraints and transitions, we need to ensure enough time for movements and door opening.
    # Let's assume a few cycles of operation.
    simulation_duration = 30 # seconds

    # To trigger transitions, we need to set request_floor at certain times.
    # Since this is a time-driven system, we don't have an input loop.
    # We will manually set requests at specific times for demonstration.

    def request_simulator(env, sm):
        # Example scenario:
        yield env.timeout(1)
        sm.request_floor = 3
        print(f"[INPUT] Setting request_floor to {sm.request_floor} at t={env.now:.2f}")
        yield env.timeout(10) # Wait for elevator to potentially reach floor 3
        sm.request_floor = 1
        print(f"[INPUT] Setting request_floor to {sm.request_floor} at t={env.now:.2f}")
        yield env.timeout(15) # Wait for elevator to potentially reach floor 1
        sm.request_floor = 5
        print(f"[INPUT] Setting request_floor to {sm.request_floor} at t={env.now:.2f}")
        yield env.timeout(20) # Wait for elevator to potentially reach floor 5

    env.process(request_simulator(env, state_machine))
    env.run(until=simulation_duration)
    print(f"[SIM][t={env.now:.2f}] END state={state_machine.current_state}")
    print("[SIM] END simulation")

if __name__ == "__main__":
    run_simulation()
        ```
        
        Please execute this code and verify the results.
        
verifier_agent > {"status": "FAIL", "reason": "Simulation code failed to execute due to a Python error: AttributeError: 'generator' object has no attribute 'callbacks'. This indicates an issue within the SimPy framework or how it's being used in the simulation code.", "retry": true}

[DEBUG] Sessions dict keys: ['InMemoryRunner']
[DEBUG] Session value type for key 'InMemoryRunner': <class 'dict'>
[DEBUG] Nested keys: ['debug_user_id']
[DEBUG] Nested value type for key 'debug_user_id': <class 'dict'>
[DEBUG] Triple nested keys: ['debug_session_id']
[DEBUG] Found session from triple nested dict: debug_session_id
[DEBUG] Session events count: 4
[DEBUG] Session events count: 4
[DEBUG] Response length: 3
[DEBUG] Event 0 type: <class 'google.adk.events.event.Event'>
[DEBUG] Event content parts: 1
[DEBUG] Part type: <class 'google.genai.types.Part'>
[DEBUG] Part text (snippet): None
[DEBUG] Part function_response: Yes
[DEBUG] Event 1 type: <class 'google.adk.events.event.Event'>
[DEBUG] Event content parts: 1
[DEBUG] Part type: <class 'google.genai.types.Part'>
[DEBUG] Part text (snippet): None
[DEBUG] Part function_response: Yes
[DEBUG] Event 2 type: <class 'google.adk.events.event.Event'>
[DEBUG] Event content parts: 1
[DEBUG] Part type: <class 'google.genai.types.Part'>
[DEBUG] Part text (snippet): {"status": "FAIL", "reason": "Simulation code fail
[DEBUG] Part function_response: Yes
    Verification: {'status': 'FAIL', 'reason': "Simulation code failed to execute due to a Python error: AttributeError: 'generator' object has no attribute 'callbacks'. This indicates an issue within the SimPy framework or how it's being used in the simulation code.", 'retry': True, 'logs': '[SIM] Starting simulation\n[SIM][t=0.00] ENTER state=Idle\n[SIM][t=0.01] ENTER state=Idle\n[SIM][t=0.02] ENTER state=Idle\n[SIM][t=0.03] ENTER state=Idle\n[SIM][t=0.04] ENTER state=Idle\n[SIM][t=0.05] ENTER state=Idle\n[SIM][t=0.06] ENTER state=Idle\n[SIM][t=0.07] ENTER state=Idle\n[SIM][t=0.08] ENTER state=Idle\n[SIM][t=0.09] ENTER state=Idle\n[SIM][t=0.10] ENTER state=Idle\n[SIM][t=0.11] ENTER state=Idle\n[SIM][t=0.12] ENTER state=Idle\n[SIM][t=0.13] ENTER state=Idle\n[SIM][t=0.14] ENTER state=Idle\n[SIM][t=0.15] ENTER state=Idle\n[SIM][t=0.16] ENTER state=Idle\n[SIM][t=0.17] ENTER state=Idle\n[SIM][t=0.18] ENTER state=Idle\n[SIM][t=0.19] ENTER state=Idle\n[SIM][t=0.20] ENTER state=Idle\n[SIM][t=0.21] ENTER state=Idle\n[SIM][t=0.22] ENTER state=Idle\n[SIM][t=0.23] ENTER state=Idle\n[SIM][t=0.24] ENTER state=Idle\n[SIM][t=0.25] ENTER state=Idle\n[SIM][t=0.26] ENTER state=Idle\n[SIM][t=0.27] ENTER state=Idle\n[SIM][t=0.28] ENTER state=Idle\n[SIM][t=0.29] ENTER state=Idle\n[SIM][t=0.30] ENTER state=Idle\n[SIM][t=0.31] ENTER state=Idle\n[SIM][t=0.32] ENTER state=Idle\n[SIM][t=0.33] ENTER state=Idle\n[SIM][t=0.34] ENTER state=Idle\n[SIM][t=0.35] ENTER state=Idle\n[SIM][t=0.36] ENTER state=Idle\n[SIM][t=0.37] ENTER state=Idle\n[SIM][t=0.38] ENTER state=Idle\n[SIM][t=0.39] ENTER state=Idle\n[SIM][t=0.40] ENTER state=Idle\n[SIM][t=0.41] ENTER state=Idle\n[SIM][t=0.42] ENTER state=Idle\n[SIM][t=0.43] ENTER state=Idle\n[SIM][t=0.44] ENTER state=Idle\n[SIM][t=0.45] ENTER state=Idle\n[SIM][t=0.46] ENTER state=Idle\n[SIM][t=0.47] ENTER state=Idle\n[SIM][t=0.48] ENTER state=Idle\n[SIM][t=0.49] ENTER state=Idle\n[SIM][t=0.50] ENTER state=Idle\n[SIM][t=0.51] ENTER state=Idle\n[SIM][t=0.52] ENTER state=Idle\n[SIM][t=0.53] ENTER state=Idle\n[SIM][t=0.54] ENTER state=Idle\n[SIM][t=0.55] ENTER state=Idle\n[SIM][t=0.56] ENTER state=Idle\n[SIM][t=0.57] ENTER state=Idle\n[SIM][t=0.58] ENTER state=Idle\n[SIM][t=0.59] ENTER state=Idle\n[SIM][t=0.60] ENTER state=Idle\n[SIM][t=0.61] ENTER state=Idle\n[SIM][t=0.62] ENTER state=Idle\n[SIM][t=0.63] ENTER state=Idle\n[SIM][t=0.64] ENTER state=Idle\n[SIM][t=0.65] ENTER state=Idle\n[SIM][t=0.66] ENTER state=Idle\n[SIM][t=0.67] ENTER state=Idle\n[SIM][t=0.68] ENTER state=Idle\n[SIM][t=0.69] ENTER state=Idle\n[SIM][t=0.70] ENTER state=Idle\n[SIM][t=0.71] ENTER state=Idle\n[SIM][t=0.72] ENTER state=Idle\n[SIM][t=0.73] ENTER state=Idle\n[SIM][t=0.74] ENTER state=Idle\n[SIM][t=0.75] ENTER state=Idle\n[SIM][t=0.76] ENTER state=Idle\n[SIM][t=0.77] ENTER state=Idle\n[SIM][t=0.78] ENTER state=Idle\n[SIM][t=0.79] ENTER state=Idle\n[SIM][t=0.80] ENTER state=Idle\n[SIM][t=0.81] ENTER state=Idle\n[SIM][t=0.82] ENTER state=Idle\n[SIM][t=0.83] ENTER state=Idle\n[SIM][t=0.84] ENTER state=Idle\n[SIM][t=0.85] ENTER state=Idle\n[SIM][t=0.86] ENTER state=Idle\n[SIM][t=0.87] ENTER state=Idle\n[SIM][t=0.88] ENTER state=Idle\n[SIM][t=0.89] ENTER state=Idle\n[SIM][t=0.90] ENTER state=Idle\n[SIM][t=0.91] ENTER state=Idle\n[SIM][t=0.92] ENTER state=Idle\n[SIM][t=0.93] ENTER state=Idle\n[SIM][t=0.94] ENTER state=Idle\n[SIM][t=0.95] ENTER state=Idle\n[SIM][t=0.96] ENTER state=Idle\n[SIM][t=0.97] ENTER state=Idle\n[SIM][t=0.98] ENTER state=Idle\n[SIM][t=0.99] ENTER state=Idle\n[SIM][t=1.00] ENTER state=Idle\n[SIM][t=1.00] TRANSITION Idle -> MovingUp (reason=request_floor > current_floor)\n[SIM][t=1.00] ENTER state=MovingUp\n\n[SYSTEM] Simulation Execution Errors:\n{\'content\': [{\'type\': \'text\', \'text\': \'LOGS:\\n[SIM] Starting simulation\\n[SIM][t=0.00] ENTER state=Idle\\n[SIM][t=0.00] ENTER state=Idle\\n[SIM][t=0.00] ENTER state=Idle\\n[SIM][t=0.01] ENTER state=Idle\\n[SIM][t=0.01] ENTER state=Idle\\n[SIM][t=0.01] ENTER state=Idle\\n[SIM][t=0.01] ENTER state=Idle\\n[SIM][t=0.01] ENTER state=Idle\\n[SIM][t=0.02] ENTER state=Idle\\n[SIM][t=0.02] ENTER state=Idle\\n[SIM][t=0.02] ENTER state=Idle\\n[SIM][t=0.02] ENTER state=Idle\\n[SIM][t=0.02] ENTER state=Idle\\n[SIM][t=0.03] ENTER state=Idle\\n[SIM][t=0.03] ENTER state=Idle\\n[SIM][t=0.03] ENTER state=Idle\\n[SIM][t=0.03] ENTER state=Idle\\n[SIM][t=0.03] ENTER state=Idle\\n[SIM][t=0.04] ENTER state=Idle\\n[SIM][t=0.04] ENTER state=Idle\\n[SIM][t=0.04] ENTER state=Idle\\n[SIM][t=0.04] ENTER state=Idle\\n[SIM][t=0.04] ENTER state=Idle\\n[SIM][t=0.05] ENTER state=Idle\\n[SIM][t=0.05] ENTER state=Idle\\n[SIM][t=0.05] ENTER state=Idle\\n[SIM][t=0.05] ENTER state=Idle\\n[SIM][t=0.05] ENTER state=Idle\\n[SIM][t=0.06] ENTER state=Idle\\n[SIM][t=0.06] ENTER state=Idle\\n[SIM][t=0.06] ENTER state=Idle\\n[SIM][t=0.06] ENTER state=Idle\\n[SIM][t=0.06] ENTER state=Idle\\n[SIM][t=0.07] ENTER state=Idle\\n[SIM][t=0.07] ENTER state=Idle\\n[SIM][t=0.07] ENTER state=Idle\\n[SIM][t=0.07] ENTER state=Idle\\n[SIM][t=0.07] ENTER state=Idle\\n[SIM][t=0.08] ENTER state=Idle\\n[SIM][t=0.08] ENTER state=Idle\\n[SIM][t=0.08] ENTER state=Idle\\n[SIM][t=0.08] ENTER state=Idle\\n[SIM][t=0.08] ENTER state=Idle\\n[SIM][t=0.09] ENTER state=Idle\\n[SIM][t=0.09] ENTER state=Idle\\n[SIM][t=0.09] ENTER state=Idle\\n[SIM][t=0.09] ENTER state=Idle\\n[SIM][t=0.09] ENTER state=Idle\\n[SIM][t=0.10] ENTER state=Idle\\n[SIM][t=0.10] ENTER state=Idle\\n[SIM][t=0.10] ENTER state=Idle\\n[SIM][t=0.10] ENTER state=Idle\\n[SIM][t=0.10] ENTER state=Idle\\n[SIM][t=0.11] ENTER state=Idle\\n[SIM][t=0.11] ENTER state=Idle\\n[SIM][t=0.11] ENTER state=Idle\\n[SIM][t=0.11] ENTER state=Idle\\n[SIM][t=0.11] ENTER state=Idle\\n[SIM][t=0.12] ENTER state=Idle\\n[SIM][t=0.12] ENTER state=Idle\\n[SIM][t=0.12] ENTER state=Idle\\n[SIM][t=0.12] ENTER state=Idle\\n[SIM][t=0.12] ENTER state=Idle\\n[SIM][t=0.13] ENTER state=Idle\\n[SIM][t=0.13] ENTER state=Idle\\n[SIM][t=0.13] ENTER state=Idle\\n[SIM][t=0.13] ENTER state=Idle\\n[SIM][t=0.13] ENTER state=Idle\\n[SIM][t=0.14] ENTER state=Idle\\n[SIM][t=0.14] ENTER state=Idle\\n[SIM][t=0.14] ENTER state=Idle\\n[SIM][t=0.14] ENTER state=Idle\\n[SIM][t=0.14] ENTER state=Idle\\n[SIM][t=0.15] ENTER state=Idle\\n[SIM][t=0.15] ENTER state=Idle\\n[SIM][t=0.15] ENTER state=Idle\\n[SIM][t=0.15] ENTER state=Idle\\n[SIM][t=0.15] ENTER state=Idle\\n[SIM][t=0.16] ENTER state=Idle\\n[SIM][t=0.16] ENTER state=Idle\\n[SIM][t=0.16] ENTER state=Idle\\n[SIM][t=0.16] ENTER state=Idle\\n[SIM][t=0.16] ENTER state=Idle\\n[SIM][t=0.17] ENTER state=Idle\\n[SIM][t=0.17] ENTER state=Idle\\n[SIM][t=0.17] ENTER state=Idle\\n[SIM][t=0.17] ENTER state=Idle\\n[SIM][t=0.17] ENTER state=Idle\\n[SIM][t=0.18] ENTER state=Idle\\n[SIM][t=0.18] ENTER state=Idle\\n[SIM][t=0.18] ENTER state=Idle\\n[SIM][t=0.18] ENTER state=Idle\\n[SIM][t=0.18] ENTER state=Idle\\n[SIM][t=0.19] ENTER state=Idle\\n[SIM][t=0.19] ENTER state=Idle\\n[SIM][t=0.19] ENTER state=Idle\\n[SIM][t=0.19] ENTER state=Idle\\n[SIM][t=0.19] ENTER state=Idle\\n[SIM][t=0.20] ENTER state=Idle\\n[SIM][t=0.20] ENTER state=Idle\\n[SIM][t=0.20] ENTER state=Idle\\n[SIM][t=0.20] ENTER state=Idle\\n[SIM][t=0.20] ENTER state=Idle\\n[SIM][t=0.21] ENTER state=Idle\\n[SIM][t=0.21] ENTER state=Idle\\n[SIM][t=0.21] ENTER state=Idle\\n[SIM][t=0.21] ENTER state=Idle\\n[SIM][t=0.21] ENTER state=Idle\\n[SIM][t=0.22] ENTER state=Idle\\n[SIM][t=0.22] ENTER state=Idle\\n[SIM][t=0.22] ENTER state=Idle\\n[SIM][t=0.22] ENTER state=Idle\\n[SIM][t=0.22] ENTER state=Idle\\n[SIM][t=0.23] ENTER state=Idle\\n[SIM][t=0.23] ENTER state=Idle\\n[SIM][t=0.23] ENTER state=Idle\\n[SIM][t=0.23] ENTER state=Idle\\n[SIM][t=0.23] ENTER state=Idle\\n[SIM][t=0.24] ENTER state=Idle\\n[SIM][t=0.24] ENTER state=Idle\\n[SIM][t=0.24] ENTER state=Idle\\n[SIM][t=0.24] ENTER state=Idle\\n[SIM][t=0.24] ENTER state=Idle\\n[SIM][t=0.25] ENTER state=Idle\\n[SIM][t=0.25] ENTER state=Idle\\n[SIM][t=0.25] ENTER state=Idle\\n[SIM][t=0.25] ENTER state=Idle\\n[SIM][t=0.25] ENTER state=Idle\\n[SIM][t=0.26] ENTER state=Idle\\n[SIM][t=0.26] ENTER state=Idle\\n[SIM][t=0.26] ENTER state=Idle\\n[SIM][t=0.26] ENTER state=Idle\\n[SIM][t=0.26] ENTER state=Idle\\n[SIM][t=0.27] ENTER state=Idle\\n[SIM][t=0.27] ENTER state=Idle\\n[SIM][t=0.27] ENTER state=Idle\\n[SIM][t=0.27] ENTER state=Idle\\n[SIM][t=0.27] ENTER state=Idle\\n[SIM][t=0.28] ENTER state=Idle\\n[SIM][t=0.28] ENTER state=Idle\\n[SIM][t=0.28] ENTER state=Idle\\n[SIM][t=0.28] ENTER state=Idle\\n[SIM][t=0.28] ENTER state=Idle\\n[SIM][t=0.29] ENTER state=Idle\\n[SIM][t=0.29] ENTER state=Idle\\n[SIM][t=0.29] ENTER state=Idle\\n[SIM][t=0.29] ENTER state=Idle\\n[SIM][t=0.29] ENTER state=Idle\\n[SIM][t=0.30] ENTER state=Idle\\n[SIM][t=0.30] ENTER state=Idle\\n[SIM][t=0.30] ENTER state=Idle\\n[SIM][t=0.30] ENTER state=Idle\\n[SIM][t=0.30] ENTER state=Idle\\n[SIM][t=0.31] ENTER state=Idle\\n[SIM][t=0.31] ENTER state=Idle\\n[SIM][t=0.31] ENTER state=Idle\\n[SIM][t=0.31] ENTER state=Idle\\n[SIM][t=0.31] ENTER state=Idle\\n[SIM][t=0.32] ENTER state=Idle\\n[SIM][t=0.32] ENTER state=Idle\\n[SIM][t=0.32] ENTER state=Idle\\n[SIM][t=0.32] ENTER state=Idle\\n[SIM][t=0.32] ENTER state=Idle\\n[SIM][t=0.33] ENTER state=Idle\\n[SIM][t=0.33] ENTER state=Idle\\n[SIM][t=0.33] ENTER state=Idle\\n[SIM][t=0.33] ENTER state=Idle\\n[SIM][t=0.33] ENTER state=Idle\\n[SIM][t=0.34] ENTER state=Idle\\n[SIM][t=0.34] ENTER state=Idle\\n[SIM][t=0.34] ENTER state=Idle\\n[SIM][t=0.34] ENTER state=Idle\\n[SIM][t=0.34] ENTER state=Idle\\n[SIM][t=0.35] ENTER state=Idle\\n[SIM][t=0.35] ENTER state=Idle\\n[SIM][t=0.35] ENTER state=Idle\\n[SIM][t=0.35] ENTER state=Idle\\n[SIM][t=0.35] ENTER state=Idle\\n[SIM][t=0.36] ENTER state=Idle\\n[SIM][t=0.36] ENTER state=Idle\\n[SIM][t=0.36] ENTER state=Idle\\n[SIM][t=0.36] ENTER state=Idle\\n[SIM][t=0.36] ENTER state=Idle\\n[SIM][t=0.37] ENTER state=Idle\\n[SIM][t=0.37] ENTER state=Idle\\n[SIM][t=0.37] ENTER state=Idle\\n[SIM][t=0.37] ENTER state=Idle\\n[SIM][t=0.37] ENTER state=Idle\\n[SIM][t=0.38] ENTER state=Idle\\n[SIM][t=0.38] ENTER state=Idle\\n[SIM][t=0.38] ENTER state=Idle\\n[SIM][t=0.38] ENTER state=Idle\\n[SIM][t=0.38] ENTER state=Idle\\n[SIM][t=0.39] ENTER state=Idle\\n[SIM][t=0.39] ENTER state=Idle\\n[SIM][t=0.39] ENTER state=Idle\\n[SIM][t=0.39] ENTER state=Idle\\n[SIM][t=0.39] ENTER state=Idle\\n[SIM][t=0.40] ENTER state=Idle\\n[SIM][t=0.40] ENTER state=Idle\\n[SIM][t=0.40] ENTER state=Idle\\n[SIM][t=0.40] ENTER state=Idle\\n[SIM][t=0.40] ENTER state=Idle\\n[SIM][t=0.41] ENTER state=Idle\\n[SIM][t=0.41] ENTER state=Idle\\n[SIM][t=0.41] ENTER state=Idle\\n[SIM][t=0.41] ENTER state=Idle\\n[SIM][t=0.41] ENTER state=Idle\\n[SIM][t=0.42] ENTER state=Idle\\n[SIM][t=0.42] ENTER state=Idle\\n[SIM][t=0.42] ENTER state=Idle\\n[SIM][t=0.42] ENTER state=Idle\\n[SIM][t=0.42] ENTER state=Idle\\n[SIM][t=0.43] ENTER state=Idle\\n[SIM][t=0.43] ENTER state=Idle\\n[SIM][t=0.43] ENTER state=Idle\\n[SIM][t=0.43] ENTER state=Idle\\n[SIM][t=0.43] ENTER state=Idle\\n[SIM][t=0.44] ENTER state=Idle\\n[SIM][t=0.44] ENTER state=Idle\\n[SIM][t=0.44] ENTER state=Idle\\n[SIM][t=0.44] ENTER state=Idle\\n[SIM][t=0.44] ENTER state=Idle\\n[SIM][t=0.45] ENTER state=Idle\\n[SIM][t=0.45] ENTER state=Idle\\n[SIM][t=0.45] ENTER state=Idle\\n[SIM][t=0.45] ENTER state=Idle\\n[SIM][t=0.45] ENTER state=Idle\\n[SIM][t=0.46] ENTER state=Idle\\n[SIM][t=0.46] ENTER state=Idle\\n[SIM][t=0.46] ENTER state=Idle\\n[SIM][t=0.46] ENTER state=Idle\\n[SIM][t=0.46] ENTER state=Idle\\n[SIM][t=0.47] ENTER state=Idle\\n[SIM][t=0.47] ENTER state=Idle\\n[SIM][t=0.47] ENTER state=Idle\\n[SIM][t=0.47] ENTER state=Idle\\n[SIM][t=0.47] ENTER state=Idle\\n[SIM][t=0.48] ENTER state=Idle\\n[SIM][t=0.48] ENTER state=Idle\\n[SIM][t=0.48] ENTER state=Idle\\n[SIM][t=0.48] ENTER state=Idle\\n[SIM][t=0.48] ENTER state=Idle\\n[SIM][t=0.49] ENTER state=Idle\\n[SIM][t=0.49] ENTER state=Idle\\n[SIM][t=0.49] ENTER state=Idle\\n[SIM][t=0.49] ENTER state=Idle\\n[SIM][t=0.49] ENTER state=Idle\\n[SIM][t=0.50] ENTER state=Idle\\n[SIM][t=0.50] ENTER state=Idle\\n[SIM][t=0.50] ENTER state=Idle\\n[SIM][t=0.50] ENTER state=Idle\\n[SIM][t=0.50] ENTER state=Idle\\n[SIM][t=0.51] ENTER state=Idle\\n[SIM][t=0.51] ENTER state=Idle\\n[SIM][t=0.51] ENTER state=Idle\\n[SIM][t=0.51] ENTER state=Idle\\n[SIM][t=0.51] ENTER state=Idle\\n[SIM][t=0.52] ENTER state=Idle\\n[SIM][t=0.52] ENTER state=Idle\\n[SIM][t=0.52] ENTER state=Idle\\n[SIM][t=0.52] ENTER state=Idle\\n[SIM][t=0.52] ENTER state=Idle\\n[SIM][t=0.53] ENTER state=Idle\\n[SIM][t=0.53] ENTER state=Idle\\n[SIM][t=0.53] ENTER state=Idle\\n[SIM][t=0.53] ENTER state=Idle\\n[SIM][t=0.53] ENTER state=Idle\\n[SIM][t=0.54] ENTER state=Idle\\n[SIM][t=0.54] ENTER state=Idle\\n[SIM][t=0.54] ENTER state=Idle\\n[SIM][t=0.54] ENTER state=Idle\\n[SIM][t=0.54] ENTER state=Idle\\n[SIM][t=0.55] ENTER state=Idle\\n[SIM][t=0.55] ENTER state=Idle\\n[SIM][t=0.55] ENTER state=Idle\\n[SIM][t=0.55] ENTER state=Idle\\n[SIM][t=0.55] ENTER state=Idle\\n[SIM][t=0.56] ENTER state=Idle\\n[SIM][t=0.56] ENTER state=Idle\\n[SIM][t=0.56] ENTER state=Idle\\n[SIM][t=0.56] ENTER state=Idle\\n[SIM][t=0.56] ENTER state=Idle\\n[SIM][t=0.57] ENTER state=Idle\\n[SIM][t=0.57] ENTER state=Idle\\n[SIM][t=0.57] ENTER state=Idle\\n[SIM][t=0.57] ENTER state=Idle\\n[SIM][t=0.57] ENTER state=Idle\\n[SIM][t=0.58] ENTER state=Idle\\n[SIM][t=0.58] ENTER state=Idle\\n[SIM][t=0.58] ENTER state=Idle\\n[SIM][t=0.58] ENTER state=Idle\\n[SIM][t=0.58] ENTER state=Idle\\n[SIM][t=0.59] ENTER state=Idle\\n[SIM][t=0.59] ENTER state=Idle\\n[SIM][t=0.59] ENTER state=Idle\\n[SIM][t=0.59] ENTER state=Idle\\n[SIM][t=0.59] ENTER state=Idle\\n[SIM][t=0.60] ENTER state=Idle\\n[SIM][t=0.60] ENTER state=Idle\\n[SIM][t=0.60] ENTER state=Idle\\n[SIM][t=0.60] ENTER state=Idle\\n[SIM][t=0.60] ENTER state=Idle\\n[SIM][t=0.61] ENTER state=Idle\\n[SIM][t=0.61] ENTER state=Idle\\n[SIM][t=0.61] ENTER state=Idle\\n[SIM][t=0.61] ENTER state=Idle\\n[SIM][t=0.61] ENTER state=Idle\\n[SIM][t=0.62] ENTER state=Idle\\n[SIM][t=0.62] ENTER state=Idle\\n[SIM][t=0.62] ENTER state=Idle\\n[SIM][t=0.62] ENTER state=Idle\\n[SIM][t=0.62] ENTER state=Idle\\n[SIM][t=0.63] ENTER state=Idle\\n[SIM][t=0.63] ENTER state=Idle\\n[SIM][t=0.63] ENTER state=Idle\\n[SIM][t=0.63] ENTER state=Idle\\n[SIM][t=0.63] ENTER state=Idle\\n[SIM][t=0.64] ENTER state=Idle\\n[SIM][t=0.64] ENTER state=Idle\\n[SIM][t=0.64] ENTER state=Idle\\n[SIM][t=0.64] ENTER state=Idle\\n[SIM][t=0.64] ENTER state=Idle\\n[SIM][t=0.65] ENTER state=Idle\\n[SIM][t=0.65] ENTER state=Idle\\n[SIM][t=0.65] ENTER state=Idle\\n[SIM][t=0.65] ENTER state=Idle\\n[SIM][t=0.65] ENTER state=Idle\\n[SIM][t=0.66] ENTER state=Idle\\n[SIM][t=0.66] ENTER state=Idle\\n[SIM][t=0.66] ENTER state=Idle\\n[SIM][t=0.66] ENTER state=Idle\\n[SIM][t=0.66] ENTER state=Idle\\n[SIM][t=0.67] ENTER state=Idle\\n[SIM][t=0.67] ENTER state=Idle\\n[SIM][t=0.67] ENTER state=Idle\\n[SIM][t=0.67] ENTER state=Idle\\n[SIM][t=0.67] ENTER state=Idle\\n[SIM][t=0.68] ENTER state=Idle\\n[SIM][t=0.68] ENTER state=Idle\\n[SIM][t=0.68] ENTER state=Idle\\n[SIM][t=0.68] ENTER state=Idle\\n[SIM][t=0.68] ENTER state=Idle\\n[SIM][t=0.69] ENTER state=Idle\\n[SIM][t=0.69] ENTER state=Idle\\n[SIM][t=0.69] ENTER state=Idle\\n[SIM][t=0.69] ENTER state=Idle\\n[SIM][t=0.69] ENTER state=Idle\\n[SIM][t=0.70] ENTER state=Idle\\n[SIM][t=0.70] ENTER state=Idle\\n[SIM][t=0.70] ENTER state=Idle\\n[SIM][t=0.70] ENTER state=Idle\\n[SIM][t=0.70] ENTER state=Idle\\n[SIM][t=0.71] ENTER state=Idle\\n[SIM][t=0.71] ENTER state=Idle\\n[SIM][t=0.71] ENTER state=Idle\\n[SIM][t=0.71] ENTER state=Idle\\n[SIM][t=0.71] ENTER state=Idle\\n[SIM][t=0.72] ENTER state=Idle\\n[SIM][t=0.72] ENTER state=Idle\\n[SIM][t=0.72] ENTER state=Idle\\n[SIM][t=0.72] ENTER state=Idle\\n[SIM][t=0.72] ENTER state=Idle\\n[SIM][t=0.73] ENTER state=Idle\\n[SIM][t=0.73] ENTER state=Idle\\n[SIM][t=0.73] ENTER state=Idle\\n[SIM][t=0.73] ENTER state=Idle\\n[SIM][t=0.73] ENTER state=Idle\\n[SIM][t=0.74] ENTER state=Idle\\n[SIM][t=0.74] ENTER state=Idle\\n[SIM][t=0.74] ENTER state=Idle\\n[SIM][t=0.74] ENTER state=Idle\\n[SIM][t=0.74] ENTER state=Idle\\n[SIM][t=0.75] ENTER state=Idle\\n[SIM][t=0.75] ENTER state=Idle\\n[SIM][t=0.75] ENTER state=Idle\\n[SIM][t=0.75] ENTER state=Idle\\n[SIM][t=0.75] ENTER state=Idle\\n[SIM][t=0.76] ENTER state=Idle\\n[SIM][t=0.76] ENTER state=Idle\\n[SIM][t=0.76] ENTER state=Idle\\n[SIM][t=0.76] ENTER state=Idle\\n[SIM][t=0.76] ENTER state=Idle\\n[SIM][t=0.77] ENTER state=Idle\\n[SIM][t=0.77] ENTER state=Idle\\n[SIM][t=0.77] ENTER state=Idle\\n[SIM][t=0.77] ENTER state=Idle\\n[SIM][t=0.77] ENTER state=Idle\\n[SIM][t=0.78] ENTER state=Idle\\n[SIM][t=0.78] ENTER state=Idle\\n[SIM][t=0.78] ENTER state=Idle\\n[SIM][t=0.78] ENTER state=Idle\\n[SIM][t=0.78] ENTER state=Idle\\n[SIM][t=0.79] ENTER state=Idle\\n[SIM][t=0.79] ENTER state=Idle\\n[SIM][t=0.79] ENTER state=Idle\\n[SIM][t=0.79] ENTER state=Idle\\n[SIM][t=0.79] ENTER state=Idle\\n[SIM][t=0.80] ENTER state=Idle\\n[SIM][t=0.80] ENTER state=Idle\\n[SIM][t=0.80] ENTER state=Idle\\n[SIM][t=0.80] ENTER state=Idle\\n[SIM][t=0.80] ENTER state=Idle\\n[SIM][t=0.81] ENTER state=Idle\\n[SIM][t=0.81] ENTER state=Idle\\n[SIM][t=0.81] ENTER state=Idle\\n[SIM][t=0.81] ENTER state=Idle\\n[SIM][t=0.81] ENTER state=Idle\\n[SIM][t=0.82] ENTER state=Idle\\n[SIM][t=0.82] ENTER state=Idle\\n[SIM][t=0.82] ENTER state=Idle\\n[SIM][t=0.82] ENTER state=Idle\\n[SIM][t=0.82] ENTER state=Idle\\n[SIM][t=0.83] ENTER state=Idle\\n[SIM][t=0.83] ENTER state=Idle\\n[SIM][t=0.83] ENTER state=Idle\\n[SIM][t=0.83] ENTER state=Idle\\n[SIM][t=0.83] ENTER state=Idle\\n[SIM][t=0.84] ENTER state=Idle\\n[SIM][t=0.84] ENTER state=Idle\\n[SIM][t=0.84] ENTER state=Idle\\n[SIM][t=0.84] ENTER state=Idle\\n[SIM][t=0.84] ENTER state=Idle\\n[SIM][t=0.85] ENTER state=Idle\\n[SIM][t=0.85] ENTER state=Idle\\n[SIM][t=0.85] ENTER state=Idle\\n[SIM][t=0.85] ENTER state=Idle\\n[SIM][t=0.85] ENTER state=Idle\\n[SIM][t=0.86] ENTER state=Idle\\n[SIM][t=0.86] ENTER state=Idle\\n[SIM][t=0.86] ENTER state=Idle\\n[SIM][t=0.86] ENTER state=Idle\\n[SIM][t=0.86] ENTER state=Idle\\n[SIM][t=0.87] ENTER state=Idle\\n[SIM][t=0.87] ENTER state=Idle\\n[SIM][t=0.87] ENTER state=Idle\\n[SIM][t=0.87] ENTER state=Idle\\n[SIM][t=0.87] ENTER state=Idle\\n[SIM][t=0.88] ENTER state=Idle\\n[SIM][t=0.88] ENTER state=Idle\\n[SIM][t=0.88] ENTER state=Idle\\n[SIM][t=0.88] ENTER state=Idle\\n[SIM][t=0.88] ENTER state=Idle\\n[SIM][t=0.89] ENTER state=Idle\\n[SIM][t=0.89] ENTER state=Idle\\n[SIM][t=0.89] ENTER state=Idle\\n[SIM][t=0.89] ENTER state=Idle\\n[SIM][t=0.89] ENTER state=Idle\\n[SIM][t=0.90] ENTER state=Idle\\n[SIM][t=0.90] ENTER state=Idle\\n[SIM][t=0.90] ENTER state=Idle\\n[SIM][t=0.90] ENTER state=Idle\\n[SIM][t=0.90] ENTER state=Idle\\n[SIM][t=0.91] ENTER state=Idle\\n[SIM][t=0.91] ENTER state=Idle\\n[SIM][t=0.91] ENTER state=Idle\\n[SIM][t=0.91] ENTER state=Idle\\n[SIM][t=0.91] ENTER state=Idle\\n[SIM][t=0.92] ENTER state=Idle\\n[SIM][t=0.92] ENTER state=Idle\\n[SIM][t=0.92] ENTER state=Idle\\n[SIM][t=0.92] ENTER state=Idle\\n[SIM][t=0.92] ENTER state=Idle\\n[SIM][t=0.93] ENTER state=Idle\\n[SIM][t=0.93] ENTER state=Idle\\n[SIM][t=0.93] ENTER state=Idle\\n[SIM][t=0.93] ENTER state=Idle\\n[SIM][t=0.93] ENTER state=Idle\\n[SIM][t=0.94] ENTER state=Idle\\n[SIM][t=0.94] ENTER state=Idle\\n[SIM][t=0.94] ENTER state=Idle\\n[SIM][t=0.94] ENTER state=Idle\\n[SIM][t=0.94] ENTER state=Idle\\n[SIM][t=0.95] ENTER state=Idle\\n[SIM][t=0.95] ENTER state=Idle\\n[SIM][t=0.95] ENTER state=Idle\\n[SIM][t=0.95] ENTER state=Idle\\n[SIM][t=0.95] ENTER state=Idle\\n[SIM][t=0.96] ENTER state=Idle\\n[SIM][t=0.96] ENTER state=Idle\\n[SIM][t=0.96] ENTER state=Idle\\n[SIM][t=0.96] ENTER state=Idle\\n[SIM][t=0.96] ENTER state=Idle\\n[SIM][t=0.97] ENTER state=Idle\\n[SIM][t=0.97] ENTER state=Idle\\n[SIM][t=0.97] ENTER state=Idle\\n[SIM][t=0.97] ENTER state=Idle\\n[SIM][t=0.97] ENTER state=Idle\\n[SIM][t=0.98] ENTER state=Idle\\n[SIM][t=0.98] ENTER state=Idle\\n[SIM][t=0.98] ENTER state=Idle\\n[SIM][t=0.98] ENTER state=Idle\\n[SIM][t=0.98] ENTER state=Idle\\n[SIM][t=0.99] ENTER state=Idle\\n[SIM][t=0.99] ENTER state=Idle\\n[SIM][t=0.99] ENTER state=Idle\\n[SIM][t=0.99] ENTER state=Idle\\n[SIM][t=0.99] ENTER state=Idle\\n[SIM][t=1.00] ENTER state=Idle\\n[SIM][t=1.00] ENTER state=Idle\\n[INPUT] Setting request_floor to 3 at t=1.00\\n[SIM][t=1.00] ENTER state=Idle\\n[SIM][t=1.00] TRANSITION Idle -> MovingUp (reason=request_floor > current_floor)\\n[SIM][t=1.00] ENTER state=MovingUp\\n\\n\\nERRORS:\\nTraceback (most recent call last):\\n  File "C:\\\\Users\\\\24760\\\\AppData\\\\Roaming\\\\Python\\\\Python313\\\\site-packages\\\\simpy\\\\events.py", line 431, in _resume\\n    if event.callbacks is not None:\\n       ^^^^^^^^^^^^^^^\\nAttributeError: \\\'generator\\\' object has no attribute \\\'callbacks\\\'\\n\\nDuring handling of the above exception, another exception occurred:\\n\\nTraceback (most recent call last):\\n  File "E:\\\\VeriSpec\\\\verispec-lite\\\\servers\\\\simulation_server.py", line 41, in execute_simulation_code\\n    exec(code_str, exec_globals)\\n    ~~~~^^^^^^^^^^^^^^^^^^^^^^^^\\n  File "<string>", line 175, in <module>\\n  File "<string>", line 170, in run_simulation\\n  File "C:\\\\Users\\\\24760\\\\AppData\\\\Roaming\\\\Python\\\\Python313\\\\site-packages\\\\simpy\\\\core.py", line 246, in run\\n    self.step()\\n    ~~~~~~~~~^^\\n  File "C:\\\\Users\\\\24760\\\\AppData\\\\Roaming\\\\Python\\\\Python313\\\\site-packages\\\\simpy\\\\core.py", line 196, in step\\n    callback(event)\\n    ~~~~~~~~^^^^^^^\\n  File "C:\\\\Users\\\\24760\\\\AppData\\\\Roaming\\\\Python\\\\Python313\\\\site-packages\\\\simpy\\\\events.py", line 443, in _resume\\n    descr = _describe_frame(self._generator.gi_frame)\\n  File "C:\\\\Users\\\\24760\\\\AppData\\\\Roaming\\\\Python\\\\Python313\\\\site-packages\\\\simpy\\\\events.py", line 645, in _describe_frame\\n    with open(filename) as f:\\n         ~~~~^^^^^^^^^^\\nOSError: [Errno 22] Invalid argument: \\\'<string>\\\'\\n\'}], \'structuredContent\': {\'result\': \'LOGS:\\n[SIM] Starting simulation\\n[SIM][t=0.00] ENTER state=Idle\\n[SIM][t=0.00] ENTER state=Idle\\n[SIM][t=0.00] ENTER state=Idle\\n[SIM][t=0.01] ENTER state=Idle\\n[SIM][t=0.01] ENTER state=Idle\\n[SIM][t=0.01] ENTER state=Idle\\n[SIM][t=0.01] ENTER state=Idle\\n[SIM][t=0.01] ENTER state=Idle\\n[SIM][t=0.02] ENTER state=Idle\\n[SIM][t=0.02] ENTER state=Idle\\n[SIM][t=0.02] ENTER state=Idle\\n[SIM][t=0.02] ENTER state=Idle\\n[SIM][t=0.02] ENTER state=Idle\\n[SIM][t=0.03] ENTER state=Idle\\n[SIM][t=0.03] ENTER state=Idle\\n[SIM][t=0.03] ENTER state=Idle\\n[SIM][t=0.03] ENTER state=Idle\\n[SIM][t=0.03] ENTER state=Idle\\n[SIM][t=0.04] ENTER state=Idle\\n[SIM][t=0.04] ENTER state=Idle\\n[SIM][t=0.04] ENTER state=Idle\\n[SIM][t=0.04] ENTER state=Idle\\n[SIM][t=0.04] ENTER state=Idle\\n[SIM][t=0.05] ENTER state=Idle\\n[SIM][t=0.05] ENTER state=Idle\\n[SIM][t=0.05] ENTER state=Idle\\n[SIM][t=0.05] ENTER state=Idle\\n[SIM][t=0.05] ENTER state=Idle\\n[SIM][t=0.06] ENTER state=Idle\\n[SIM][t=0.06] ENTER state=Idle\\n[SIM][t=0.06] ENTER state=Idle\\n[SIM][t=0.06] ENTER state=Idle\\n[SIM][t=0.06] ENTER state=Idle\\n[SIM][t=0.07] ENTER state=Idle\\n[SIM][t=0.07] ENTER state=Idle\\n[SIM][t=0.07] ENTER state=Idle\\n[SIM][t=0.07] ENTER state=Idle\\n[SIM][t=0.07] ENTER state=Idle\\n[SIM][t=0.08] ENTER state=Idle\\n[SIM][t=0.08] ENTER state=Idle\\n[SIM][t=0.08] ENTER state=Idle\\n[SIM][t=0.08] ENTER state=Idle\\n[SIM][t=0.08] ENTER state=Idle\\n[SIM][t=0.09] ENTER state=Idle\\n[SIM][t=0.09] ENTER state=Idle\\n[SIM][t=0.09] ENTER state=Idle\\n[SIM][t=0.09] ENTER state=Idle\\n[SIM][t=0.09] ENTER state=Idle\\n[SIM][t=0.10] ENTER state=Idle\\n[SIM][t=0.10] ENTER state=Idle\\n[SIM][t=0.10] ENTER state=Idle\\n[SIM][t=0.10] ENTER state=Idle\\n[SIM][t=0.10] ENTER state=Idle\\n[SIM][t=0.11] ENTER state=Idle\\n[SIM][t=0.11] ENTER state=Idle\\n[SIM][t=0.11] ENTER state=Idle\\n[SIM][t=0.11] ENTER state=Idle\\n[SIM][t=0.11] ENTER state=Idle\\n[SIM][t=0.12] ENTER state=Idle\\n[SIM][t=0.12] ENTER state=Idle\\n[SIM][t=0.12] ENTER state=Idle\\n[SIM][t=0.12] ENTER state=Idle\\n[SIM][t=0.12] ENTER state=Idle\\n[SIM][t=0.13] ENTER state=Idle\\n[SIM][t=0.13] ENTER state=Idle\\n[SIM][t=0.13] ENTER state=Idle\\n[SIM][t=0.13] ENTER state=Idle\\n[SIM][t=0.13] ENTER state=Idle\\n[SIM][t=0.14] ENTER state=Idle\\n[SIM][t=0.14] ENTER state=Idle\\n[SIM][t=0.14] ENTER state=Idle\\n[SIM][t=0.14] ENTER state=Idle\\n[SIM][t=0.14] ENTER state=Idle\\n[SIM][t=0.15] ENTER state=Idle\\n[SIM][t=0.15] ENTER state=Idle\\n[SIM][t=0.15] ENTER state=Idle\\n[SIM][t=0.15] ENTER state=Idle\\n[SIM][t=0.15] ENTER state=Idle\\n[SIM][t=0.16] ENTER state=Idle\\n[SIM][t=0.16] ENTER state=Idle\\n[SIM][t=0.16] ENTER state=Idle\\n[SIM][t=0.16] ENTER state=Idle\\n[SIM][t=0.16] ENTER state=Idle\\n[SIM][t=0.17] ENTER state=Idle\\n[SIM][t=0.17] ENTER state=Idle\\n[SIM][t=0.17] ENTER state=Idle\\n[SIM][t=0.17] ENTER state=Idle\\n[SIM][t=0.17] ENTER state=Idle\\n[SIM][t=0.18] ENTER state=Idle\\n[SIM][t=0.18] ENTER state=Idle\\n[SIM][t=0.18] ENTER state=Idle\\n[SIM][t=0.18] ENTER state=Idle\\n[SIM][t=0.18] ENTER state=Idle\\n[SIM][t=0.19] ENTER state=Idle\\n[SIM][t=0.19] ENTER state=Idle\\n[SIM][t=0.19] ENTER state=Idle\\n[SIM][t=0.19] ENTER state=Idle\\n[SIM][t=0.19] ENTER state=Idle\\n[SIM][t=0.20] ENTER state=Idle\\n[SIM][t=0.20] ENTER state=Idle\\n[SIM][t=0.20] ENTER state=Idle\\n[SIM][t=0.20] ENTER state=Idle\\n[SIM][t=0.20] ENTER state=Idle\\n[SIM][t=0.21] ENTER state=Idle\\n[SIM][t=0.21] ENTER state=Idle\\n[SIM][t=0.21] ENTER state=Idle\\n[SIM][t=0.21] ENTER state=Idle\\n[SIM][t=0.21] ENTER state=Idle\\n[SIM][t=0.22] ENTER state=Idle\\n[SIM][t=0.22] ENTER state=Idle\\n[SIM][t=0.22] ENTER state=Idle\\n[SIM][t=0.22] ENTER state=Idle\\n[SIM][t=0.22] ENTER state=Idle\\n[SIM][t=0.23] ENTER state=Idle\\n[SIM][t=0.23] ENTER state=Idle\\n[SIM][t=0.23] ENTER state=Idle\\n[SIM][t=0.23] ENTER state=Idle\\n[SIM][t=0.23] ENTER state=Idle\\n[SIM][t=0.24] ENTER state=Idle\\n[SIM][t=0.24] ENTER state=Idle\\n[SIM][t=0.24] ENTER state=Idle\\n[SIM][t=0.24] ENTER state=Idle\\n[SIM][t=0.24] ENTER state=Idle\\n[SIM][t=0.25] ENTER state=Idle\\n[SIM][t=0.25] ENTER state=Idle\\n[SIM][t=0.25] ENTER state=Idle\\n[SIM][t=0.25] ENTER state=Idle\\n[SIM][t=0.25] ENTER state=Idle\\n[SIM][t=0.26] ENTER state=Idle\\n[SIM][t=0.26] ENTER state=Idle\\n[SIM][t=0.26] ENTER state=Idle\\n[SIM][t=0.26] ENTER state=Idle\\n[SIM][t=0.26] ENTER state=Idle\\n[SIM][t=0.27] ENTER state=Idle\\n[SIM][t=0.27] ENTER state=Idle\\n[SIM][t=0.27] ENTER state=Idle\\n[SIM][t=0.27] ENTER state=Idle\\n[SIM][t=0.27] ENTER state=Idle\\n[SIM][t=0.28] ENTER state=Idle\\n[SIM][t=0.28] ENTER state=Idle\\n[SIM][t=0.28] ENTER state=Idle\\n[SIM][t=0.28] ENTER state=Idle\\n[SIM][t=0.28] ENTER state=Idle\\n[SIM][t=0.29] ENTER state=Idle\\n[SIM][t=0.29] ENTER state=Idle\\n[SIM][t=0.29] ENTER state=Idle\\n[SIM][t=0.29] ENTER state=Idle\\n[SIM][t=0.29] ENTER state=Idle\\n[SIM][t=0.30] ENTER state=Idle\\n[SIM][t=0.30] ENTER state=Idle\\n[SIM][t=0.30] ENTER state=Idle\\n[SIM][t=0.30] ENTER state=Idle\\n[SIM][t=0.30] ENTER state=Idle\\n[SIM][t=0.31] ENTER state=Idle\\n[SIM][t=0.31] ENTER state=Idle\\n[SIM][t=0.31] ENTER state=Idle\\n[SIM][t=0.31] ENTER state=Idle\\n[SIM][t=0.31] ENTER state=Idle\\n[SIM][t=0.32] ENTER state=Idle\\n[SIM][t=0.32] ENTER state=Idle\\n[SIM][t=0.32] ENTER state=Idle\\n[SIM][t=0.32] ENTER state=Idle\\n[SIM][t=0.32] ENTER state=Idle\\n[SIM][t=0.33] ENTER state=Idle\\n[SIM][t=0.33] ENTER state=Idle\\n[SIM][t=0.33] ENTER state=Idle\\n[SIM][t=0.33] ENTER state=Idle\\n[SIM][t=0.33] ENTER state=Idle\\n[SIM][t=0.34] ENTER state=Idle\\n[SIM][t=0.34] ENTER state=Idle\\n[SIM][t=0.34] ENTER state=Idle\\n[SIM][t=0.34] ENTER state=Idle\\n[SIM][t=0.34] ENTER state=Idle\\n[SIM][t=0.35] ENTER state=Idle\\n[SIM][t=0.35] ENTER state=Idle\\n[SIM][t=0.35] ENTER state=Idle\\n[SIM][t=0.35] ENTER state=Idle\\n[SIM][t=0.35] ENTER state=Idle\\n[SIM][t=0.36] ENTER state=Idle\\n[SIM][t=0.36] ENTER state=Idle\\n[SIM][t=0.36] ENTER state=Idle\\n[SIM][t=0.36] ENTER state=Idle\\n[SIM][t=0.36] ENTER state=Idle\\n[SIM][t=0.37] ENTER state=Idle\\n[SIM][t=0.37] ENTER state=Idle\\n[SIM][t=0.37] ENTER state=Idle\\n[SIM][t=0.37] ENTER state=Idle\\n[SIM][t=0.37] ENTER state=Idle\\n[SIM][t=0.38] ENTER state=Idle\\n[SIM][t=0.38] ENTER state=Idle\\n[SIM][t=0.38] ENTER state=Idle\\n[SIM][t=0.38] ENTER state=Idle\\n[SIM][t=0.38] ENTER state=Idle\\n[SIM][t=0.39] ENTER state=Idle\\n[SIM][t=0.39] ENTER state=Idle\\n[SIM][t=0.39] ENTER state=Idle\\n[SIM][t=0.39] ENTER state=Idle\\n[SIM][t=0.39] ENTER state=Idle\\n[SIM][t=0.40] ENTER state=Idle\\n[SIM][t=0.40] ENTER state=Idle\\n[SIM][t=0.40] ENTER state=Idle\\n[SIM][t=0.40] ENTER state=Idle\\n[SIM][t=0.40] ENTER state=Idle\\n[SIM][t=0.41] ENTER state=Idle\\n[SIM][t=0.41] ENTER state=Idle\\n[SIM][t=0.41] ENTER state=Idle\\n[SIM][t=0.41] ENTER state=Idle\\n[SIM][t=0.41] ENTER state=Idle\\n[SIM][t=0.42] ENTER state=Idle\\n[SIM][t=0.42] ENTER state=Idle\\n[SIM][t=0.42] ENTER state=Idle\\n[SIM][t=0.42] ENTER state=Idle\\n[SIM][t=0.42] ENTER state=Idle\\n[SIM][t=0.43] ENTER state=Idle\\n[SIM][t=0.43] ENTER state=Idle\\n[SIM][t=0.43] ENTER state=Idle\\n[SIM][t=0.43] ENTER state=Idle\\n[SIM][t=0.43] ENTER state=Idle\\n[SIM][t=0.44] ENTER state=Idle\\n[SIM][t=0.44] ENTER state=Idle\\n[SIM][t=0.44] ENTER state=Idle\\n[SIM][t=0.44] ENTER state=Idle\\n[SIM][t=0.44] ENTER state=Idle\\n[SIM][t=0.45] ENTER state=Idle\\n[SIM][t=0.45] ENTER state=Idle\\n[SIM][t=0.45] ENTER state=Idle\\n[SIM][t=0.45] ENTER state=Idle\\n[SIM][t=0.45] ENTER state=Idle\\n[SIM][t=0.46] ENTER state=Idle\\n[SIM][t=0.46] ENTER state=Idle\\n[SIM][t=0.46] ENTER state=Idle\\n[SIM][t=0.46] ENTER state=Idle\\n[SIM][t=0.46] ENTER state=Idle\\n[SIM][t=0.47] ENTER state=Idle\\n[SIM][t=0.47] ENTER state=Idle\\n[SIM][t=0.47] ENTER state=Idle\\n[SIM][t=0.47] ENTER state=Idle\\n[SIM][t=0.47] ENTER state=Idle\\n[SIM][t=0.48] ENTER state=Idle\\n[SIM][t=0.48] ENTER state=Idle\\n[SIM][t=0.48] ENTER state=Idle\\n[SIM][t=0.48] ENTER state=Idle\\n[SIM][t=0.48] ENTER state=Idle\\n[SIM][t=0.49] ENTER state=Idle\\n[SIM][t=0.49] ENTER state=Idle\\n[SIM][t=0.49] ENTER state=Idle\\n[SIM][t=0.49] ENTER state=Idle\\n[SIM][t=0.49] ENTER state=Idle\\n[SIM][t=0.50] ENTER state=Idle\\n[SIM][t=0.50] ENTER state=Idle\\n[SIM][t=0.50] ENTER state=Idle\\n[SIM][t=0.50] ENTER state=Idle\\n[SIM][t=0.50] ENTER state=Idle\\n[SIM][t=0.51] ENTER state=Idle\\n[SIM][t=0.51] ENTER state=Idle\\n[SIM][t=0.51] ENTER state=Idle\\n[SIM][t=0.51] ENTER state=Idle\\n[SIM][t=0.51] ENTER state=Idle\\n[SIM][t=0.52] ENTER state=Idle\\n[SIM][t=0.52] ENTER state=Idle\\n[SIM][t=0.52] ENTER state=Idle\\n[SIM][t=0.52] ENTER state=Idle\\n[SIM][t=0.52] ENTER state=Idle\\n[SIM][t=0.53] ENTER state=Idle\\n[SIM][t=0.53] ENTER state=Idle\\n[SIM][t=0.53] ENTER state=Idle\\n[SIM][t=0.53] ENTER state=Idle\\n[SIM][t=0.53] ENTER state=Idle\\n[SIM][t=0.54] ENTER state=Idle\\n[SIM][t=0.54] ENTER state=Idle\\n[SIM][t=0.54] ENTER state=Idle\\n[SIM][t=0.54] ENTER state=Idle\\n[SIM][t=0.54] ENTER state=Idle\\n[SIM][t=0.55] ENTER state=Idle\\n[SIM][t=0.55] ENTER state=Idle\\n[SIM][t=0.55] ENTER state=Idle\\n[SIM][t=0.55] ENTER state=Idle\\n[SIM][t=0.55] ENTER state=Idle\\n[SIM][t=0.56] ENTER state=Idle\\n[SIM][t=0.56] ENTER state=Idle\\n[SIM][t=0.56] ENTER state=Idle\\n[SIM][t=0.56] ENTER state=Idle\\n[SIM][t=0.56] ENTER state=Idle\\n[SIM][t=0.57] ENTER state=Idle\\n[SIM][t=0.57] ENTER state=Idle\\n[SIM][t=0.57] ENTER state=Idle\\n[SIM][t=0.57] ENTER state=Idle\\n[SIM][t=0.57] ENTER state=Idle\\n[SIM][t=0.58] ENTER state=Idle\\n[SIM][t=0.58] ENTER state=Idle\\n[SIM][t=0.58] ENTER state=Idle\\n[SIM][t=0.58] ENTER state=Idle\\n[SIM][t=0.58] ENTER state=Idle\\n[SIM][t=0.59] ENTER state=Idle\\n[SIM][t=0.59] ENTER state=Idle\\n[SIM][t=0.59] ENTER state=Idle\\n[SIM][t=0.59] ENTER state=Idle\\n[SIM][t=0.59] ENTER state=Idle\\n[SIM][t=0.60] ENTER state=Idle\\n[SIM][t=0.60] ENTER state=Idle\\n[SIM][t=0.60] ENTER state=Idle\\n[SIM][t=0.60] ENTER state=Idle\\n[SIM][t=0.60] ENTER state=Idle\\n[SIM][t=0.61] ENTER state=Idle\\n[SIM][t=0.61] ENTER state=Idle\\n[SIM][t=0.61] ENTER state=Idle\\n[SIM][t=0.61] ENTER state=Idle\\n[SIM][t=0.61] ENTER state=Idle\\n[SIM][t=0.62] ENTER state=Idle\\n[SIM][t=0.62] ENTER state=Idle\\n[SIM][t=0.62] ENTER state=Idle\\n[SIM][t=0.62] ENTER state=Idle\\n[SIM][t=0.62] ENTER state=Idle\\n[SIM][t=0.63] ENTER state=Idle\\n[SIM][t=0.63] ENTER state=Idle\\n[SIM][t=0.63] ENTER state=Idle\\n[SIM][t=0.63] ENTER state=Idle\\n[SIM][t=0.63] ENTER state=Idle\\n[SIM][t=0.64] ENTER state=Idle\\n[SIM][t=0.64] ENTER state=Idle\\n[SIM][t=0.64] ENTER state=Idle\\n[SIM][t=0.64] ENTER state=Idle\\n[SIM][t=0.64] ENTER state=Idle\\n[SIM][t=0.65] ENTER state=Idle\\n[SIM][t=0.65] ENTER state=Idle\\n[SIM][t=0.65] ENTER state=Idle\\n[SIM][t=0.65] ENTER state=Idle\\n[SIM][t=0.65] ENTER state=Idle\\n[SIM][t=0.66] ENTER state=Idle\\n[SIM][t=0.66] ENTER state=Idle\\n[SIM][t=0.66] ENTER state=Idle\\n[SIM][t=0.66] ENTER state=Idle\\n[SIM][t=0.66] ENTER state=Idle\\n[SIM][t=0.67] ENTER state=Idle\\n[SIM][t=0.67] ENTER state=Idle\\n[SIM][t=0.67] ENTER state=Idle\\n[SIM][t=0.67] ENTER state=Idle\\n[SIM][t=0.67] ENTER state=Idle\\n[SIM][t=0.68] ENTER state=Idle\\n[SIM][t=0.68] ENTER state=Idle\\n[SIM][t=0.68] ENTER state=Idle\\n[SIM][t=0.68] ENTER state=Idle\\n[SIM][t=0.68] ENTER state=Idle\\n[SIM][t=0.69] ENTER state=Idle\\n[SIM][t=0.69] ENTER state=Idle\\n[SIM][t=0.69] ENTER state=Idle\\n[SIM][t=0.69] ENTER state=Idle\\n[SIM][t=0.69] ENTER state=Idle\\n[SIM][t=0.70] ENTER state=Idle\\n[SIM][t=0.70] ENTER state=Idle\\n[SIM][t=0.70] ENTER state=Idle\\n[SIM][t=0.70] ENTER state=Idle\\n[SIM][t=0.70] ENTER state=Idle\\n[SIM][t=0.71] ENTER state=Idle\\n[SIM][t=0.71] ENTER state=Idle\\n[SIM][t=0.71] ENTER state=Idle\\n[SIM][t=0.71] ENTER state=Idle\\n[SIM][t=0.71] ENTER state=Idle\\n[SIM][t=0.72] ENTER state=Idle\\n[SIM][t=0.72] ENTER state=Idle\\n[SIM][t=0.72] ENTER state=Idle\\n[SIM][t=0.72] ENTER state=Idle\\n[SIM][t=0.72] ENTER state=Idle\\n[SIM][t=0.73] ENTER state=Idle\\n[SIM][t=0.73] ENTER state=Idle\\n[SIM][t=0.73] ENTER state=Idle\\n[SIM][t=0.73] ENTER state=Idle\\n[SIM][t=0.73] ENTER state=Idle\\n[SIM][t=0.74] ENTER state=Idle\\n[SIM][t=0.74] ENTER state=Idle\\n[SIM][t=0.74] ENTER state=Idle\\n[SIM][t=0.74] ENTER state=Idle\\n[SIM][t=0.74] ENTER state=Idle\\n[SIM][t=0.75] ENTER state=Idle\\n[SIM][t=0.75] ENTER state=Idle\\n[SIM][t=0.75] ENTER state=Idle\\n[SIM][t=0.75] ENTER state=Idle\\n[SIM][t=0.75] ENTER state=Idle\\n[SIM][t=0.76] ENTER state=Idle\\n[SIM][t=0.76] ENTER state=Idle\\n[SIM][t=0.76] ENTER state=Idle\\n[SIM][t=0.76] ENTER state=Idle\\n[SIM][t=0.76] ENTER state=Idle\\n[SIM][t=0.77] ENTER state=Idle\\n[SIM][t=0.77] ENTER state=Idle\\n[SIM][t=0.77] ENTER state=Idle\\n[SIM][t=0.77] ENTER state=Idle\\n[SIM][t=0.77] ENTER state=Idle\\n[SIM][t=0.78] ENTER state=Idle\\n[SIM][t=0.78] ENTER state=Idle\\n[SIM][t=0.78] ENTER state=Idle\\n[SIM][t=0.78] ENTER state=Idle\\n[SIM][t=0.78] ENTER state=Idle\\n[SIM][t=0.79] ENTER state=Idle\\n[SIM][t=0.79] ENTER state=Idle\\n[SIM][t=0.79] ENTER state=Idle\\n[SIM][t=0.79] ENTER state=Idle\\n[SIM][t=0.79] ENTER state=Idle\\n[SIM][t=0.80] ENTER state=Idle\\n[SIM][t=0.80] ENTER state=Idle\\n[SIM][t=0.80] ENTER state=Idle\\n[SIM][t=0.80] ENTER state=Idle\\n[SIM][t=0.80] ENTER state=Idle\\n[SIM][t=0.81] ENTER state=Idle\\n[SIM][t=0.81] ENTER state=Idle\\n[SIM][t=0.81] ENTER state=Idle\\n[SIM][t=0.81] ENTER state=Idle\\n[SIM][t=0.81] ENTER state=Idle\\n[SIM][t=0.82] ENTER state=Idle\\n[SIM][t=0.82] ENTER state=Idle\\n[SIM][t=0.82] ENTER state=Idle\\n[SIM][t=0.82] ENTER state=Idle\\n[SIM][t=0.82] ENTER state=Idle\\n[SIM][t=0.83] ENTER state=Idle\\n[SIM][t=0.83] ENTER state=Idle\\n[SIM][t=0.83] ENTER state=Idle\\n[SIM][t=0.83] ENTER state=Idle\\n[SIM][t=0.83] ENTER state=Idle\\n[SIM][t=0.84] ENTER state=Idle\\n[SIM][t=0.84] ENTER state=Idle\\n[SIM][t=0.84] ENTER state=Idle\\n[SIM][t=0.84] ENTER state=Idle\\n[SIM][t=0.84] ENTER state=Idle\\n[SIM][t=0.85] ENTER state=Idle\\n[SIM][t=0.85] ENTER state=Idle\\n[SIM][t=0.85] ENTER state=Idle\\n[SIM][t=0.85] ENTER state=Idle\\n[SIM][t=0.85] ENTER state=Idle\\n[SIM][t=0.86] ENTER state=Idle\\n[SIM][t=0.86] ENTER state=Idle\\n[SIM][t=0.86] ENTER state=Idle\\n[SIM][t=0.86] ENTER state=Idle\\n[SIM][t=0.86] ENTER state=Idle\\n[SIM][t=0.87] ENTER state=Idle\\n[SIM][t=0.87] ENTER state=Idle\\n[SIM][t=0.87] ENTER state=Idle\\n[SIM][t=0.87] ENTER state=Idle\\n[SIM][t=0.87] ENTER state=Idle\\n[SIM][t=0.88] ENTER state=Idle\\n[SIM][t=0.88] ENTER state=Idle\\n[SIM][t=0.88] ENTER state=Idle\\n[SIM][t=0.88] ENTER state=Idle\\n[SIM][t=0.88] ENTER state=Idle\\n[SIM][t=0.89] ENTER state=Idle\\n[SIM][t=0.89] ENTER state=Idle\\n[SIM][t=0.89] ENTER state=Idle\\n[SIM][t=0.89] ENTER state=Idle\\n[SIM][t=0.89] ENTER state=Idle\\n[SIM][t=0.90] ENTER state=Idle\\n[SIM][t=0.90] ENTER state=Idle\\n[SIM][t=0.90] ENTER state=Idle\\n[SIM][t=0.90] ENTER state=Idle\\n[SIM][t=0.90] ENTER state=Idle\\n[SIM][t=0.91] ENTER state=Idle\\n[SIM][t=0.91] ENTER state=Idle\\n[SIM][t=0.91] ENTER state=Idle\\n[SIM][t=0.91] ENTER state=Idle\\n[SIM][t=0.91] ENTER state=Idle\\n[SIM][t=0.92] ENTER state=Idle\\n[SIM][t=0.92] ENTER state=Idle\\n[SIM][t=0.92] ENTER state=Idle\\n[SIM][t=0.92] ENTER state=Idle\\n[SIM][t=0.92] ENTER state=Idle\\n[SIM][t=0.93] ENTER state=Idle\\n[SIM][t=0.93] ENTER state=Idle\\n[SIM][t=0.93] ENTER state=Idle\\n[SIM][t=0.93] ENTER state=Idle\\n[SIM][t=0.93] ENTER state=Idle\\n[SIM][t=0.94] ENTER state=Idle\\n[SIM][t=0.94] ENTER state=Idle\\n[SIM][t=0.94] ENTER state=Idle\\n[SIM][t=0.94] ENTER state=Idle\\n[SIM][t=0.94] ENTER state=Idle\\n[SIM][t=0.95] ENTER state=Idle\\n[SIM][t=0.95] ENTER state=Idle\\n[SIM][t=0.95] ENTER state=Idle\\n[SIM][t=0.95] ENTER state=Idle\\n[SIM][t=0.95] ENTER state=Idle\\n[SIM][t=0.96] ENTER state=Idle\\n[SIM][t=0.96] ENTER state=Idle\\n[SIM][t=0.96] ENTER state=Idle\\n[SIM][t=0.96] ENTER state=Idle\\n[SIM][t=0.96] ENTER state=Idle\\n[SIM][t=0.97] ENTER state=Idle\\n[SIM][t=0.97] ENTER state=Idle\\n[SIM][t=0.97] ENTER state=Idle\\n[SIM][t=0.97] ENTER state=Idle\\n[SIM][t=0.97] ENTER state=Idle\\n[SIM][t=0.98] ENTER state=Idle\\n[SIM][t=0.98] ENTER state=Idle\\n[SIM][t=0.98] ENTER state=Idle\\n[SIM][t=0.98] ENTER state=Idle\\n[SIM][t=0.98] ENTER state=Idle\\n[SIM][t=0.99] ENTER state=Idle\\n[SIM][t=0.99] ENTER state=Idle\\n[SIM][t=0.99] ENTER state=Idle\\n[SIM][t=0.99] ENTER state=Idle\\n[SIM][t=0.99] ENTER state=Idle\\n[SIM][t=1.00] ENTER state=Idle\\n[SIM][t=1.00] ENTER state=Idle\\n[INPUT] Setting request_floor to 3 at t=1.00\\n[SIM][t=1.00] ENTER state=Idle\\n[SIM][t=1.00] TRANSITION Idle -> MovingUp (reason=request_floor > current_floor)\\n[SIM][t=1.00] ENTER state=MovingUp\\n\\n\\nERRORS:\\nTraceback (most recent call last):\\n  File "C:\\\\Users\\\\24760\\\\AppData\\\\Roaming\\\\Python\\\\Python313\\\\site-packages\\\\simpy\\\\events.py", line 431, in _resume\\n    if event.callbacks is not None:\\n       ^^^^^^^^^^^^^^^\\nAttributeError: \\\'generator\\\' object has no attribute \\\'callbacks\\\'\\n\\nDuring handling of the above exception, another exception occurred:\\n\\nTraceback (most recent call last):\\n  File "E:\\\\VeriSpec\\\\verispec-lite\\\\servers\\\\simulation_server.py", line 41, in execute_simulation_code\\n    exec(code_str, exec_globals)\\n    ~~~~^^^^^^^^^^^^^^^^^^^^^^^^\\n  File "<string>", line 175, in <module>\\n  File "<string>", line 170, in run_simulation\\n  File "C:\\\\Users\\\\24760\\\\AppData\\\\Roaming\\\\Python\\\\Python313\\\\site-packages\\\\simpy\\\\core.py", line 246, in run\\n    self.step()\\n    ~~~~~~~~~^^\\n  File "C:\\\\Users\\\\24760\\\\AppData\\\\Roaming\\\\Python\\\\Python313\\\\site-packages\\\\simpy\\\\core.py", line 196, in step\\n    callback(event)\\n    ~~~~~~~~^^^^^^^\\n  File "C:\\\\Users\\\\24760\\\\AppData\\\\Roaming\\\\Python\\\\Python313\\\\site-packages\\\\simpy\\\\events.py", line 443, in _resume\\n    descr = _describe_frame(self._generator.gi_frame)\\n  File "C:\\\\Users\\\\24760\\\\AppData\\\\Roaming\\\\Python\\\\Python313\\\\site-packages\\\\simpy\\\\events.py", line 645, in _describe_frame\\n    with open(filename) as f:\\n         ~~~~^^^^^^^^^^\\nOSError: [Errno 22] Invalid argument: \\\'<string>\\\'\\n\'}, \'isError\': False}\n'}
    Retrying...

[2] Architect Agent: Generating Code (Attempt 3)...

 ### Created new session: debug_session_id

User > Specification:
{'states': [{'name': 'Idle'}, {'name': 'MovingUp'}, {'name': 'MovingDown'}, {'name': 'DoorOpen'}], 'transitions': [{'from': 'Idle', 'to': 'MovingUp', 'condition': 'request_floor > current_floor'}, {'from': 'Idle', 'to': 'MovingDown', 'condition': 'request_floor < current_floor'}, {'from': 'MovingUp', 'to': 'DoorOpen', 'condition': 'current_floor == request_floor'}, {'from': 'MovingDown', 'to': 'DoorOpen', 'condition': 'current_floor == request_floor'}, {'from': 'DoorOpen', 'to': 'Idle', 'condition': 'no requests'}, {'from': 'DoorOpen', 'to': 'MovingUp', 'condition': 'request_floor > current_floor'}, {'from': 'DoorOpen', 'to': 'MovingDown', 'condition': 'request_floor < current_floor'}], 'constraints': [{'param': 'DoorOpen_duration', 'value': 5}, {'param': 'MovingUp_increment_time', 'value': 2}, {'param': 'MovingDown_decrement_time', 'value': 2}]}

FEEDBACK FROM PREVIOUS ATTEMPT (FIX THESE ERRORS):
Verification Failed: Simulation code failed to execute due to a Python error: AttributeError: 'generator' object has no attribute 'callbacks'. This indicates an issue within the SimPy framework or how it's being used in the simulation code.
Logs/Errors:
[SIM] Starting simulation
[SIM][t=0.00] ENTER state=Idle
[SIM][t=0.01] ENTER state=Idle
[SIM][t=0.02] ENTER state=Idle
[SIM][t=0.03] ENTER state=Idle
[SIM][t=0.04] ENTER state=Idle
[SIM][t=0.05] ENTER state=Idle
[SIM][t=0.06] ENTER state=Idle
[SIM][t=0.07] ENTER state=Idle
[SIM][t=0.08] ENTER state=Idle
[SIM][t=0.09] ENTER state=Idle
[SIM][t=0.10] ENTER state=Idle
[SIM][t=0.11] ENTER state=Idle
[SIM][t=0.12] ENTER state=Idle
[SIM][t=0.13] ENTER state=Idle
[SIM][t=0.14] ENTER state=Idle
[SIM][t=0.15] ENTER state=Idle
[SIM][t=0.16] ENTER state=Idle
[SIM][t=0.17] ENTER state=Idle
[SIM][t=0.18] ENTER state=Idle
[SIM][t=0.19] ENTER state=Idle
[SIM][t=0.20] ENTER state=Idle
[SIM][t=0.21] ENTER state=Idle
[SIM][t=0.22] ENTER state=Idle
[SIM][t=0.23] ENTER state=Idle
[SIM][t=0.24] ENTER state=Idle
[SIM][t=0.25] ENTER state=Idle
[SIM][t=0.26] ENTER state=Idle
[SIM][t=0.27] ENTER state=Idle
[SIM][t=0.28] ENTER state=Idle
[SIM][t=0.29] ENTER state=Idle
[SIM][t=0.30] ENTER state=Idle
[SIM][t=0.31] ENTER state=Idle
[SIM][t=0.32] ENTER state=Idle
[SIM][t=0.33] ENTER state=Idle
[SIM][t=0.34] ENTER state=Idle
[SIM][t=0.35] ENTER state=Idle
[SIM][t=0.36] ENTER state=Idle
[SIM][t=0.37] ENTER state=Idle
[SIM][t=0.38] ENTER state=Idle
[SIM][t=0.39] ENTER state=Idle
[SIM][t=0.40] ENTER state=Idle
[SIM][t=0.41] ENTER state=Idle
[SIM][t=0.42] ENTER state=Idle
[SIM][t=0.43] ENTER state=Idle
[SIM][t=0.44] ENTER state=Idle
[SIM][t=0.45] ENTER state=Idle
[SIM][t=0.46] ENTER state=Idle
[SIM][t=0.47] ENTER state=Idle
[SIM][t=0.48] ENTER state=Idle
[SIM][t=0.49] ENTER state=Idle
[SIM][t=0.50] ENTER state=Idle
[SIM][t=0.51] ENTER state=Idle
[SIM][t=0.52] ENTER state=Idle
[SIM][t=0.53] ENTER state=Idle
[SIM][t=0.54] ENTER state=Idle
[SIM][t=0.55] ENTER state=Idle
[SIM][t=0.56] ENTER state=Idle
[SIM][t=0.57] ENTER state=Idle
[SIM][t=0.58] ENTER state=Idle
[SIM][t=0.59] ENTER state=Idle
[SIM][t=0.60] ENTER state=Idle
[SIM][t=0.61] ENTER state=Idle
[SIM][t=0.62] ENTER state=Idle
[SIM][t=0.63] ENTER state=Idle
[SIM][t=0.64] ENTER state=Idle
[SIM][t=0.65] ENTER state=Idle
[SIM][t=0.66] ENTER state=Idle
[SIM][t=0.67] ENTER state=Idle
[SIM][t=0.68] ENTER state=Idle
[SIM][t=0.69] ENTER state=Idle
[SIM][t=0.70] ENTER state=Idle
[SIM][t=0.71] ENTER state=Idle
[SIM][t=0.72] ENTER state=Idle
[SIM][t=0.73] ENTER state=Idle
[SIM][t=0.74] ENTER state=Idle
[SIM][t=0.75] ENTER state=Idle
[SIM][t=0.76] ENTER state=Idle
[SIM][t=0.77] ENTER state=Idle
[SIM][t=0.78] ENTER state=Idle
[SIM][t=0.79] ENTER state=Idle
[SIM][t=0.80] ENTER state=Idle
[SIM][t=0.81] ENTER state=Idle
[SIM][t=0.82] ENTER state=Idle
[SIM][t=0.83] ENTER state=Idle
[SIM][t=0.84] ENTER state=Idle
[SIM][t=0.85] ENTER state=Idle
[SIM][t=0.86] ENTER state=Idle
[SIM][t=0.87] ENTER state=Idle
[SIM][t=0.88] ENTER state=Idle
[SIM][t=0.89] ENTER state=Idle
[SIM][t=0.90] ENTER state=Idle
[SIM][t=0.91] ENTER state=Idle
[SIM][t=0.92] ENTER state=Idle
[SIM][t=0.93] ENTER state=Idle
[SIM][t=0.94] ENTER state=Idle
[SIM][t=0.95] ENTER state=Idle
[SIM][t=0.96] ENTER state=Idle
[SIM][t=0.97] ENTER state=Idle
[SIM][t=0.98] ENTER state=Idle
[SIM][t=0.99] ENTER state=Idle
[SIM][t=1.00] ENTER state=Idle
[SIM][t=1.00] TRANSITION Idle -> MovingUp (reason=request_floor > current_floor)
[SIM][t=1.00] ENTER state=MovingUp

[SYSTEM] Simulation Execution Errors:
{'content': [{'type': 'text', 'text': 'LOGS:\n[SIM] Starting simulation\n[SIM][t=0.00] ENTER state=Idle\n[SIM][t=0.00] ENTER state=Idle\n[SIM][t=0.00] ENTER state=Idle\n[SIM][t=0.01] ENTER state=Idle\n[SIM][t=0.01] ENTER state=Idle\n[SIM][t=0.01] ENTER state=Idle\n[SIM][t=0.01] ENTER state=Idle\n[SIM][t=0.01] ENTER state=Idle\n[SIM][t=0.02] ENTER state=Idle\n[SIM][t=0.02] ENTER state=Idle\n[SIM][t=0.02] ENTER state=Idle\n[SIM][t=0.02] ENTER state=Idle\n[SIM][t=0.02] ENTER state=Idle\n[SIM][t=0.03] ENTER state=Idle\n[SIM][t=0.03] ENTER state=Idle\n[SIM][t=0.03] ENTER state=Idle\n[SIM][t=0.03] ENTER state=Idle\n[SIM][t=0.03] ENTER state=Idle\n[SIM][t=0.04] ENTER state=Idle\n[SIM][t=0.04] ENTER state=Idle\n[SIM][t=0.04] ENTER state=Idle\n[SIM][t=0.04] ENTER state=Idle\n[SIM][t=0.04] ENTER state=Idle\n[SIM][t=0.05] ENTER state=Idle\n[SIM][t=0.05] ENTER state=Idle\n[SIM][t=0.05] ENTER state=Idle\n[SIM][t=0.05] ENTER state=Idle\n[SIM][t=0.05] ENTER state=Idle\n[SIM][t=0.06] ENTER state=Idle\n[SIM][t=0.06] ENTER state=Idle\n[SIM][t=0.06] ENTER state=Idle\n[SIM][t=0.06] ENTER state=Idle\n[SIM][t=0.06] ENTER state=Idle\n[SIM][t=0.07] ENTER state=Idle\n[SIM][t=0.07] ENTER state=Idle\n[SIM][t=0.07] ENTER state=Idle\n[SIM][t=0.07] ENTER state=Idle\n[SIM][t=0.07] ENTER state=Idle\n[SIM][t=0.08] ENTER state=Idle\n[SIM][t=0.08] ENTER state=Idle\n[SIM][t=0.08] ENTER state=Idle\n[SIM][t=0.08] ENTER state=Idle\n[SIM][t=0.08] ENTER state=Idle\n[SIM][t=0.09] ENTER state=Idle\n[SIM][t=0.09] ENTER state=Idle\n[SIM][t=0.09] ENTER state=Idle\n[SIM][t=0.09] ENTER state=Idle\n[SIM][t=0.09] ENTER state=Idle\n[SIM][t=0.10] ENTER state=Idle\n[SIM][t=0.10] ENTER state=Idle\n[SIM][t=0.10] ENTER state=Idle\n[SIM][t=0.10] ENTER state=Idle\n[SIM][t=0.10] ENTER state=Idle\n[SIM][t=0.11] ENTER state=Idle\n[SIM][t=0.11] ENTER state=Idle\n[SIM][t=0.11] ENTER state=Idle\n[SIM][t=0.11] ENTER state=Idle\n[SIM][t=0.11] ENTER state=Idle\n[SIM][t=0.12] ENTER state=Idle\n[SIM][t=0.12] ENTER state=Idle\n[SIM][t=0.12] ENTER state=Idle\n[SIM][t=0.12] ENTER state=Idle\n[SIM][t=0.12] ENTER state=Idle\n[SIM][t=0.13] ENTER state=Idle\n[SIM][t=0.13] ENTER state=Idle\n[SIM][t=0.13] ENTER state=Idle\n[SIM][t=0.13] ENTER state=Idle\n[SIM][t=0.13] ENTER state=Idle\n[SIM][t=0.14] ENTER state=Idle\n[SIM][t=0.14] ENTER state=Idle\n[SIM][t=0.14] ENTER state=Idle\n[SIM][t=0.14] ENTER state=Idle\n[SIM][t=0.14] ENTER state=Idle\n[SIM][t=0.15] ENTER state=Idle\n[SIM][t=0.15] ENTER state=Idle\n[SIM][t=0.15] ENTER state=Idle\n[SIM][t=0.15] ENTER state=Idle\n[SIM][t=0.15] ENTER state=Idle\n[SIM][t=0.16] ENTER state=Idle\n[SIM][t=0.16] ENTER state=Idle\n[SIM][t=0.16] ENTER state=Idle\n[SIM][t=0.16] ENTER state=Idle\n[SIM][t=0.16] ENTER state=Idle\n[SIM][t=0.17] ENTER state=Idle\n[SIM][t=0.17] ENTER state=Idle\n[SIM][t=0.17] ENTER state=Idle\n[SIM][t=0.17] ENTER state=Idle\n[SIM][t=0.17] ENTER state=Idle\n[SIM][t=0.18] ENTER state=Idle\n[SIM][t=0.18] ENTER state=Idle\n[SIM][t=0.18] ENTER state=Idle\n[SIM][t=0.18] ENTER state=Idle\n[SIM][t=0.18] ENTER state=Idle\n[SIM][t=0.19] ENTER state=Idle\n[SIM][t=0.19] ENTER state=Idle\n[SIM][t=0.19] ENTER state=Idle\n[SIM][t=0.19] ENTER state=Idle\n[SIM][t=0.19] ENTER state=Idle\n[SIM][t=0.20] ENTER state=Idle\n[SIM][t=0.20] ENTER state=Idle\n[SIM][t=0.20] ENTER state=Idle\n[SIM][t=0.20] ENTER state=Idle\n[SIM][t=0.20] ENTER state=Idle\n[SIM][t=0.21] ENTER state=Idle\n[SIM][t=0.21] ENTER state=Idle\n[SIM][t=0.21] ENTER state=Idle\n[SIM][t=0.21] ENTER state=Idle\n[SIM][t=0.21] ENTER state=Idle\n[SIM][t=0.22] ENTER state=Idle\n[SIM][t=0.22] ENTER state=Idle\n[SIM][t=0.22] ENTER state=Idle\n[SIM][t=0.22] ENTER state=Idle\n[SIM][t=0.22] ENTER state=Idle\n[SIM][t=0.23] ENTER state=Idle\n[SIM][t=0.23] ENTER state=Idle\n[SIM][t=0.23] ENTER state=Idle\n[SIM][t=0.23] ENTER state=Idle\n[SIM][t=0.23] ENTER state=Idle\n[SIM][t=0.24] ENTER state=Idle\n[SIM][t=0.24] ENTER state=Idle\n[SIM][t=0.24] ENTER state=Idle\n[SIM][t=0.24] ENTER state=Idle\n[SIM][t=0.24] ENTER state=Idle\n[SIM][t=0.25] ENTER state=Idle\n[SIM][t=0.25] ENTER state=Idle\n[SIM][t=0.25] ENTER state=Idle\n[SIM][t=0.25] ENTER state=Idle\n[SIM][t=0.25] ENTER state=Idle\n[SIM][t=0.26] ENTER state=Idle\n[SIM][t=0.26] ENTER state=Idle\n[SIM][t=0.26] ENTER state=Idle\n[SIM][t=0.26] ENTER state=Idle\n[SIM][t=0.26] ENTER state=Idle\n[SIM][t=0.27] ENTER state=Idle\n[SIM][t=0.27] ENTER state=Idle\n[SIM][t=0.27] ENTER state=Idle\n[SIM][t=0.27] ENTER state=Idle\n[SIM][t=0.27] ENTER state=Idle\n[SIM][t=0.28] ENTER state=Idle\n[SIM][t=0.28] ENTER state=Idle\n[SIM][t=0.28] ENTER state=Idle\n[SIM][t=0.28] ENTER state=Idle\n[SIM][t=0.28] ENTER state=Idle\n[SIM][t=0.29] ENTER state=Idle\n[SIM][t=0.29] ENTER state=Idle\n[SIM][t=0.29] ENTER state=Idle\n[SIM][t=0.29] ENTER state=Idle\n[SIM][t=0.29] ENTER state=Idle\n[SIM][t=0.30] ENTER state=Idle\n[SIM][t=0.30] ENTER state=Idle\n[SIM][t=0.30] ENTER state=Idle\n[SIM][t=0.30] ENTER state=Idle\n[SIM][t=0.30] ENTER state=Idle\n[SIM][t=0.31] ENTER state=Idle\n[SIM][t=0.31] ENTER state=Idle\n[SIM][t=0.31] ENTER state=Idle\n[SIM][t=0.31] ENTER state=Idle\n[SIM][t=0.31] ENTER state=Idle\n[SIM][t=0.32] ENTER state=Idle\n[SIM][t=0.32] ENTER state=Idle\n[SIM][t=0.32] ENTER state=Idle\n[SIM][t=0.32] ENTER state=Idle\n[SIM][t=0.32] ENTER state=Idle\n[SIM][t=0.33] ENTER state=Idle\n[SIM][t=0.33] ENTER state=Idle\n[SIM][t=0.33] ENTER state=Idle\n[SIM][t=0.33] ENTER state=Idle\n[SIM][t=0.33] ENTER state=Idle\n[SIM][t=0.34] ENTER state=Idle\n[SIM][t=0.34] ENTER state=Idle\n[SIM][t=0.34] ENTER state=Idle\n[SIM][t=0.34] ENTER state=Idle\n[SIM][t=0.34] ENTER state=Idle\n[SIM][t=0.35] ENTER state=Idle\n[SIM][t=0.35] ENTER state=Idle\n[SIM][t=0.35] ENTER state=Idle\n[SIM][t=0.35] ENTER state=Idle\n[SIM][t=0.35] ENTER state=Idle\n[SIM][t=0.36] ENTER state=Idle\n[SIM][t=0.36] ENTER state=Idle\n[SIM][t=0.36] ENTER state=Idle\n[SIM][t=0.36] ENTER state=Idle\n[SIM][t=0.36] ENTER state=Idle\n[SIM][t=0.37] ENTER state=Idle\n[SIM][t=0.37] ENTER state=Idle\n[SIM][t=0.37] ENTER state=Idle\n[SIM][t=0.37] ENTER state=Idle\n[SIM][t=0.37] ENTER state=Idle\n[SIM][t=0.38] ENTER state=Idle\n[SIM][t=0.38] ENTER state=Idle\n[SIM][t=0.38] ENTER state=Idle\n[SIM][t=0.38] ENTER state=Idle\n[SIM][t=0.38] ENTER state=Idle\n[SIM][t=0.39] ENTER state=Idle\n[SIM][t=0.39] ENTER state=Idle\n[SIM][t=0.39] ENTER state=Idle\n[SIM][t=0.39] ENTER state=Idle\n[SIM][t=0.39] ENTER state=Idle\n[SIM][t=0.40] ENTER state=Idle\n[SIM][t=0.40] ENTER state=Idle\n[SIM][t=0.40] ENTER state=Idle\n[SIM][t=0.40] ENTER state=Idle\n[SIM][t=0.40] ENTER state=Idle\n[SIM][t=0.41] ENTER state=Idle\n[SIM][t=0.41] ENTER state=Idle\n[SIM][t=0.41] ENTER state=Idle\n[SIM][t=0.41] ENTER state=Idle\n[SIM][t=0.41] ENTER state=Idle\n[SIM][t=0.42] ENTER state=Idle\n[SIM][t=0.42] ENTER state=Idle\n[SIM][t=0.42] ENTER state=Idle\n[SIM][t=0.42] ENTER state=Idle\n[SIM][t=0.42] ENTER state=Idle\n[SIM][t=0.43] ENTER state=Idle\n[SIM][t=0.43] ENTER state=Idle\n[SIM][t=0.43] ENTER state=Idle\n[SIM][t=0.43] ENTER state=Idle\n[SIM][t=0.43] ENTER state=Idle\n[SIM][t=0.44] ENTER state=Idle\n[SIM][t=0.44] ENTER state=Idle\n[SIM][t=0.44] ENTER state=Idle\n[SIM][t=0.44] ENTER state=Idle\n[SIM][t=0.44] ENTER state=Idle\n[SIM][t=0.45] ENTER state=Idle\n[SIM][t=0.45] ENTER state=Idle\n[SIM][t=0.45] ENTER state=Idle\n[SIM][t=0.45] ENTER state=Idle\n[SIM][t=0.45] ENTER state=Idle\n[SIM][t=0.46] ENTER state=Idle\n[SIM][t=0.46] ENTER state=Idle\n[SIM][t=0.46] ENTER state=Idle\n[SIM][t=0.46] ENTER state=Idle\n[SIM][t=0.46] ENTER state=Idle\n[SIM][t=0.47] ENTER state=Idle\n[SIM][t=0.47] ENTER state=Idle\n[SIM][t=0.47] ENTER state=Idle\n[SIM][t=0.47] ENTER state=Idle\n[SIM][t=0.47] ENTER state=Idle\n[SIM][t=0.48] ENTER state=Idle\n[SIM][t=0.48] ENTER state=Idle\n[SIM][t=0.48] ENTER state=Idle\n[SIM][t=0.48] ENTER state=Idle\n[SIM][t=0.48] ENTER state=Idle\n[SIM][t=0.49] ENTER state=Idle\n[SIM][t=0.49] ENTER state=Idle\n[SIM][t=0.49] ENTER state=Idle\n[SIM][t=0.49] ENTER state=Idle\n[SIM][t=0.49] ENTER state=Idle\n[SIM][t=0.50] ENTER state=Idle\n[SIM][t=0.50] ENTER state=Idle\n[SIM][t=0.50] ENTER state=Idle\n[SIM][t=0.50] ENTER state=Idle\n[SIM][t=0.50] ENTER state=Idle\n[SIM][t=0.51] ENTER state=Idle\n[SIM][t=0.51] ENTER state=Idle\n[SIM][t=0.51] ENTER state=Idle\n[SIM][t=0.51] ENTER state=Idle\n[SIM][t=0.51] ENTER state=Idle\n[SIM][t=0.52] ENTER state=Idle\n[SIM][t=0.52] ENTER state=Idle\n[SIM][t=0.52] ENTER state=Idle\n[SIM][t=0.52] ENTER state=Idle\n[SIM][t=0.52] ENTER state=Idle\n[SIM][t=0.53] ENTER state=Idle\n[SIM][t=0.53] ENTER state=Idle\n[SIM][t=0.53] ENTER state=Idle\n[SIM][t=0.53] ENTER state=Idle\n[SIM][t=0.53] ENTER state=Idle\n[SIM][t=0.54] ENTER state=Idle\n[SIM][t=0.54] ENTER state=Idle\n[SIM][t=0.54] ENTER state=Idle\n[SIM][t=0.54] ENTER state=Idle\n[SIM][t=0.54] ENTER state=Idle\n[SIM][t=0.55] ENTER state=Idle\n[SIM][t=0.55] ENTER state=Idle\n[SIM][t=0.55] ENTER state=Idle\n[SIM][t=0.55] ENTER state=Idle\n[SIM][t=0.55] ENTER state=Idle\n[SIM][t=0.56] ENTER state=Idle\n[SIM][t=0.56] ENTER state=Idle\n[SIM][t=0.56] ENTER state=Idle\n[SIM][t=0.56] ENTER state=Idle\n[SIM][t=0.56] ENTER state=Idle\n[SIM][t=0.57] ENTER state=Idle\n[SIM][t=0.57] ENTER state=Idle\n[SIM][t=0.57] ENTER state=Idle\n[SIM][t=0.57] ENTER state=Idle\n[SIM][t=0.57] ENTER state=Idle\n[SIM][t=0.58] ENTER state=Idle\n[SIM][t=0.58] ENTER state=Idle\n[SIM][t=0.58] ENTER state=Idle\n[SIM][t=0.58] ENTER state=Idle\n[SIM][t=0.58] ENTER state=Idle\n[SIM][t=0.59] ENTER state=Idle\n[SIM][t=0.59] ENTER state=Idle\n[SIM][t=0.59] ENTER state=Idle\n[SIM][t=0.59] ENTER state=Idle\n[SIM][t=0.59] ENTER state=Idle\n[SIM][t=0.60] ENTER state=Idle\n[SIM][t=0.60] ENTER state=Idle\n[SIM][t=0.60] ENTER state=Idle\n[SIM][t=0.60] ENTER state=Idle\n[SIM][t=0.60] ENTER state=Idle\n[SIM][t=0.61] ENTER state=Idle\n[SIM][t=0.61] ENTER state=Idle\n[SIM][t=0.61] ENTER state=Idle\n[SIM][t=0.61] ENTER state=Idle\n[SIM][t=0.61] ENTER state=Idle\n[SIM][t=0.62] ENTER state=Idle\n[SIM][t=0.62] ENTER state=Idle\n[SIM][t=0.62] ENTER state=Idle\n[SIM][t=0.62] ENTER state=Idle\n[SIM][t=0.62] ENTER state=Idle\n[SIM][t=0.63] ENTER state=Idle\n[SIM][t=0.63] ENTER state=Idle\n[SIM][t=0.63] ENTER state=Idle\n[SIM][t=0.63] ENTER state=Idle\n[SIM][t=0.63] ENTER state=Idle\n[SIM][t=0.64] ENTER state=Idle\n[SIM][t=0.64] ENTER state=Idle\n[SIM][t=0.64] ENTER state=Idle\n[SIM][t=0.64] ENTER state=Idle\n[SIM][t=0.64] ENTER state=Idle\n[SIM][t=0.65] ENTER state=Idle\n[SIM][t=0.65] ENTER state=Idle\n[SIM][t=0.65] ENTER state=Idle\n[SIM][t=0.65] ENTER state=Idle\n[SIM][t=0.65] ENTER state=Idle\n[SIM][t=0.66] ENTER state=Idle\n[SIM][t=0.66] ENTER state=Idle\n[SIM][t=0.66] ENTER state=Idle\n[SIM][t=0.66] ENTER state=Idle\n[SIM][t=0.66] ENTER state=Idle\n[SIM][t=0.67] ENTER state=Idle\n[SIM][t=0.67] ENTER state=Idle\n[SIM][t=0.67] ENTER state=Idle\n[SIM][t=0.67] ENTER state=Idle\n[SIM][t=0.67] ENTER state=Idle\n[SIM][t=0.68] ENTER state=Idle\n[SIM][t=0.68] ENTER state=Idle\n[SIM][t=0.68] ENTER state=Idle\n[SIM][t=0.68] ENTER state=Idle\n[SIM][t=0.68] ENTER state=Idle\n[SIM][t=0.69] ENTER state=Idle\n[SIM][t=0.69] ENTER state=Idle\n[SIM][t=0.69] ENTER state=Idle\n[SIM][t=0.69] ENTER state=Idle\n[SIM][t=0.69] ENTER state=Idle\n[SIM][t=0.70] ENTER state=Idle\n[SIM][t=0.70] ENTER state=Idle\n[SIM][t=0.70] ENTER state=Idle\n[SIM][t=0.70] ENTER state=Idle\n[SIM][t=0.70] ENTER state=Idle\n[SIM][t=0.71] ENTER state=Idle\n[SIM][t=0.71] ENTER state=Idle\n[SIM][t=0.71] ENTER state=Idle\n[SIM][t=0.71] ENTER state=Idle\n[SIM][t=0.71] ENTER state=Idle\n[SIM][t=0.72] ENTER state=Idle\n[SIM][t=0.72] ENTER state=Idle\n[SIM][t=0.72] ENTER state=Idle\n[SIM][t=0.72] ENTER state=Idle\n[SIM][t=0.72] ENTER state=Idle\n[SIM][t=0.73] ENTER state=Idle\n[SIM][t=0.73] ENTER state=Idle\n[SIM][t=0.73] ENTER state=Idle\n[SIM][t=0.73] ENTER state=Idle\n[SIM][t=0.73] ENTER state=Idle\n[SIM][t=0.74] ENTER state=Idle\n[SIM][t=0.74] ENTER state=Idle\n[SIM][t=0.74] ENTER state=Idle\n[SIM][t=0.74] ENTER state=Idle\n[SIM][t=0.74] ENTER state=Idle\n[SIM][t=0.75] ENTER state=Idle\n[SIM][t=0.75] ENTER state=Idle\n[SIM][t=0.75] ENTER state=Idle\n[SIM][t=0.75] ENTER state=Idle\n[SIM][t=0.75] ENTER state=Idle\n[SIM][t=0.76] ENTER state=Idle\n[SIM][t=0.76] ENTER state=Idle\n[SIM][t=0.76] ENTER state=Idle\n[SIM][t=0.76] ENTER state=Idle\n[SIM][t=0.76] ENTER state=Idle\n[SIM][t=0.77] ENTER state=Idle\n[SIM][t=0.77] ENTER state=Idle\n[SIM][t=0.77] ENTER state=Idle\n[SIM][t=0.77] ENTER state=Idle\n[SIM][t=0.77] ENTER state=Idle\n[SIM][t=0.78] ENTER state=Idle\n[SIM][t=0.78] ENTER state=Idle\n[SIM][t=0.78] ENTER state=Idle\n[SIM][t=0.78] ENTER state=Idle\n[SIM][t=0.78] ENTER state=Idle\n[SIM][t=0.79] ENTER state=Idle\n[SIM][t=0.79] ENTER state=Idle\n[SIM][t=0.79] ENTER state=Idle\n[SIM][t=0.79] ENTER state=Idle\n[SIM][t=0.79] ENTER state=Idle\n[SIM][t=0.80] ENTER state=Idle\n[SIM][t=0.80] ENTER state=Idle\n[SIM][t=0.80] ENTER state=Idle\n[SIM][t=0.80] ENTER state=Idle\n[SIM][t=0.80] ENTER state=Idle\n[SIM][t=0.81] ENTER state=Idle\n[SIM][t=0.81] ENTER state=Idle\n[SIM][t=0.81] ENTER state=Idle\n[SIM][t=0.81] ENTER state=Idle\n[SIM][t=0.81] ENTER state=Idle\n[SIM][t=0.82] ENTER state=Idle\n[SIM][t=0.82] ENTER state=Idle\n[SIM][t=0.82] ENTER state=Idle\n[SIM][t=0.82] ENTER state=Idle\n[SIM][t=0.82] ENTER state=Idle\n[SIM][t=0.83] ENTER state=Idle\n[SIM][t=0.83] ENTER state=Idle\n[SIM][t=0.83] ENTER state=Idle\n[SIM][t=0.83] ENTER state=Idle\n[SIM][t=0.83] ENTER state=Idle\n[SIM][t=0.84] ENTER state=Idle\n[SIM][t=0.84] ENTER state=Idle\n[SIM][t=0.84] ENTER state=Idle\n[SIM][t=0.84] ENTER state=Idle\n[SIM][t=0.84] ENTER state=Idle\n[SIM][t=0.85] ENTER state=Idle\n[SIM][t=0.85] ENTER state=Idle\n[SIM][t=0.85] ENTER state=Idle\n[SIM][t=0.85] ENTER state=Idle\n[SIM][t=0.85] ENTER state=Idle\n[SIM][t=0.86] ENTER state=Idle\n[SIM][t=0.86] ENTER state=Idle\n[SIM][t=0.86] ENTER state=Idle\n[SIM][t=0.86] ENTER state=Idle\n[SIM][t=0.86] ENTER state=Idle\n[SIM][t=0.87] ENTER state=Idle\n[SIM][t=0.87] ENTER state=Idle\n[SIM][t=0.87] ENTER state=Idle\n[SIM][t=0.87] ENTER state=Idle\n[SIM][t=0.87] ENTER state=Idle\n[SIM][t=0.88] ENTER state=Idle\n[SIM][t=0.88] ENTER state=Idle\n[SIM][t=0.88] ENTER state=Idle\n[SIM][t=0.88] ENTER state=Idle\n[SIM][t=0.88] ENTER state=Idle\n[SIM][t=0.89] ENTER state=Idle\n[SIM][t=0.89] ENTER state=Idle\n[SIM][t=0.89] ENTER state=Idle\n[SIM][t=0.89] ENTER state=Idle\n[SIM][t=0.89] ENTER state=Idle\n[SIM][t=0.90] ENTER state=Idle\n[SIM][t=0.90] ENTER state=Idle\n[SIM][t=0.90] ENTER state=Idle\n[SIM][t=0.90] ENTER state=Idle\n[SIM][t=0.90] ENTER state=Idle\n[SIM][t=0.91] ENTER state=Idle\n[SIM][t=0.91] ENTER state=Idle\n[SIM][t=0.91] ENTER state=Idle\n[SIM][t=0.91] ENTER state=Idle\n[SIM][t=0.91] ENTER state=Idle\n[SIM][t=0.92] ENTER state=Idle\n[SIM][t=0.92] ENTER state=Idle\n[SIM][t=0.92] ENTER state=Idle\n[SIM][t=0.92] ENTER state=Idle\n[SIM][t=0.92] ENTER state=Idle\n[SIM][t=0.93] ENTER state=Idle\n[SIM][t=0.93] ENTER state=Idle\n[SIM][t=0.93] ENTER state=Idle\n[SIM][t=0.93] ENTER state=Idle\n[SIM][t=0.93] ENTER state=Idle\n[SIM][t=0.94] ENTER state=Idle\n[SIM][t=0.94] ENTER state=Idle\n[SIM][t=0.94] ENTER state=Idle\n[SIM][t=0.94] ENTER state=Idle\n[SIM][t=0.94] ENTER state=Idle\n[SIM][t=0.95] ENTER state=Idle\n[SIM][t=0.95] ENTER state=Idle\n[SIM][t=0.95] ENTER state=Idle\n[SIM][t=0.95] ENTER state=Idle\n[SIM][t=0.95] ENTER state=Idle\n[SIM][t=0.96] ENTER state=Idle\n[SIM][t=0.96] ENTER state=Idle\n[SIM][t=0.96] ENTER state=Idle\n[SIM][t=0.96] ENTER state=Idle\n[SIM][t=0.96] ENTER state=Idle\n[SIM][t=0.97] ENTER state=Idle\n[SIM][t=0.97] ENTER state=Idle\n[SIM][t=0.97] ENTER state=Idle\n[SIM][t=0.97] ENTER state=Idle\n[SIM][t=0.97] ENTER state=Idle\n[SIM][t=0.98] ENTER state=Idle\n[SIM][t=0.98] ENTER state=Idle\n[SIM][t=0.98] ENTER state=Idle\n[SIM][t=0.98] ENTER state=Idle\n[SIM][t=0.98] ENTER state=Idle\n[SIM][t=0.99] ENTER state=Idle\n[SIM][t=0.99] ENTER state=Idle\n[SIM][t=0.99] ENTER state=Idle\n[SIM][t=0.99] ENTER state=Idle\n[SIM][t=0.99] ENTER state=Idle\n[SIM][t=1.00] ENTER state=Idle\n[SIM][t=1.00] ENTER state=Idle\n[INPUT] Setting request_floor to 3 at t=1.00\n[SIM][t=1.00] ENTER state=Idle\n[SIM][t=1.00] TRANSITION Idle -> MovingUp (reason=request_floor > current_floor)\n[SIM][t=1.00] ENTER state=MovingUp\n\n\nERRORS:\nTraceback (most recent call last):\n  File "C:\\Users\\24760\\AppData\\Roaming\\Python\\Python313\\site-packages\\simpy\\events.py", line 431, in _resume\n    if event.callbacks is not None:\n       ^^^^^^^^^^^^^^^\nAttributeError: \'generator\' object has no attribute \'callbacks\'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File "E:\\VeriSpec\\verispec-lite\\servers\\simulation_server.py", line 41, in execute_simulation_code\n    exec(code_str, exec_globals)\n    ~~~~^^^^^^^^^^^^^^^^^^^^^^^^\n  File "<string>", line 175, in <module>\n  File "<string>", line 170, in run_simulation\n  File "C:\\Users\\24760\\AppData\\Roaming\\Python\\Python313\\site-packages\\simpy\\core.py", line 246, in run\n    self.step()\n    ~~~~~~~~~^^\n  File "C:\\Users\\24760\\AppData\\Roaming\\Python\\Python313\\site-packages\\simpy\\core.py", line 196, in step\n    callback(event)\n    ~~~~~~~~^^^^^^^\n  File "C:\\Users\\24760\\AppData\\Roaming\\Python\\Python313\\site-packages\\simpy\\events.py", line 443, in _resume\n    descr = _describe_frame(self._generator.gi_frame)\n  File "C:\\Users\\24760\\AppData\\Roaming\\Python\\Python313\\site-packages\\simpy\\events.py", line 645, in _describe_frame\n    with open(filename) as f:\n         ~~~~^^^^^^^^^^\nOSError: [Errno 22] Invalid argument: \'<string>\'\n'}], 'structuredContent': {'result': 'LOGS:\n[SIM] Starting simulation\n[SIM][t=0.00] ENTER state=Idle\n[SIM][t=0.00] ENTER state=Idle\n[SIM][t=0.00] ENTER state=Idle\n[SIM][t=0.01] ENTER state=Idle\n[SIM][t=0.01] ENTER state=Idle\n[SIM][t=0.01] ENTER state=Idle\n[SIM][t=0.01] ENTER state=Idle\n[SIM][t=0.01] ENTER state=Idle\n[SIM][t=0.02] ENTER state=Idle\n[SIM][t=0.02] ENTER state=Idle\n[SIM][t=0.02] ENTER state=Idle\n[SIM][t=0.02] ENTER state=Idle\n[SIM][t=0.02] ENTER state=Idle\n[SIM][t=0.03] ENTER state=Idle\n[SIM][t=0.03] ENTER state=Idle\n[SIM][t=0.03] ENTER state=Idle\n[SIM][t=0.03] ENTER state=Idle\n[SIM][t=0.03] ENTER state=Idle\n[SIM][t=0.04] ENTER state=Idle\n[SIM][t=0.04] ENTER state=Idle\n[SIM][t=0.04] ENTER state=Idle\n[SIM][t=0.04] ENTER state=Idle\n[SIM][t=0.04] ENTER state=Idle\n[SIM][t=0.05] ENTER state=Idle\n[SIM][t=0.05] ENTER state=Idle\n[SIM][t=0.05] ENTER state=Idle\n[SIM][t=0.05] ENTER state=Idle\n[SIM][t=0.05] ENTER state=Idle\n[SIM][t=0.06] ENTER state=Idle\n[SIM][t=0.06] ENTER state=Idle\n[SIM][t=0.06] ENTER state=Idle\n[SIM][t=0.06] ENTER state=Idle\n[SIM][t=0.06] ENTER state=Idle\n[SIM][t=0.07] ENTER state=Idle\n[SIM][t=0.07] ENTER state=Idle\n[SIM][t=0.07] ENTER state=Idle\n[SIM][t=0.07] ENTER state=Idle\n[SIM][t=0.07] ENTER state=Idle\n[SIM][t=0.08] ENTER state=Idle\n[SIM][t=0.08] ENTER state=Idle\n[SIM][t=0.08] ENTER state=Idle\n[SIM][t=0.08] ENTER state=Idle\n[SIM][t=0.08] ENTER state=Idle\n[SIM][t=0.09] ENTER state=Idle\n[SIM][t=0.09] ENTER state=Idle\n[SIM][t=0.09] ENTER state=Idle\n[SIM][t=0.09] ENTER state=Idle\n[SIM][t=0.09] ENTER state=Idle\n[SIM][t=0.10] ENTER state=Idle\n[SIM][t=0.10] ENTER state=Idle\n[SIM][t=0.10] ENTER state=Idle\n[SIM][t=0.10] ENTER state=Idle\n[SIM][t=0.10] ENTER state=Idle\n[SIM][t=0.11] ENTER state=Idle\n[SIM][t=0.11] ENTER state=Idle\n[SIM][t=0.11] ENTER state=Idle\n[SIM][t=0.11] ENTER state=Idle\n[SIM][t=0.11] ENTER state=Idle\n[SIM][t=0.12] ENTER state=Idle\n[SIM][t=0.12] ENTER state=Idle\n[SIM][t=0.12] ENTER state=Idle\n[SIM][t=0.12] ENTER state=Idle\n[SIM][t=0.12] ENTER state=Idle\n[SIM][t=0.13] ENTER state=Idle\n[SIM][t=0.13] ENTER state=Idle\n[SIM][t=0.13] ENTER state=Idle\n[SIM][t=0.13] ENTER state=Idle\n[SIM][t=0.13] ENTER state=Idle\n[SIM][t=0.14] ENTER state=Idle\n[SIM][t=0.14] ENTER state=Idle\n[SIM][t=0.14] ENTER state=Idle\n[SIM][t=0.14] ENTER state=Idle\n[SIM][t=0.14] ENTER state=Idle\n[SIM][t=0.15] ENTER state=Idle\n[SIM][t=0.15] ENTER state=Idle\n[SIM][t=0.15] ENTER state=Idle\n[SIM][t=0.15] ENTER state=Idle\n[SIM][t=0.15] ENTER state=Idle\n[SIM][t=0.16] ENTER state=Idle\n[SIM][t=0.16] ENTER state=Idle\n[SIM][t=0.16] ENTER state=Idle\n[SIM][t=0.16] ENTER state=Idle\n[SIM][t=0.16] ENTER state=Idle\n[SIM][t=0.17] ENTER state=Idle\n[SIM][t=0.17] ENTER state=Idle\n[SIM][t=0.17] ENTER state=Idle\n[SIM][t=0.17] ENTER state=Idle\n[SIM][t=0.17] ENTER state=Idle\n[SIM][t=0.18] ENTER state=Idle\n[SIM][t=0.18] ENTER state=Idle\n[SIM][t=0.18] ENTER state=Idle\n[SIM][t=0.18] ENTER state=Idle\n[SIM][t=0.18] ENTER state=Idle\n[SIM][t=0.19] ENTER state=Idle\n[SIM][t=0.19] ENTER state=Idle\n[SIM][t=0.19] ENTER state=Idle\n[SIM][t=0.19] ENTER state=Idle\n[SIM][t=0.19] ENTER state=Idle\n[SIM][t=0.20] ENTER state=Idle\n[SIM][t=0.20] ENTER state=Idle\n[SIM][t=0.20] ENTER state=Idle\n[SIM][t=0.20] ENTER state=Idle\n[SIM][t=0.20] ENTER state=Idle\n[SIM][t=0.21] ENTER state=Idle\n[SIM][t=0.21] ENTER state=Idle\n[SIM][t=0.21] ENTER state=Idle\n[SIM][t=0.21] ENTER state=Idle\n[SIM][t=0.21] ENTER state=Idle\n[SIM][t=0.22] ENTER state=Idle\n[SIM][t=0.22] ENTER state=Idle\n[SIM][t=0.22] ENTER state=Idle\n[SIM][t=0.22] ENTER state=Idle\n[SIM][t=0.22] ENTER state=Idle\n[SIM][t=0.23] ENTER state=Idle\n[SIM][t=0.23] ENTER state=Idle\n[SIM][t=0.23] ENTER state=Idle\n[SIM][t=0.23] ENTER state=Idle\n[SIM][t=0.23] ENTER state=Idle\n[SIM][t=0.24] ENTER state=Idle\n[SIM][t=0.24] ENTER state=Idle\n[SIM][t=0.24] ENTER state=Idle\n[SIM][t=0.24] ENTER state=Idle\n[SIM][t=0.24] ENTER state=Idle\n[SIM][t=0.25] ENTER state=Idle\n[SIM][t=0.25] ENTER state=Idle\n[SIM][t=0.25] ENTER state=Idle\n[SIM][t=0.25] ENTER state=Idle\n[SIM][t=0.25] ENTER state=Idle\n[SIM][t=0.26] ENTER state=Idle\n[SIM][t=0.26] ENTER state=Idle\n[SIM][t=0.26] ENTER state=Idle\n[SIM][t=0.26] ENTER state=Idle\n[SIM][t=0.26] ENTER state=Idle\n[SIM][t=0.27] ENTER state=Idle\n[SIM][t=0.27] ENTER state=Idle\n[SIM][t=0.27] ENTER state=Idle\n[SIM][t=0.27] ENTER state=Idle\n[SIM][t=0.27] ENTER state=Idle\n[SIM][t=0.28] ENTER state=Idle\n[SIM][t=0.28] ENTER state=Idle\n[SIM][t=0.28] ENTER state=Idle\n[SIM][t=0.28] ENTER state=Idle\n[SIM][t=0.28] ENTER state=Idle\n[SIM][t=0.29] ENTER state=Idle\n[SIM][t=0.29] ENTER state=Idle\n[SIM][t=0.29] ENTER state=Idle\n[SIM][t=0.29] ENTER state=Idle\n[SIM][t=0.29] ENTER state=Idle\n[SIM][t=0.30] ENTER state=Idle\n[SIM][t=0.30] ENTER state=Idle\n[SIM][t=0.30] ENTER state=Idle\n[SIM][t=0.30] ENTER state=Idle\n[SIM][t=0.30] ENTER state=Idle\n[SIM][t=0.31] ENTER state=Idle\n[SIM][t=0.31] ENTER state=Idle\n[SIM][t=0.31] ENTER state=Idle\n[SIM][t=0.31] ENTER state=Idle\n[SIM][t=0.31] ENTER state=Idle\n[SIM][t=0.32] ENTER state=Idle\n[SIM][t=0.32] ENTER state=Idle\n[SIM][t=0.32] ENTER state=Idle\n[SIM][t=0.32] ENTER state=Idle\n[SIM][t=0.32] ENTER state=Idle\n[SIM][t=0.33] ENTER state=Idle\n[SIM][t=0.33] ENTER state=Idle\n[SIM][t=0.33] ENTER state=Idle\n[SIM][t=0.33] ENTER state=Idle\n[SIM][t=0.33] ENTER state=Idle\n[SIM][t=0.34] ENTER state=Idle\n[SIM][t=0.34] ENTER state=Idle\n[SIM][t=0.34] ENTER state=Idle\n[SIM][t=0.34] ENTER state=Idle\n[SIM][t=0.34] ENTER state=Idle\n[SIM][t=0.35] ENTER state=Idle\n[SIM][t=0.35] ENTER state=Idle\n[SIM][t=0.35] ENTER state=Idle\n[SIM][t=0.35] ENTER state=Idle\n[SIM][t=0.35] ENTER state=Idle\n[SIM][t=0.36] ENTER state=Idle\n[SIM][t=0.36] ENTER state=Idle\n[SIM][t=0.36] ENTER state=Idle\n[SIM][t=0.36] ENTER state=Idle\n[SIM][t=0.36] ENTER state=Idle\n[SIM][t=0.37] ENTER state=Idle\n[SIM][t=0.37] ENTER state=Idle\n[SIM][t=0.37] ENTER state=Idle\n[SIM][t=0.37] ENTER state=Idle\n[SIM][t=0.37] ENTER state=Idle\n[SIM][t=0.38] ENTER state=Idle\n[SIM][t=0.38] ENTER state=Idle\n[SIM][t=0.38] ENTER state=Idle\n[SIM][t=0.38] ENTER state=Idle\n[SIM][t=0.38] ENTER state=Idle\n[SIM][t=0.39] ENTER state=Idle\n[SIM][t=0.39] ENTER state=Idle\n[SIM][t=0.39] ENTER state=Idle\n[SIM][t=0.39] ENTER state=Idle\n[SIM][t=0.39] ENTER state=Idle\n[SIM][t=0.40] ENTER state=Idle\n[SIM][t=0.40] ENTER state=Idle\n[SIM][t=0.40] ENTER state=Idle\n[SIM][t=0.40] ENTER state=Idle\n[SIM][t=0.40] ENTER state=Idle\n[SIM][t=0.41] ENTER state=Idle\n[SIM][t=0.41] ENTER state=Idle\n[SIM][t=0.41] ENTER state=Idle\n[SIM][t=0.41] ENTER state=Idle\n[SIM][t=0.41] ENTER state=Idle\n[SIM][t=0.42] ENTER state=Idle\n[SIM][t=0.42] ENTER state=Idle\n[SIM][t=0.42] ENTER state=Idle\n[SIM][t=0.42] ENTER state=Idle\n[SIM][t=0.42] ENTER state=Idle\n[SIM][t=0.43] ENTER state=Idle\n[SIM][t=0.43] ENTER state=Idle\n[SIM][t=0.43] ENTER state=Idle\n[SIM][t=0.43] ENTER state=Idle\n[SIM][t=0.43] ENTER state=Idle\n[SIM][t=0.44] ENTER state=Idle\n[SIM][t=0.44] ENTER state=Idle\n[SIM][t=0.44] ENTER state=Idle\n[SIM][t=0.44] ENTER state=Idle\n[SIM][t=0.44] ENTER state=Idle\n[SIM][t=0.45] ENTER state=Idle\n[SIM][t=0.45] ENTER state=Idle\n[SIM][t=0.45] ENTER state=Idle\n[SIM][t=0.45] ENTER state=Idle\n[SIM][t=0.45] ENTER state=Idle\n[SIM][t=0.46] ENTER state=Idle\n[SIM][t=0.46] ENTER state=Idle\n[SIM][t=0.46] ENTER state=Idle\n[SIM][t=0.46] ENTER state=Idle\n[SIM][t=0.46] ENTER state=Idle\n[SIM][t=0.47] ENTER state=Idle\n[SIM][t=0.47] ENTER state=Idle\n[SIM][t=0.47] ENTER state=Idle\n[SIM][t=0.47] ENTER state=Idle\n[SIM][t=0.47] ENTER state=Idle\n[SIM][t=0.48] ENTER state=Idle\n[SIM][t=0.48] ENTER state=Idle\n[SIM][t=0.48] ENTER state=Idle\n[SIM][t=0.48] ENTER state=Idle\n[SIM][t=0.48] ENTER state=Idle\n[SIM][t=0.49] ENTER state=Idle\n[SIM][t=0.49] ENTER state=Idle\n[SIM][t=0.49] ENTER state=Idle\n[SIM][t=0.49] ENTER state=Idle\n[SIM][t=0.49] ENTER state=Idle\n[SIM][t=0.50] ENTER state=Idle\n[SIM][t=0.50] ENTER state=Idle\n[SIM][t=0.50] ENTER state=Idle\n[SIM][t=0.50] ENTER state=Idle\n[SIM][t=0.50] ENTER state=Idle\n[SIM][t=0.51] ENTER state=Idle\n[SIM][t=0.51] ENTER state=Idle\n[SIM][t=0.51] ENTER state=Idle\n[SIM][t=0.51] ENTER state=Idle\n[SIM][t=0.51] ENTER state=Idle\n[SIM][t=0.52] ENTER state=Idle\n[SIM][t=0.52] ENTER state=Idle\n[SIM][t=0.52] ENTER state=Idle\n[SIM][t=0.52] ENTER state=Idle\n[SIM][t=0.52] ENTER state=Idle\n[SIM][t=0.53] ENTER state=Idle\n[SIM][t=0.53] ENTER state=Idle\n[SIM][t=0.53] ENTER state=Idle\n[SIM][t=0.53] ENTER state=Idle\n[SIM][t=0.53] ENTER state=Idle\n[SIM][t=0.54] ENTER state=Idle\n[SIM][t=0.54] ENTER state=Idle\n[SIM][t=0.54] ENTER state=Idle\n[SIM][t=0.54] ENTER state=Idle\n[SIM][t=0.54] ENTER state=Idle\n[SIM][t=0.55] ENTER state=Idle\n[SIM][t=0.55] ENTER state=Idle\n[SIM][t=0.55] ENTER state=Idle\n[SIM][t=0.55] ENTER state=Idle\n[SIM][t=0.55] ENTER state=Idle\n[SIM][t=0.56] ENTER state=Idle\n[SIM][t=0.56] ENTER state=Idle\n[SIM][t=0.56] ENTER state=Idle\n[SIM][t=0.56] ENTER state=Idle\n[SIM][t=0.56] ENTER state=Idle\n[SIM][t=0.57] ENTER state=Idle\n[SIM][t=0.57] ENTER state=Idle\n[SIM][t=0.57] ENTER state=Idle\n[SIM][t=0.57] ENTER state=Idle\n[SIM][t=0.57] ENTER state=Idle\n[SIM][t=0.58] ENTER state=Idle\n[SIM][t=0.58] ENTER state=Idle\n[SIM][t=0.58] ENTER state=Idle\n[SIM][t=0.58] ENTER state=Idle\n[SIM][t=0.58] ENTER state=Idle\n[SIM][t=0.59] ENTER state=Idle\n[SIM][t=0.59] ENTER state=Idle\n[SIM][t=0.59] ENTER state=Idle\n[SIM][t=0.59] ENTER state=Idle\n[SIM][t=0.59] ENTER state=Idle\n[SIM][t=0.60] ENTER state=Idle\n[SIM][t=0.60] ENTER state=Idle\n[SIM][t=0.60] ENTER state=Idle\n[SIM][t=0.60] ENTER state=Idle\n[SIM][t=0.60] ENTER state=Idle\n[SIM][t=0.61] ENTER state=Idle\n[SIM][t=0.61] ENTER state=Idle\n[SIM][t=0.61] ENTER state=Idle\n[SIM][t=0.61] ENTER state=Idle\n[SIM][t=0.61] ENTER state=Idle\n[SIM][t=0.62] ENTER state=Idle\n[SIM][t=0.62] ENTER state=Idle\n[SIM][t=0.62] ENTER state=Idle\n[SIM][t=0.62] ENTER state=Idle\n[SIM][t=0.62] ENTER state=Idle\n[SIM][t=0.63] ENTER state=Idle\n[SIM][t=0.63] ENTER state=Idle\n[SIM][t=0.63] ENTER state=Idle\n[SIM][t=0.63] ENTER state=Idle\n[SIM][t=0.63] ENTER state=Idle\n[SIM][t=0.64] ENTER state=Idle\n[SIM][t=0.64] ENTER state=Idle\n[SIM][t=0.64] ENTER state=Idle\n[SIM][t=0.64] ENTER state=Idle\n[SIM][t=0.64] ENTER state=Idle\n[SIM][t=0.65] ENTER state=Idle\n[SIM][t=0.65] ENTER state=Idle\n[SIM][t=0.65] ENTER state=Idle\n[SIM][t=0.65] ENTER state=Idle\n[SIM][t=0.65] ENTER state=Idle\n[SIM][t=0.66] ENTER state=Idle\n[SIM][t=0.66] ENTER state=Idle\n[SIM][t=0.66] ENTER state=Idle\n[SIM][t=0.66] ENTER state=Idle\n[SIM][t=0.66] ENTER state=Idle\n[SIM][t=0.67] ENTER state=Idle\n[SIM][t=0.67] ENTER state=Idle\n[SIM][t=0.67] ENTER state=Idle\n[SIM][t=0.67] ENTER state=Idle\n[SIM][t=0.67] ENTER state=Idle\n[SIM][t=0.68] ENTER state=Idle\n[SIM][t=0.68] ENTER state=Idle\n[SIM][t=0.68] ENTER state=Idle\n[SIM][t=0.68] ENTER state=Idle\n[SIM][t=0.68] ENTER state=Idle\n[SIM][t=0.69] ENTER state=Idle\n[SIM][t=0.69] ENTER state=Idle\n[SIM][t=0.69] ENTER state=Idle\n[SIM][t=0.69] ENTER state=Idle\n[SIM][t=0.69] ENTER state=Idle\n[SIM][t=0.70] ENTER state=Idle\n[SIM][t=0.70] ENTER state=Idle\n[SIM][t=0.70] ENTER state=Idle\n[SIM][t=0.70] ENTER state=Idle\n[SIM][t=0.70] ENTER state=Idle\n[SIM][t=0.71] ENTER state=Idle\n[SIM][t=0.71] ENTER state=Idle\n[SIM][t=0.71] ENTER state=Idle\n[SIM][t=0.71] ENTER state=Idle\n[SIM][t=0.71] ENTER state=Idle\n[SIM][t=0.72] ENTER state=Idle\n[SIM][t=0.72] ENTER state=Idle\n[SIM][t=0.72] ENTER state=Idle\n[SIM][t=0.72] ENTER state=Idle\n[SIM][t=0.72] ENTER state=Idle\n[SIM][t=0.73] ENTER state=Idle\n[SIM][t=0.73] ENTER state=Idle\n[SIM][t=0.73] ENTER state=Idle\n[SIM][t=0.73] ENTER state=Idle\n[SIM][t=0.73] ENTER state=Idle\n[SIM][t=0.74] ENTER state=Idle\n[SIM][t=0.74] ENTER state=Idle\n[SIM][t=0.74] ENTER state=Idle\n[SIM][t=0.74] ENTER state=Idle\n[SIM][t=0.74] ENTER state=Idle\n[SIM][t=0.75] ENTER state=Idle\n[SIM][t=0.75] ENTER state=Idle\n[SIM][t=0.75] ENTER state=Idle\n[SIM][t=0.75] ENTER state=Idle\n[SIM][t=0.75] ENTER state=Idle\n[SIM][t=0.76] ENTER state=Idle\n[SIM][t=0.76] ENTER state=Idle\n[SIM][t=0.76] ENTER state=Idle\n[SIM][t=0.76] ENTER state=Idle\n[SIM][t=0.76] ENTER state=Idle\n[SIM][t=0.77] ENTER state=Idle\n[SIM][t=0.77] ENTER state=Idle\n[SIM][t=0.77] ENTER state=Idle\n[SIM][t=0.77] ENTER state=Idle\n[SIM][t=0.77] ENTER state=Idle\n[SIM][t=0.78] ENTER state=Idle\n[SIM][t=0.78] ENTER state=Idle\n[SIM][t=0.78] ENTER state=Idle\n[SIM][t=0.78] ENTER state=Idle\n[SIM][t=0.78] ENTER state=Idle\n[SIM][t=0.79] ENTER state=Idle\n[SIM][t=0.79] ENTER state=Idle\n[SIM][t=0.79] ENTER state=Idle\n[SIM][t=0.79] ENTER state=Idle\n[SIM][t=0.79] ENTER state=Idle\n[SIM][t=0.80] ENTER state=Idle\n[SIM][t=0.80] ENTER state=Idle\n[SIM][t=0.80] ENTER state=Idle\n[SIM][t=0.80] ENTER state=Idle\n[SIM][t=0.80] ENTER state=Idle\n[SIM][t=0.81] ENTER state=Idle\n[SIM][t=0.81] ENTER state=Idle\n[SIM][t=0.81] ENTER state=Idle\n[SIM][t=0.81] ENTER state=Idle\n[SIM][t=0.81] ENTER state=Idle\n[SIM][t=0.82] ENTER state=Idle\n[SIM][t=0.82] ENTER state=Idle\n[SIM][t=0.82] ENTER state=Idle\n[SIM][t=0.82] ENTER state=Idle\n[SIM][t=0.82] ENTER state=Idle\n[SIM][t=0.83] ENTER state=Idle\n[SIM][t=0.83] ENTER state=Idle\n[SIM][t=0.83] ENTER state=Idle\n[SIM][t=0.83] ENTER state=Idle\n[SIM][t=0.83] ENTER state=Idle\n[SIM][t=0.84] ENTER state=Idle\n[SIM][t=0.84] ENTER state=Idle\n[SIM][t=0.84] ENTER state=Idle\n[SIM][t=0.84] ENTER state=Idle\n[SIM][t=0.84] ENTER state=Idle\n[SIM][t=0.85] ENTER state=Idle\n[SIM][t=0.85] ENTER state=Idle\n[SIM][t=0.85] ENTER state=Idle\n[SIM][t=0.85] ENTER state=Idle\n[SIM][t=0.85] ENTER state=Idle\n[SIM][t=0.86] ENTER state=Idle\n[SIM][t=0.86] ENTER state=Idle\n[SIM][t=0.86] ENTER state=Idle\n[SIM][t=0.86] ENTER state=Idle\n[SIM][t=0.86] ENTER state=Idle\n[SIM][t=0.87] ENTER state=Idle\n[SIM][t=0.87] ENTER state=Idle\n[SIM][t=0.87] ENTER state=Idle\n[SIM][t=0.87] ENTER state=Idle\n[SIM][t=0.87] ENTER state=Idle\n[SIM][t=0.88] ENTER state=Idle\n[SIM][t=0.88] ENTER state=Idle\n[SIM][t=0.88] ENTER state=Idle\n[SIM][t=0.88] ENTER state=Idle\n[SIM][t=0.88] ENTER state=Idle\n[SIM][t=0.89] ENTER state=Idle\n[SIM][t=0.89] ENTER state=Idle\n[SIM][t=0.89] ENTER state=Idle\n[SIM][t=0.89] ENTER state=Idle\n[SIM][t=0.89] ENTER state=Idle\n[SIM][t=0.90] ENTER state=Idle\n[SIM][t=0.90] ENTER state=Idle\n[SIM][t=0.90] ENTER state=Idle\n[SIM][t=0.90] ENTER state=Idle\n[SIM][t=0.90] ENTER state=Idle\n[SIM][t=0.91] ENTER state=Idle\n[SIM][t=0.91] ENTER state=Idle\n[SIM][t=0.91] ENTER state=Idle\n[SIM][t=0.91] ENTER state=Idle\n[SIM][t=0.91] ENTER state=Idle\n[SIM][t=0.92] ENTER state=Idle\n[SIM][t=0.92] ENTER state=Idle\n[SIM][t=0.92] ENTER state=Idle\n[SIM][t=0.92] ENTER state=Idle\n[SIM][t=0.92] ENTER state=Idle\n[SIM][t=0.93] ENTER state=Idle\n[SIM][t=0.93] ENTER state=Idle\n[SIM][t=0.93] ENTER state=Idle\n[SIM][t=0.93] ENTER state=Idle\n[SIM][t=0.93] ENTER state=Idle\n[SIM][t=0.94] ENTER state=Idle\n[SIM][t=0.94] ENTER state=Idle\n[SIM][t=0.94] ENTER state=Idle\n[SIM][t=0.94] ENTER state=Idle\n[SIM][t=0.94] ENTER state=Idle\n[SIM][t=0.95] ENTER state=Idle\n[SIM][t=0.95] ENTER state=Idle\n[SIM][t=0.95] ENTER state=Idle\n[SIM][t=0.95] ENTER state=Idle\n[SIM][t=0.95] ENTER state=Idle\n[SIM][t=0.96] ENTER state=Idle\n[SIM][t=0.96] ENTER state=Idle\n[SIM][t=0.96] ENTER state=Idle\n[SIM][t=0.96] ENTER state=Idle\n[SIM][t=0.96] ENTER state=Idle\n[SIM][t=0.97] ENTER state=Idle\n[SIM][t=0.97] ENTER state=Idle\n[SIM][t=0.97] ENTER state=Idle\n[SIM][t=0.97] ENTER state=Idle\n[SIM][t=0.97] ENTER state=Idle\n[SIM][t=0.98] ENTER state=Idle\n[SIM][t=0.98] ENTER state=Idle\n[SIM][t=0.98] ENTER state=Idle\n[SIM][t=0.98] ENTER state=Idle\n[SIM][t=0.98] ENTER state=Idle\n[SIM][t=0.99] ENTER state=Idle\n[SIM][t=0.99] ENTER state=Idle\n[SIM][t=0.99] ENTER state=Idle\n[SIM][t=0.99] ENTER state=Idle\n[SIM][t=0.99] ENTER state=Idle\n[SIM][t=1.00] ENTER state=Idle\n[SIM][t=1.00] ENTER state=Idle\n[INPUT] Setting request_floor to 3 at t=1.00\n[SIM][t=1.00] ENTER state=Idle\n[SIM][t=1.00] TRANSITION Idle -> MovingUp (reason=request_floor > current_floor)\n[SIM][t=1.00] ENTER state=MovingUp\n\n\nERRORS:\nTraceback (most recent call last):\n  File "C:\\Users\\24760\\AppData\\Roaming\\Python\\Python313\\site-packages\\simpy\\events.py", line 431, in _resume\n    if event.callbacks is not None:\n       ^^^^^^^^^^^^^^^\nAttributeError: \'generator\' object has no attribute \'callbacks\'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File "E:\\VeriSpec\\verispec-lite\\servers\\simulation_server.py", line 41, in execute_simulation_code\n    exec(code_str, exec_globals)\n    ~~~~^^^^^^^^^^^^^^^^^^^^^^^^\n  File "<string>", line 175, in <module>\n  File "<string>", line 170, in run_simulation\n  File "C:\\Users\\24760\\AppData\\Roaming\\Python\\Python313\\site-packages\\simpy\\core.py", line 246, in run\n    self.step()\n    ~~~~~~~~~^^\n  File "C:\\Users\\24760\\AppData\\Roaming\\Python\\Python313\\site-packages\\simpy\\core.py", line 196, in step\n    callback(event)\n    ~~~~~~~~^^^^^^^\n  File "C:\\Users\\24760\\AppData\\Roaming\\Python\\Python313\\site-packages\\simpy\\events.py", line 443, in _resume\n    descr = _describe_frame(self._generator.gi_frame)\n  File "C:\\Users\\24760\\AppData\\Roaming\\Python\\Python313\\site-packages\\simpy\\events.py", line 645, in _describe_frame\n    with open(filename) as f:\n         ~~~~^^^^^^^^^^\nOSError: [Errno 22] Invalid argument: \'<string>\'\n'}, 'isError': False}

architect_agent > ```python
import simpy

class StateMachine:
    def __init__(self, env):
        self.env = env
        self.current_state = 'Idle'
        self.request_floor = None
        self.current_floor = 0
        self.requests = [] # To keep track of active requests

        # Constraints with defaults
        self.door_open_duration = 5
        self.moving_up_increment_time = 2
        self.moving_down_decrement_time = 2

        # Apply constraints from specification if they exist
        constraints_map = {
            'DoorOpen_duration': 'door_open_duration',
            'MovingUp_increment_time': 'moving_up_increment_time',
            'MovingDown_decrement_time': 'moving_down_decrement_time'
        }
        for constraint in specification.get('constraints', []):
            param_name = constraint.get('param')
            param_value = constraint.get('value')
            if param_name in constraints_map and param_value is not None:
                setattr(self, constraints_map[param_name], param_value)

        print("[SIM] Starting simulation")
        self.env.process(self.run())

    def log_state_change(self, from_state, to_state, reason):
        print(f"[SIM][t={self.env.now:.2f}] TRANSITION {from_state} -> {to_state} (reason={reason})")

    def enter_state(self, state_name):
        self.current_state = state_name
        print(f"[SIM][t={self.env.now:.2f}] ENTER state={state_name}")

    def wait_for_event(self, duration, event_name):
        print(f"[SIM][t={self.env.now:.2f}] WAIT {duration}s for {event_name}")
        return self.env.timeout(duration)

    def run(self):
        while True:
            if self.current_state == 'Idle':
                yield from self.idle()
            elif self.current_state == 'MovingUp':
                yield from self.moving_up()
            elif self.current_state == 'MovingDown':
                yield from self.moving_down()
            elif self.current_state == 'DoorOpen':
                yield from self.door_open()
            else:
                # Should not happen in this state machine
                yield self.env.timeout(1) # Prevent infinite loop

    def idle(self):
        if not self.requests:
            # Stay in Idle if no requests
            yield self.env.timeout(0.001) # Yield to allow other processes
            return

        # Process the next request
        next_request = self.requests[0]
        self.request_floor = next_request['floor']
        reason = f"request_floor={self.request_floor} > current_floor={self.current_floor}"
        if self.request_floor > self.current_floor:
            self.log_state_change(self.current_state, 'MovingUp', reason)
            self.enter_state('MovingUp')
            return

        reason = f"request_floor={self.request_floor} < current_floor={self.current_floor}"
        if self.request_floor < self.current_floor:
            self.log_state_change(self.current_state, 'MovingDown', reason)
            self.enter_state('MovingDown')
            return

        # If current_floor == request_floor, it should be handled by DoorOpen state logic in this case
        # However, to avoid deadlock, we will transition to DoorOpen if we are already at the requested floor
        if self.current_floor == self.request_floor:
            self.log_state_change(self.current_state, 'DoorOpen', f"current_floor={self.current_floor} == request_floor={self.request_floor}")
            self.enter_state('DoorOpen')
            return

        yield self.env.timeout(0.001) # Yield to allow other processes

    def moving_up(self):
        # Simulate moving up one floor at a time
        yield self.wait_for_event(self.moving_up_increment_time, "MovingUp increment")
        self.current_floor += 1
        print(f"[SIM][t={self.env.now:.2f}] Current floor: {self.current_floor}")

        # Check if we have reached the requested floor
        if self.current_floor == self.request_floor:
            self.log_state_change(self.current_state, 'DoorOpen', f"current_floor={self.current_floor} == request_floor={self.request_floor}")
            self.enter_state('DoorOpen')
        else:
            # Continue moving up if not yet at the destination
            yield from self.moving_up() # Recursive call to continue moving


    def moving_down(self):
        # Simulate moving down one floor at a time
        yield self.wait_for_event(self.moving_down_decrement_time, "MovingDown decrement")
        self.current_floor -= 1
        print(f"[SIM][t={self.env.now:.2f}] Current floor: {self.current_floor}")

        # Check if we have reached the requested floor
        if self.current_floor == self.request_floor:
            self.log_state_change(self.current_state, 'DoorOpen', f"current_floor={self.current_floor} == request_floor={self.request_floor}")
            self.enter_state('DoorOpen')
        else:
            # Continue moving down if not yet at the destination
            yield from self.moving_down() # Recursive call to continue moving

    def door_open(self):
        yield self.wait_for_event(self.door_open_duration, "Door open duration")

        # Remove the served request
        if self.requests and self.requests[0]['floor'] == self.request_floor:
            self.requests.pop(0)

        self.request_floor = None # Reset request_floor

        if not self.requests:
            self.log_state_change(self.current_state, 'Idle', "no requests")
            self.enter_state('Idle')
        else:
            # Check for new requests or if we need to move again
            if self.requests[0]['floor'] > self.current_floor:
                reason = f"request_floor={self.requests[0]['floor']} > current_floor={self.current_floor}"
                self.log_state_change(self.current_state, 'MovingUp', reason)
                self.enter_state('MovingUp')
            elif self.requests[0]['floor'] < self.current_floor:
                reason = f"request_floor={self.requests[0]['floor']} < current_floor={self.current_floor}"
                self.log_state_change(self.current_state, 'MovingDown', reason)
                self.enter_state('MovingDown')
            else: # request_floor == current_floor, should have been handled, but for safety
                self.log_state_change(self.current_state, 'Idle', "request_floor == current_floor, no further movement needed")
                self.enter_state('Idle') # Stay idle if already at requested floor and that was the only request

        # Ensure yielding even if immediate transition occurs
        yield self.env.timeout(0.001)


def test_scenarios(env, state_machine):
    # Initial state is Idle, current_floor is 0.
    # Let's simulate a few requests

    yield env.timeout(1) # Give simulation a moment to start

    # Request floor 3
    print("[INPUT] Adding request for floor 3")
    state_machine.requests.append({'floor': 3})
    yield env.timeout(5) # Wait a bit

    # Request floor 1
    print("[INPUT] Adding request for floor 1")
    state_machine.requests.append({'floor': 1})
    yield env.timeout(3)

    # Request floor 5
    print("[INPUT] Adding request for floor 5")
    state_machine.requests.append({'floor': 5})
    yield env.timeout(10)

    # Request floor 2
    print("[INPUT] Adding request for floor 2")
    state_machine.requests.append({'floor': 2})
    yield env.timeout(10)


def run_simulation():
    print("[SIM] Starting simulation")
    env = simpy.Environment()
    state_machine = StateMachine(env)

    # This system is input-driven, so we need a process to feed inputs
    env.process(test_scenarios(env, state_machine))

    # Run the simulation for a fixed duration
    # The duration should be long enough to cover the scenarios
    env.run(until=60) # Run for 60 seconds

    print(f"[SIM][t={env.now:.2f}] END simulation")


if __name__ == "__main__":
    # Define the specification globally for StateMachine to access
    specification = {
        'states': [{'name': 'Idle'}, {'name': 'MovingUp'}, {'name': 'MovingDown'}, {'name': 'DoorOpen'}],
        'transitions': [
            {'from': 'Idle', 'to': 'MovingUp', 'condition': 'request_floor > current_floor'},
            {'from': 'Idle', 'to': 'MovingDown', 'condition': 'request_floor < current_floor'},
            {'from': 'MovingUp', 'to': 'DoorOpen', 'condition': 'current_floor == request_floor'},
            {'from': 'MovingDown', 'to': 'DoorOpen', 'condition': 'current_floor == request_floor'},
            {'from': 'DoorOpen', 'to': 'Idle', 'condition': 'no requests'},
            {'from': 'DoorOpen', 'to': 'MovingUp', 'condition': 'request_floor > current_floor'},
            {'from': 'DoorOpen', 'to': 'MovingDown', 'condition': 'request_floor < current_floor'}
        ],
        'constraints': [
            {'param': 'DoorOpen_duration', 'value': 5},
            {'param': 'MovingUp_increment_time', 'value': 2},
            {'param': 'MovingDown_decrement_time', 'value': 2}
        ]
    }
    run_simulation()
```
    Code Generated.
    --- Generated Code ---
import simpy

class StateMachine:
    def __init__(self, env):
        self.env = env
        self.current_state = 'Idle'
        self.request_floor = None
        self.current_floor = 0
        self.requests = [] # To keep track of active requests

        # Constraints with defaults
        self.door_open_duration = 5
        self.moving_up_increment_time = 2
        self.moving_down_decrement_time = 2

        # Apply constraints from specification if they exist
        constraints_map = {
            'DoorOpen_duration': 'door_open_duration',
            'MovingUp_increment_time': 'moving_up_increment_time',
            'MovingDown_decrement_time': 'moving_down_decrement_time'
        }
        for constraint in specification.get('constraints', []):
            param_name = constraint.get('param')
            param_value = constraint.get('value')
            if param_name in constraints_map and param_value is not None:
                setattr(self, constraints_map[param_name], param_value)

        print("[SIM] Starting simulation")
        self.env.process(self.run())

    def log_state_change(self, from_state, to_state, reason):
        print(f"[SIM][t={self.env.now:.2f}] TRANSITION {from_state} -> {to_state} (reason={reason})")

    def enter_state(self, state_name):
        self.current_state = state_name
        print(f"[SIM][t={self.env.now:.2f}] ENTER state={state_name}")

    def wait_for_event(self, duration, event_name):
        print(f"[SIM][t={self.env.now:.2f}] WAIT {duration}s for {event_name}")
        return self.env.timeout(duration)

    def run(self):
        while True:
            if self.current_state == 'Idle':
                yield from self.idle()
            elif self.current_state == 'MovingUp':
                yield from self.moving_up()
            elif self.current_state == 'MovingDown':
                yield from self.moving_down()
            elif self.current_state == 'DoorOpen':
                yield from self.door_open()
            else:
                # Should not happen in this state machine
                yield self.env.timeout(1) # Prevent infinite loop

    def idle(self):
        if not self.requests:
            # Stay in Idle if no requests
            yield self.env.timeout(0.001) # Yield to allow other processes
            return

        # Process the next request
        next_request = self.requests[0]
        self.request_floor = next_request['floor']
        reason = f"request_floor={self.request_floor} > current_floor={self.current_floor}"
        if self.request_floor > self.current_floor:
            self.log_state_change(self.current_state, 'MovingUp', reason)
            self.enter_state('MovingUp')
            return

        reason = f"request_floor={self.request_floor} < current_floor={self.current_floor}"
        if self.request_floor < self.current_floor:
            self.log_state_change(self.current_state, 'MovingDown', reason)
            self.enter_state('MovingDown')
            return

        # If current_floor == request_floor, it should be handled by DoorOpen state logic in this case
        # However, to avoid deadlock, we will transition to DoorOpen if we are already at the requested floor
        if self.current_floor == self.request_floor:
            self.log_state_change(self.current_state, 'DoorOpen', f"current_floor={self.current_floor} == request_floor={self.request_floor}")
            self.enter_state('DoorOpen')
            return

        yield self.env.timeout(0.001) # Yield to allow other processes

    def moving_up(self):
        # Simulate moving up one floor at a time
        yield self.wait_for_event(self.moving_up_increment_time, "MovingUp increment")
        self.current_floor += 1
        print(f"[SIM][t={self.env.now:.2f}] Current floor: {self.current_floor}")

        # Check if we have reached the requested floor
        if self.current_floor == self.request_floor:
            self.log_state_change(self.current_state, 'DoorOpen', f"current_floor={self.current_floor} == request_floor={self.request_floor}")
            self.enter_state('DoorOpen')
        else:
            # Continue moving up if not yet at the destination
            yield from self.moving_up() # Recursive call to continue moving


    def moving_down(self):
        # Simulate moving down one floor at a time
        yield self.wait_for_event(self.moving_down_decrement_time, "MovingDown decrement")
        self.current_floor -= 1
        print(f"[SIM][t={self.env.now:.2f}] Current floor: {self.current_floor}")

        # Check if we have reached the requested floor
        if self.current_floor == self.request_floor:
            self.log_state_change(self.current_state, 'DoorOpen', f"current_floor={self.current_floor} == request_floor={self.request_floor}")
            self.enter_state('DoorOpen')
        else:
            # Continue moving down if not yet at the destination
            yield from self.moving_down() # Recursive call to continue moving

    def door_open(self):
        yield self.wait_for_event(self.door_open_duration, "Door open duration")

        # Remove the served request
        if self.requests and self.requests[0]['floor'] == self.request_floor:
            self.requests.pop(0)

        self.request_floor = None # Reset request_floor

        if not self.requests:
            self.log_state_change(self.current_state, 'Idle', "no requests")
            self.enter_state('Idle')
        else:
            # Check for new requests or if we need to move again
            if self.requests[0]['floor'] > self.current_floor:
                reason = f"request_floor={self.requests[0]['floor']} > current_floor={self.current_floor}"
                self.log_state_change(self.current_state, 'MovingUp', reason)
                self.enter_state('MovingUp')
            elif self.requests[0]['floor'] < self.current_floor:
                reason = f"request_floor={self.requests[0]['floor']} < current_floor={self.current_floor}"
                self.log_state_change(self.current_state, 'MovingDown', reason)
                self.enter_state('MovingDown')
            else: # request_floor == current_floor, should have been handled, but for safety
                self.log_state_change(self.current_state, 'Idle', "request_floor == current_floor, no further movement needed")
                self.enter_state('Idle') # Stay idle if already at requested floor and that was the only request

        # Ensure yielding even if immediate transition occurs
        yield self.env.timeout(0.001)


def test_scenarios(env, state_machine):
    # Initial state is Idle, current_floor is 0.
    # Let's simulate a few requests

    yield env.timeout(1) # Give simulation a moment to start

    # Request floor 3
    print("[INPUT] Adding request for floor 3")
    state_machine.requests.append({'floor': 3})
    yield env.timeout(5) # Wait a bit

    # Request floor 1
    print("[INPUT] Adding request for floor 1")
    state_machine.requests.append({'floor': 1})
    yield env.timeout(3)

    # Request floor 5
    print("[INPUT] Adding request for floor 5")
    state_machine.requests.append({'floor': 5})
    yield env.timeout(10)

    # Request floor 2
    print("[INPUT] Adding request for floor 2")
    state_machine.requests.append({'floor': 2})
    yield env.timeout(10)


def run_simulation():
    print("[SIM] Starting simulation")
    env = simpy.Environment()
    state_machine = StateMachine(env)

    # This system is input-driven, so we need a process to feed inputs
    env.process(test_scenarios(env, state_machine))

    # Run the simulation for a fixed duration
    # The duration should be long enough to cover the scenarios
    env.run(until=60) # Run for 60 seconds

    print(f"[SIM][t={env.now:.2f}] END simulation")


if __name__ == "__main__":
    # Define the specification globally for StateMachine to access
    specification = {
        'states': [{'name': 'Idle'}, {'name': 'MovingUp'}, {'name': 'MovingDown'}, {'name': 'DoorOpen'}],
        'transitions': [
            {'from': 'Idle', 'to': 'MovingUp', 'condition': 'request_floor > current_floor'},
            {'from': 'Idle', 'to': 'MovingDown', 'condition': 'request_floor < current_floor'},
            {'from': 'MovingUp', 'to': 'DoorOpen', 'condition': 'current_floor == request_floor'},
            {'from': 'MovingDown', 'to': 'DoorOpen', 'condition': 'current_floor == request_floor'},
            {'from': 'DoorOpen', 'to': 'Idle', 'condition': 'no requests'},
            {'from': 'DoorOpen', 'to': 'MovingUp', 'condition': 'request_floor > current_floor'},
            {'from': 'DoorOpen', 'to': 'MovingDown', 'condition': 'request_floor < current_floor'}
        ],
        'constraints': [
            {'param': 'DoorOpen_duration', 'value': 5},
            {'param': 'MovingUp_increment_time', 'value': 2},
            {'param': 'MovingDown_decrement_time', 'value': 2}
        ]
    }
    run_simulation()
    ----------------------

[3] Verifier Agent: Executing & Verifying via MCP...

 ### Created new session: debug_session_id

User > 
        Specification:
        {
  "states": [
    {
      "name": "Idle"
    },
    {
      "name": "MovingUp"
    },
    {
      "name": "MovingDown"
    },
    {
      "name": "DoorOpen"
    }
  ],
  "transitions": [
    {
      "from": "Idle",
      "to": "MovingUp",
      "condition": "request_floor > current_floor"
    },
    {
      "from": "Idle",
      "to": "MovingDown",
      "condition": "request_floor < current_floor"
    },
    {
      "from": "MovingUp",
      "to": "DoorOpen",
      "condition": "current_floor == request_floor"
    },
    {
      "from": "MovingDown",
      "to": "DoorOpen",
      "condition": "current_floor == request_floor"
    },
    {
      "from": "DoorOpen",
      "to": "Idle",
      "condition": "no requests"
    },
    {
      "from": "DoorOpen",
      "to": "MovingUp",
      "condition": "request_floor > current_floor"
    },
    {
      "from": "DoorOpen",
      "to": "MovingDown",
      "condition": "request_floor < current_floor"
    }
  ],
  "constraints": [
    {
      "param": "DoorOpen_duration",
      "value": 5
    },
    {
      "param": "MovingUp_increment_time",
      "value": 2
    },
    {
      "param": "MovingDown_decrement_time",
      "value": 2
    }
  ]
}
        
        Simulation Code:
        ```python
        import simpy

class StateMachine:
    def __init__(self, env):
        self.env = env
        self.current_state = 'Idle'
        self.request_floor = None
        self.current_floor = 0
        self.requests = [] # To keep track of active requests

        # Constraints with defaults
        self.door_open_duration = 5
        self.moving_up_increment_time = 2
        self.moving_down_decrement_time = 2

        # Apply constraints from specification if they exist
        constraints_map = {
            'DoorOpen_duration': 'door_open_duration',
            'MovingUp_increment_time': 'moving_up_increment_time',
            'MovingDown_decrement_time': 'moving_down_decrement_time'
        }
        for constraint in specification.get('constraints', []):
            param_name = constraint.get('param')
            param_value = constraint.get('value')
            if param_name in constraints_map and param_value is not None:
                setattr(self, constraints_map[param_name], param_value)

        print("[SIM] Starting simulation")
        self.env.process(self.run())

    def log_state_change(self, from_state, to_state, reason):
        print(f"[SIM][t={self.env.now:.2f}] TRANSITION {from_state} -> {to_state} (reason={reason})")

    def enter_state(self, state_name):
        self.current_state = state_name
        print(f"[SIM][t={self.env.now:.2f}] ENTER state={state_name}")

    def wait_for_event(self, duration, event_name):
        print(f"[SIM][t={self.env.now:.2f}] WAIT {duration}s for {event_name}")
        return self.env.timeout(duration)

    def run(self):
        while True:
            if self.current_state == 'Idle':
                yield from self.idle()
            elif self.current_state == 'MovingUp':
                yield from self.moving_up()
            elif self.current_state == 'MovingDown':
                yield from self.moving_down()
            elif self.current_state == 'DoorOpen':
                yield from self.door_open()
            else:
                # Should not happen in this state machine
                yield self.env.timeout(1) # Prevent infinite loop

    def idle(self):
        if not self.requests:
            # Stay in Idle if no requests
            yield self.env.timeout(0.001) # Yield to allow other processes
            return

        # Process the next request
        next_request = self.requests[0]
        self.request_floor = next_request['floor']
        reason = f"request_floor={self.request_floor} > current_floor={self.current_floor}"
        if self.request_floor > self.current_floor:
            self.log_state_change(self.current_state, 'MovingUp', reason)
            self.enter_state('MovingUp')
            return

        reason = f"request_floor={self.request_floor} < current_floor={self.current_floor}"
        if self.request_floor < self.current_floor:
            self.log_state_change(self.current_state, 'MovingDown', reason)
            self.enter_state('MovingDown')
            return

        # If current_floor == request_floor, it should be handled by DoorOpen state logic in this case
        # However, to avoid deadlock, we will transition to DoorOpen if we are already at the requested floor
        if self.current_floor == self.request_floor:
            self.log_state_change(self.current_state, 'DoorOpen', f"current_floor={self.current_floor} == request_floor={self.request_floor}")
            self.enter_state('DoorOpen')
            return

        yield self.env.timeout(0.001) # Yield to allow other processes

    def moving_up(self):
        # Simulate moving up one floor at a time
        yield self.wait_for_event(self.moving_up_increment_time, "MovingUp increment")
        self.current_floor += 1
        print(f"[SIM][t={self.env.now:.2f}] Current floor: {self.current_floor}")

        # Check if we have reached the requested floor
        if self.current_floor == self.request_floor:
            self.log_state_change(self.current_state, 'DoorOpen', f"current_floor={self.current_floor} == request_floor={self.request_floor}")
            self.enter_state('DoorOpen')
        else:
            # Continue moving up if not yet at the destination
            yield from self.moving_up() # Recursive call to continue moving


    def moving_down(self):
        # Simulate moving down one floor at a time
        yield self.wait_for_event(self.moving_down_decrement_time, "MovingDown decrement")
        self.current_floor -= 1
        print(f"[SIM][t={self.env.now:.2f}] Current floor: {self.current_floor}")

        # Check if we have reached the requested floor
        if self.current_floor == self.request_floor:
            self.log_state_change(self.current_state, 'DoorOpen', f"current_floor={self.current_floor} == request_floor={self.request_floor}")
            self.enter_state('DoorOpen')
        else:
            # Continue moving down if not yet at the destination
            yield from self.moving_down() # Recursive call to continue moving

    def door_open(self):
        yield self.wait_for_event(self.door_open_duration, "Door open duration")

        # Remove the served request
        if self.requests and self.requests[0]['floor'] == self.request_floor:
            self.requests.pop(0)

        self.request_floor = None # Reset request_floor

        if not self.requests:
            self.log_state_change(self.current_state, 'Idle', "no requests")
            self.enter_state('Idle')
        else:
            # Check for new requests or if we need to move again
            if self.requests[0]['floor'] > self.current_floor:
                reason = f"request_floor={self.requests[0]['floor']} > current_floor={self.current_floor}"
                self.log_state_change(self.current_state, 'MovingUp', reason)
                self.enter_state('MovingUp')
            elif self.requests[0]['floor'] < self.current_floor:
                reason = f"request_floor={self.requests[0]['floor']} < current_floor={self.current_floor}"
                self.log_state_change(self.current_state, 'MovingDown', reason)
                self.enter_state('MovingDown')
            else: # request_floor == current_floor, should have been handled, but for safety
                self.log_state_change(self.current_state, 'Idle', "request_floor == current_floor, no further movement needed")
                self.enter_state('Idle') # Stay idle if already at requested floor and that was the only request

        # Ensure yielding even if immediate transition occurs
        yield self.env.timeout(0.001)


def test_scenarios(env, state_machine):
    # Initial state is Idle, current_floor is 0.
    # Let's simulate a few requests

    yield env.timeout(1) # Give simulation a moment to start

    # Request floor 3
    print("[INPUT] Adding request for floor 3")
    state_machine.requests.append({'floor': 3})
    yield env.timeout(5) # Wait a bit

    # Request floor 1
    print("[INPUT] Adding request for floor 1")
    state_machine.requests.append({'floor': 1})
    yield env.timeout(3)

    # Request floor 5
    print("[INPUT] Adding request for floor 5")
    state_machine.requests.append({'floor': 5})
    yield env.timeout(10)

    # Request floor 2
    print("[INPUT] Adding request for floor 2")
    state_machine.requests.append({'floor': 2})
    yield env.timeout(10)


def run_simulation():
    print("[SIM] Starting simulation")
    env = simpy.Environment()
    state_machine = StateMachine(env)

    # This system is input-driven, so we need a process to feed inputs
    env.process(test_scenarios(env, state_machine))

    # Run the simulation for a fixed duration
    # The duration should be long enough to cover the scenarios
    env.run(until=60) # Run for 60 seconds

    print(f"[SIM][t={env.now:.2f}] END simulation")


if __name__ == "__main__":
    # Define the specification globally for StateMachine to access
    specification = {
        'states': [{'name': 'Idle'}, {'name': 'MovingUp'}, {'name': 'MovingDown'}, {'name': 'DoorOpen'}],
        'transitions': [
            {'from': 'Idle', 'to': 'MovingUp', 'condition': 'request_floor > current_floor'},
            {'from': 'Idle', 'to': 'MovingDown', 'condition': 'request_floor < current_floor'},
            {'from': 'MovingUp', 'to': 'DoorOpen', 'condition': 'current_floor == request_floor'},
            {'from': 'MovingDown', 'to': 'DoorOpen', 'condition': 'current_floor == request_floor'},
            {'from': 'DoorOpen', 'to': 'Idle', 'condition': 'no requests'},
            {'from': 'DoorOpen', 'to': 'MovingUp', 'condition': 'request_floor > current_floor'},
            {'from': 'DoorOpen', 'to': 'MovingDown', 'condition': 'request_floor < current_floor'}
        ],
        'constraints': [
            {'param': 'DoorOpen_duration', 'value': 5},
            {'param': 'MovingUp_increment_time', 'value': 2},
            {'param': 'MovingDown_decrement_time', 'value': 2}
        ]
    }
    run_simulation()
        ```
        
        Please execute this code and verify the results.
        
[DEBUG] Sessions dict keys: ['InMemoryRunner']
[DEBUG] Session value type for key 'InMemoryRunner': <class 'dict'>
[DEBUG] Nested keys: ['debug_user_id']
[DEBUG] Nested value type for key 'debug_user_id': <class 'dict'>
[DEBUG] Triple nested keys: ['debug_session_id']
[DEBUG] Found session from triple nested dict: debug_session_id
[DEBUG] Session events count: 2
[DEBUG] Session events count: 2
[DEBUG] Response length: 1
[DEBUG] Event -2 type: <class 'google.adk.events.event.Event'>
[DEBUG] Event content parts: 0
    Verification: {'status': 'FAIL', 'reason': 'No simulation logs produced and no model response', 'retry': True}
    Retrying...

[2] Architect Agent: Generating Code (Attempt 4)...

 ### Created new session: debug_session_id

User > Specification:
{'states': [{'name': 'Idle'}, {'name': 'MovingUp'}, {'name': 'MovingDown'}, {'name': 'DoorOpen'}], 'transitions': [{'from': 'Idle', 'to': 'MovingUp', 'condition': 'request_floor > current_floor'}, {'from': 'Idle', 'to': 'MovingDown', 'condition': 'request_floor < current_floor'}, {'from': 'MovingUp', 'to': 'DoorOpen', 'condition': 'current_floor == request_floor'}, {'from': 'MovingDown', 'to': 'DoorOpen', 'condition': 'current_floor == request_floor'}, {'from': 'DoorOpen', 'to': 'Idle', 'condition': 'no requests'}, {'from': 'DoorOpen', 'to': 'MovingUp', 'condition': 'request_floor > current_floor'}, {'from': 'DoorOpen', 'to': 'MovingDown', 'condition': 'request_floor < current_floor'}], 'constraints': [{'param': 'DoorOpen_duration', 'value': 5}, {'param': 'MovingUp_increment_time', 'value': 2}, {'param': 'MovingDown_decrement_time', 'value': 2}]}

FEEDBACK FROM PREVIOUS ATTEMPT (FIX THESE ERRORS):
Verification Failed: No simulation logs produced and no model response
Logs/Errors:
None
architect_agent > ```python
import simpy
import random

class StateMachine:
    def __init__(self, env, constraints):
        self.env = env
        self.constraints = constraints
        self.current_state = 'Idle'
        self.current_floor = 0
        self.request_floor = 0
        self.no_requests = True  # Assume no requests initially

        # Assign sensible defaults if constraints are missing or None
        self.door_open_duration = self.constraints.get('DoorOpen_duration', 5)
        self.moving_up_increment_time = self.constraints.get('MovingUp_increment_time', 2)
        self.moving_down_decrement_time = self.constraints.get('MovingDown_decrement_time', 2)

        # Internal state flags to manage transitions and conditions
        self.door_open_timer = None # Timer for DoorOpen state

    def log_transition(self, from_state, to_state, condition):
        print(f"[SIM][t={self.env.now}] TRANSITION {from_state} -> {to_state} (reason={condition})")

    def log_state_entry(self, state_name):
        print(f"[SIM][t={self.env.now}] ENTER state={state_name}")

    def log_wait(self, duration, event_name):
        print(f"[SIM][t={self.env.now}] WAIT {duration}s for {event_name}")

    def enter_state(self, state_name):
        self.log_state_entry(state_name)
        self.current_state = state_name

    def idle(self):
        self.log_state_entry('Idle')
        while True:
            # In Idle state, we wait for external requests.
            # For simulation purposes, we yield a small timeout to avoid busy-waiting
            # and allow other processes to run.
            yield self.env.timeout(0.1)
            # The actual transition logic will be handled in the `run` method
            # based on updated `self.request_floor` and `self.current_floor`.
            # If a transition occurs, the loop will break and `run` will pick up the new state.
            if self.current_state != 'Idle':
                break

    def moving_up(self):
        self.log_state_entry('MovingUp')
        # Simulate moving up, one floor at a time
        while self.current_floor < self.request_floor:
            yield self.env.timeout(self.moving_up_increment_time)
            self.current_floor += 1
            print(f"[SIM][t={self.env.now}] Current floor: {self.current_floor}")
            if self.current_floor == self.request_floor:
                break
        # Transition to DoorOpen if arrived at the request_floor
        if self.current_floor == self.request_floor:
            pass # Will be handled by the `run` method checking conditions
        else:
            # This case should ideally not happen if logic is correct,
            # but as a fallback, return to Idle if something went wrong.
            self.log_transition('MovingUp', 'Idle', 'error_in_moving_up')
            self.current_state = 'Idle'

    def moving_down(self):
        self.log_state_entry('MovingDown')
        # Simulate moving down, one floor at a time
        while self.current_floor > self.request_floor:
            yield self.env.timeout(self.moving_down_decrement_time)
            self.current_floor -= 1
            print(f"[SIM][t={self.env.now}] Current floor: {self.current_floor}")
            if self.current_floor == self.request_floor:
                break
        # Transition to DoorOpen if arrived at the request_floor
        if self.current_floor == self.request_floor:
            pass # Will be handled by the `run` method checking conditions
        else:
            # Fallback for errors
            self.log_transition('MovingDown', 'Idle', 'error_in_moving_down')
            self.current_state = 'Idle'

    def door_open(self):
        self.log_state_entry('DoorOpen')
        self.no_requests = True # Assume requests are cleared once door is open and passengers exit/enter.
        self.door_open_timer = self.env.timeout(self.door_open_duration)
        self.log_wait(self.door_open_duration, 'door_close')
        yield self.door_open_timer
        # After door duration, transition logic will be handled by the `run` method.

    def run(self):
        while True:
            if self.current_state == 'Idle':
                yield from self.idle()
            elif self.current_state == 'MovingUp':
                yield from self.moving_up()
            elif self.current_state == 'MovingDown':
                yield from self.moving_down()
            elif self.current_state == 'DoorOpen':
                yield from self.door_open()

            # State Transition Logic after executing a state's process
            if self.current_state == 'Idle':
                if self.request_floor > self.current_floor:
                    self.log_transition('Idle', 'MovingUp', 'request_floor > current_floor')
                    self.current_state = 'MovingUp'
                    continue
                elif self.request_floor < self.current_floor:
                    self.log_transition('Idle', 'MovingDown', 'request_floor < current_floor')
                    self.current_state = 'MovingDown'
                    continue
                else:
                    # Stay in Idle if no movement needed
                    pass
            elif self.current_state == 'MovingUp':
                if self.current_floor == self.request_floor:
                    self.log_transition('MovingUp', 'DoorOpen', 'current_floor == request_floor')
                    self.current_state = 'DoorOpen'
                    continue
            elif self.current_state == 'MovingDown':
                if self.current_floor == self.request_floor:
                    self.log_transition('MovingDown', 'DoorOpen', 'current_floor == request_floor')
                    self.current_state = 'DoorOpen'
                    continue
            elif self.current_state == 'DoorOpen':
                if self.no_requests:
                    self.log_transition('DoorOpen', 'Idle', 'no requests')
                    self.current_state = 'Idle'
                    continue
                elif self.request_floor > self.current_floor:
                    self.log_transition('DoorOpen', 'MovingUp', 'request_floor > current_floor')
                    self.current_state = 'MovingUp'
                    continue
                elif self.request_floor < self.current_floor:
                    self.log_transition('DoorOpen', 'MovingDown', 'request_floor < current_floor')
                    self.current_state = 'MovingDown'
                    continue
                else:
                    # Stay in DoorOpen if no new requests after door closes
                    pass
            
            # Ensure we yield something to allow other processes to run if no state change occurred
            # and the current state's `yield from` has completed without yielding control.
            if self.current_state in ['Idle']: # States that might loop without explicit yield in their body
                yield self.env.timeout(0.001)


def test_scenarios(env, state_machine):
    """
    This function simulates external requests to drive the state machine.
    It represents an input-driven or hybrid system scenario.
    """
    yield env.timeout(1) # Initial delay before first request

    # Scenario 1: Go up to floor 3
    print("[SIM] SCENARIO: Requesting floor 3")
    state_machine.request_floor = 3
    state_machine.no_requests = False
    yield env.timeout(2)

    # Scenario 2: Request floor 5 from floor 3
    print("[SIM] SCENARIO: Requesting floor 5")
    state_machine.request_floor = 5
    state_machine.no_requests = False # This request means there IS a request
    yield env.timeout(3)

    # Scenario 3: Request floor 2 from floor 5
    print("[SIM] SCENARIO: Requesting floor 2")
    state_machine.request_floor = 2
    state_machine.no_requests = False
    yield env.timeout(4)

    # Scenario 4: No more requests
    print("[SIM] SCENARIO: No more requests")
    state_machine.request_floor = state_machine.current_floor # Setting request to current floor means no movement needed.
    state_machine.no_requests = True
    yield env.timeout(6)

    # Scenario 5: Request floor 1 from floor 2
    print("[SIM] SCENARIO: Requesting floor 1")
    state_machine.request_floor = 1
    state_machine.no_requests = False
    yield env.timeout(3)

    # Scenario 6: No more requests, end simulation
    print("[SIM] SCENARIO: No more requests")
    state_machine.request_floor = state_machine.current_floor
    state_machine.no_requests = True
    yield env.timeout(2) # Wait a bit to let the state machine settle

def run_simulation():
    """
    Sets up and runs the SimPy simulation.
    """
    print("[SIM] Starting simulation")
    constraints = {
        'DoorOpen_duration': 5,
        'MovingUp_increment_time': 2,
        'MovingDown_decrement_time': 2
    }
    env = simpy.Environment()
    state_machine = StateMachine(env, constraints)

    # Start the state machine process
    env.process(state_machine.run())

    # Start the scenario driver process (for input-driven system)
    env.process(test_scenarios(env, state_machine))

    # Run the simulation until a certain time
    env.run(until=60) # Run for 60 seconds

    print(f"[SIM] END simulation at t={env.now}")

if __name__ == "__main__":
    run_simulation()
```
    Code Generated.
    --- Generated Code ---
import simpy
import random

class StateMachine:
    def __init__(self, env, constraints):
        self.env = env
        self.constraints = constraints
        self.current_state = 'Idle'
        self.current_floor = 0
        self.request_floor = 0
        self.no_requests = True  # Assume no requests initially

        # Assign sensible defaults if constraints are missing or None
        self.door_open_duration = self.constraints.get('DoorOpen_duration', 5)
        self.moving_up_increment_time = self.constraints.get('MovingUp_increment_time', 2)
        self.moving_down_decrement_time = self.constraints.get('MovingDown_decrement_time', 2)

        # Internal state flags to manage transitions and conditions
        self.door_open_timer = None # Timer for DoorOpen state

    def log_transition(self, from_state, to_state, condition):
        print(f"[SIM][t={self.env.now}] TRANSITION {from_state} -> {to_state} (reason={condition})")

    def log_state_entry(self, state_name):
        print(f"[SIM][t={self.env.now}] ENTER state={state_name}")

    def log_wait(self, duration, event_name):
        print(f"[SIM][t={self.env.now}] WAIT {duration}s for {event_name}")

    def enter_state(self, state_name):
        self.log_state_entry(state_name)
        self.current_state = state_name

    def idle(self):
        self.log_state_entry('Idle')
        while True:
            # In Idle state, we wait for external requests.
            # For simulation purposes, we yield a small timeout to avoid busy-waiting
            # and allow other processes to run.
            yield self.env.timeout(0.1)
            # The actual transition logic will be handled in the `run` method
            # based on updated `self.request_floor` and `self.current_floor`.
            # If a transition occurs, the loop will break and `run` will pick up the new state.
            if self.current_state != 'Idle':
                break

    def moving_up(self):
        self.log_state_entry('MovingUp')
        # Simulate moving up, one floor at a time
        while self.current_floor < self.request_floor:
            yield self.env.timeout(self.moving_up_increment_time)
            self.current_floor += 1
            print(f"[SIM][t={self.env.now}] Current floor: {self.current_floor}")
            if self.current_floor == self.request_floor:
                break
        # Transition to DoorOpen if arrived at the request_floor
        if self.current_floor == self.request_floor:
            pass # Will be handled by the `run` method checking conditions
        else:
            # This case should ideally not happen if logic is correct,
            # but as a fallback, return to Idle if something went wrong.
            self.log_transition('MovingUp', 'Idle', 'error_in_moving_up')
            self.current_state = 'Idle'

    def moving_down(self):
        self.log_state_entry('MovingDown')
        # Simulate moving down, one floor at a time
        while self.current_floor > self.request_floor:
            yield self.env.timeout(self.moving_down_decrement_time)
            self.current_floor -= 1
            print(f"[SIM][t={self.env.now}] Current floor: {self.current_floor}")
            if self.current_floor == self.request_floor:
                break
        # Transition to DoorOpen if arrived at the request_floor
        if self.current_floor == self.request_floor:
            pass # Will be handled by the `run` method checking conditions
        else:
            # Fallback for errors
            self.log_transition('MovingDown', 'Idle', 'error_in_moving_down')
            self.current_state = 'Idle'

    def door_open(self):
        self.log_state_entry('DoorOpen')
        self.no_requests = True # Assume requests are cleared once door is open and passengers exit/enter.
        self.door_open_timer = self.env.timeout(self.door_open_duration)
        self.log_wait(self.door_open_duration, 'door_close')
        yield self.door_open_timer
        # After door duration, transition logic will be handled by the `run` method.

    def run(self):
        while True:
            if self.current_state == 'Idle':
                yield from self.idle()
            elif self.current_state == 'MovingUp':
                yield from self.moving_up()
            elif self.current_state == 'MovingDown':
                yield from self.moving_down()
            elif self.current_state == 'DoorOpen':
                yield from self.door_open()

            # State Transition Logic after executing a state's process
            if self.current_state == 'Idle':
                if self.request_floor > self.current_floor:
                    self.log_transition('Idle', 'MovingUp', 'request_floor > current_floor')
                    self.current_state = 'MovingUp'
                    continue
                elif self.request_floor < self.current_floor:
                    self.log_transition('Idle', 'MovingDown', 'request_floor < current_floor')
                    self.current_state = 'MovingDown'
                    continue
                else:
                    # Stay in Idle if no movement needed
                    pass
            elif self.current_state == 'MovingUp':
                if self.current_floor == self.request_floor:
                    self.log_transition('MovingUp', 'DoorOpen', 'current_floor == request_floor')
                    self.current_state = 'DoorOpen'
                    continue
            elif self.current_state == 'MovingDown':
                if self.current_floor == self.request_floor:
                    self.log_transition('MovingDown', 'DoorOpen', 'current_floor == request_floor')
                    self.current_state = 'DoorOpen'
                    continue
            elif self.current_state == 'DoorOpen':
                if self.no_requests:
                    self.log_transition('DoorOpen', 'Idle', 'no requests')
                    self.current_state = 'Idle'
                    continue
                elif self.request_floor > self.current_floor:
                    self.log_transition('DoorOpen', 'MovingUp', 'request_floor > current_floor')
                    self.current_state = 'MovingUp'
                    continue
                elif self.request_floor < self.current_floor:
                    self.log_transition('DoorOpen', 'MovingDown', 'request_floor < current_floor')
                    self.current_state = 'MovingDown'
                    continue
                else:
                    # Stay in DoorOpen if no new requests after door closes
                    pass
            
            # Ensure we yield something to allow other processes to run if no state change occurred
            # and the current state's `yield from` has completed without yielding control.
            if self.current_state in ['Idle']: # States that might loop without explicit yield in their body
                yield self.env.timeout(0.001)


def test_scenarios(env, state_machine):
    """
    This function simulates external requests to drive the state machine.
    It represents an input-driven or hybrid system scenario.
    """
    yield env.timeout(1) # Initial delay before first request

    # Scenario 1: Go up to floor 3
    print("[SIM] SCENARIO: Requesting floor 3")
    state_machine.request_floor = 3
    state_machine.no_requests = False
    yield env.timeout(2)

    # Scenario 2: Request floor 5 from floor 3
    print("[SIM] SCENARIO: Requesting floor 5")
    state_machine.request_floor = 5
    state_machine.no_requests = False # This request means there IS a request
    yield env.timeout(3)

    # Scenario 3: Request floor 2 from floor 5
    print("[SIM] SCENARIO: Requesting floor 2")
    state_machine.request_floor = 2
    state_machine.no_requests = False
    yield env.timeout(4)

    # Scenario 4: No more requests
    print("[SIM] SCENARIO: No more requests")
    state_machine.request_floor = state_machine.current_floor # Setting request to current floor means no movement needed.
    state_machine.no_requests = True
    yield env.timeout(6)

    # Scenario 5: Request floor 1 from floor 2
    print("[SIM] SCENARIO: Requesting floor 1")
    state_machine.request_floor = 1
    state_machine.no_requests = False
    yield env.timeout(3)

    # Scenario 6: No more requests, end simulation
    print("[SIM] SCENARIO: No more requests")
    state_machine.request_floor = state_machine.current_floor
    state_machine.no_requests = True
    yield env.timeout(2) # Wait a bit to let the state machine settle

def run_simulation():
    """
    Sets up and runs the SimPy simulation.
    """
    print("[SIM] Starting simulation")
    constraints = {
        'DoorOpen_duration': 5,
        'MovingUp_increment_time': 2,
        'MovingDown_decrement_time': 2
    }
    env = simpy.Environment()
    state_machine = StateMachine(env, constraints)

    # Start the state machine process
    env.process(state_machine.run())

    # Start the scenario driver process (for input-driven system)
    env.process(test_scenarios(env, state_machine))

    # Run the simulation until a certain time
    env.run(until=60) # Run for 60 seconds

    print(f"[SIM] END simulation at t={env.now}")

if __name__ == "__main__":
    run_simulation()
    ----------------------

[3] Verifier Agent: Executing & Verifying via MCP...

 ### Created new session: debug_session_id

User > 
        Specification:
        {
  "states": [
    {
      "name": "Idle"
    },
    {
      "name": "MovingUp"
    },
    {
      "name": "MovingDown"
    },
    {
      "name": "DoorOpen"
    }
  ],
  "transitions": [
    {
      "from": "Idle",
      "to": "MovingUp",
      "condition": "request_floor > current_floor"
    },
    {
      "from": "Idle",
      "to": "MovingDown",
      "condition": "request_floor < current_floor"
    },
    {
      "from": "MovingUp",
      "to": "DoorOpen",
      "condition": "current_floor == request_floor"
    },
    {
      "from": "MovingDown",
      "to": "DoorOpen",
      "condition": "current_floor == request_floor"
    },
    {
      "from": "DoorOpen",
      "to": "Idle",
      "condition": "no requests"
    },
    {
      "from": "DoorOpen",
      "to": "MovingUp",
      "condition": "request_floor > current_floor"
    },
    {
      "from": "DoorOpen",
      "to": "MovingDown",
      "condition": "request_floor < current_floor"
    }
  ],
  "constraints": [
    {
      "param": "DoorOpen_duration",
      "value": 5
    },
    {
      "param": "MovingUp_increment_time",
      "value": 2
    },
    {
      "param": "MovingDown_decrement_time",
      "value": 2
    }
  ]
}
        
        Simulation Code:
        ```python
        import simpy
import random

class StateMachine:
    def __init__(self, env, constraints):
        self.env = env
        self.constraints = constraints
        self.current_state = 'Idle'
        self.current_floor = 0
        self.request_floor = 0
        self.no_requests = True  # Assume no requests initially

        # Assign sensible defaults if constraints are missing or None
        self.door_open_duration = self.constraints.get('DoorOpen_duration', 5)
        self.moving_up_increment_time = self.constraints.get('MovingUp_increment_time', 2)
        self.moving_down_decrement_time = self.constraints.get('MovingDown_decrement_time', 2)

        # Internal state flags to manage transitions and conditions
        self.door_open_timer = None # Timer for DoorOpen state

    def log_transition(self, from_state, to_state, condition):
        print(f"[SIM][t={self.env.now}] TRANSITION {from_state} -> {to_state} (reason={condition})")

    def log_state_entry(self, state_name):
        print(f"[SIM][t={self.env.now}] ENTER state={state_name}")

    def log_wait(self, duration, event_name):
        print(f"[SIM][t={self.env.now}] WAIT {duration}s for {event_name}")

    def enter_state(self, state_name):
        self.log_state_entry(state_name)
        self.current_state = state_name

    def idle(self):
        self.log_state_entry('Idle')
        while True:
            # In Idle state, we wait for external requests.
            # For simulation purposes, we yield a small timeout to avoid busy-waiting
            # and allow other processes to run.
            yield self.env.timeout(0.1)
            # The actual transition logic will be handled in the `run` method
            # based on updated `self.request_floor` and `self.current_floor`.
            # If a transition occurs, the loop will break and `run` will pick up the new state.
            if self.current_state != 'Idle':
                break

    def moving_up(self):
        self.log_state_entry('MovingUp')
        # Simulate moving up, one floor at a time
        while self.current_floor < self.request_floor:
            yield self.env.timeout(self.moving_up_increment_time)
            self.current_floor += 1
            print(f"[SIM][t={self.env.now}] Current floor: {self.current_floor}")
            if self.current_floor == self.request_floor:
                break
        # Transition to DoorOpen if arrived at the request_floor
        if self.current_floor == self.request_floor:
            pass # Will be handled by the `run` method checking conditions
        else:
            # This case should ideally not happen if logic is correct,
            # but as a fallback, return to Idle if something went wrong.
            self.log_transition('MovingUp', 'Idle', 'error_in_moving_up')
            self.current_state = 'Idle'

    def moving_down(self):
        self.log_state_entry('MovingDown')
        # Simulate moving down, one floor at a time
        while self.current_floor > self.request_floor:
            yield self.env.timeout(self.moving_down_decrement_time)
            self.current_floor -= 1
            print(f"[SIM][t={self.env.now}] Current floor: {self.current_floor}")
            if self.current_floor == self.request_floor:
                break
        # Transition to DoorOpen if arrived at the request_floor
        if self.current_floor == self.request_floor:
            pass # Will be handled by the `run` method checking conditions
        else:
            # Fallback for errors
            self.log_transition('MovingDown', 'Idle', 'error_in_moving_down')
            self.current_state = 'Idle'

    def door_open(self):
        self.log_state_entry('DoorOpen')
        self.no_requests = True # Assume requests are cleared once door is open and passengers exit/enter.
        self.door_open_timer = self.env.timeout(self.door_open_duration)
        self.log_wait(self.door_open_duration, 'door_close')
        yield self.door_open_timer
        # After door duration, transition logic will be handled by the `run` method.

    def run(self):
        while True:
            if self.current_state == 'Idle':
                yield from self.idle()
            elif self.current_state == 'MovingUp':
                yield from self.moving_up()
            elif self.current_state == 'MovingDown':
                yield from self.moving_down()
            elif self.current_state == 'DoorOpen':
                yield from self.door_open()

            # State Transition Logic after executing a state's process
            if self.current_state == 'Idle':
                if self.request_floor > self.current_floor:
                    self.log_transition('Idle', 'MovingUp', 'request_floor > current_floor')
                    self.current_state = 'MovingUp'
                    continue
                elif self.request_floor < self.current_floor:
                    self.log_transition('Idle', 'MovingDown', 'request_floor < current_floor')
                    self.current_state = 'MovingDown'
                    continue
                else:
                    # Stay in Idle if no movement needed
                    pass
            elif self.current_state == 'MovingUp':
                if self.current_floor == self.request_floor:
                    self.log_transition('MovingUp', 'DoorOpen', 'current_floor == request_floor')
                    self.current_state = 'DoorOpen'
                    continue
            elif self.current_state == 'MovingDown':
                if self.current_floor == self.request_floor:
                    self.log_transition('MovingDown', 'DoorOpen', 'current_floor == request_floor')
                    self.current_state = 'DoorOpen'
                    continue
            elif self.current_state == 'DoorOpen':
                if self.no_requests:
                    self.log_transition('DoorOpen', 'Idle', 'no requests')
                    self.current_state = 'Idle'
                    continue
                elif self.request_floor > self.current_floor:
                    self.log_transition('DoorOpen', 'MovingUp', 'request_floor > current_floor')
                    self.current_state = 'MovingUp'
                    continue
                elif self.request_floor < self.current_floor:
                    self.log_transition('DoorOpen', 'MovingDown', 'request_floor < current_floor')
                    self.current_state = 'MovingDown'
                    continue
                else:
                    # Stay in DoorOpen if no new requests after door closes
                    pass
            
            # Ensure we yield something to allow other processes to run if no state change occurred
            # and the current state's `yield from` has completed without yielding control.
            if self.current_state in ['Idle']: # States that might loop without explicit yield in their body
                yield self.env.timeout(0.001)


def test_scenarios(env, state_machine):
    """
    This function simulates external requests to drive the state machine.
    It represents an input-driven or hybrid system scenario.
    """
    yield env.timeout(1) # Initial delay before first request

    # Scenario 1: Go up to floor 3
    print("[SIM] SCENARIO: Requesting floor 3")
    state_machine.request_floor = 3
    state_machine.no_requests = False
    yield env.timeout(2)

    # Scenario 2: Request floor 5 from floor 3
    print("[SIM] SCENARIO: Requesting floor 5")
    state_machine.request_floor = 5
    state_machine.no_requests = False # This request means there IS a request
    yield env.timeout(3)

    # Scenario 3: Request floor 2 from floor 5
    print("[SIM] SCENARIO: Requesting floor 2")
    state_machine.request_floor = 2
    state_machine.no_requests = False
    yield env.timeout(4)

    # Scenario 4: No more requests
    print("[SIM] SCENARIO: No more requests")
    state_machine.request_floor = state_machine.current_floor # Setting request to current floor means no movement needed.
    state_machine.no_requests = True
    yield env.timeout(6)

    # Scenario 5: Request floor 1 from floor 2
    print("[SIM] SCENARIO: Requesting floor 1")
    state_machine.request_floor = 1
    state_machine.no_requests = False
    yield env.timeout(3)

    # Scenario 6: No more requests, end simulation
    print("[SIM] SCENARIO: No more requests")
    state_machine.request_floor = state_machine.current_floor
    state_machine.no_requests = True
    yield env.timeout(2) # Wait a bit to let the state machine settle

def run_simulation():
    """
    Sets up and runs the SimPy simulation.
    """
    print("[SIM] Starting simulation")
    constraints = {
        'DoorOpen_duration': 5,
        'MovingUp_increment_time': 2,
        'MovingDown_decrement_time': 2
    }
    env = simpy.Environment()
    state_machine = StateMachine(env, constraints)

    # Start the state machine process
    env.process(state_machine.run())

    # Start the scenario driver process (for input-driven system)
    env.process(test_scenarios(env, state_machine))

    # Run the simulation until a certain time
    env.run(until=60) # Run for 60 seconds

    print(f"[SIM] END simulation at t={env.now}")

if __name__ == "__main__":
    run_simulation()
        ```
        
        Please execute this code and verify the results.
        
[DEBUG] Sessions dict keys: ['InMemoryRunner']
[DEBUG] Session value type for key 'InMemoryRunner': <class 'dict'>
[DEBUG] Nested keys: ['debug_user_id']
[DEBUG] Nested value type for key 'debug_user_id': <class 'dict'>
[DEBUG] Triple nested keys: ['debug_session_id']
[DEBUG] Found session from triple nested dict: debug_session_id
[DEBUG] Session events count: 4
[DEBUG] Session events count: 4
[DEBUG] Response length: 3
[DEBUG] Event 0 type: <class 'google.adk.events.event.Event'>
[DEBUG] Event content parts: 1
[DEBUG] Part type: <class 'google.genai.types.Part'>
[DEBUG] Part text (snippet): None
[DEBUG] Part function_response: Yes
[DEBUG] Event 1 type: <class 'google.adk.events.event.Event'>
[DEBUG] Event content parts: 1
[DEBUG] Part type: <class 'google.genai.types.Part'>
[DEBUG] Part text (snippet): None
[DEBUG] Part function_response: Yes
[DEBUG] Event 2 type: <class 'google.adk.events.event.Event'>
[DEBUG] Event content parts: 0
    Verification: {'status': 'FAIL', 'reason': 'Empty response from Verifier Agent', 'retry': True, 'logs': '[SIM] Starting simulation\n[SIM][t=0] ENTER state=Idle\n[SIM] SCENARIO: Requesting floor 3\n[SIM] SCENARIO: Requesting floor 5\n[SIM] SCENARIO: Requesting floor 2\n[SIM] SCENARIO: No more requests\n[SIM] SCENARIO: Requesting floor 1\n[SIM] END simulation at t=60\n'}
    Retrying...

[2] Architect Agent: Generating Code (Attempt 5)...

 ### Created new session: debug_session_id

User > Specification:
{'states': [{'name': 'Idle'}, {'name': 'MovingUp'}, {'name': 'MovingDown'}, {'name': 'DoorOpen'}], 'transitions': [{'from': 'Idle', 'to': 'MovingUp', 'condition': 'request_floor > current_floor'}, {'from': 'Idle', 'to': 'MovingDown', 'condition': 'request_floor < current_floor'}, {'from': 'MovingUp', 'to': 'DoorOpen', 'condition': 'current_floor == request_floor'}, {'from': 'MovingDown', 'to': 'DoorOpen', 'condition': 'current_floor == request_floor'}, {'from': 'DoorOpen', 'to': 'Idle', 'condition': 'no requests'}, {'from': 'DoorOpen', 'to': 'MovingUp', 'condition': 'request_floor > current_floor'}, {'from': 'DoorOpen', 'to': 'MovingDown', 'condition': 'request_floor < current_floor'}], 'constraints': [{'param': 'DoorOpen_duration', 'value': 5}, {'param': 'MovingUp_increment_time', 'value': 2}, {'param': 'MovingDown_decrement_time', 'value': 2}]}

FEEDBACK FROM PREVIOUS ATTEMPT (FIX THESE ERRORS):
Verification Failed: Empty response from Verifier Agent
Logs/Errors:
[SIM] Starting simulation
[SIM][t=0] ENTER state=Idle
[SIM] SCENARIO: Requesting floor 3
[SIM] SCENARIO: Requesting floor 5
[SIM] SCENARIO: Requesting floor 2
[SIM] SCENARIO: No more requests
[SIM] SCENARIO: Requesting floor 1
[SIM] END simulation at t=60

architect_agent > ```python
import simpy

class StateMachine:
    def __init__(self, env):
        self.env = env
        self.current_state = 'Idle'
        self.request_floor = 0
        self.current_floor = 0
        self.constraints = {
            'DoorOpen_duration': 5,
            'MovingUp_increment_time': 2,
            'MovingDown_decrement_time': 2
        }
        self.elevator_requests = [] # Simulate external requests

    def log_state_entry(self, state_name):
        print(f"[SIM][t={self.env.now:.2f}] ENTER state={state_name}")

    def log_wait(self, duration, event_name):
        print(f"[SIM][t={self.env.now:.2f}] WAIT {duration:.2f}s for {event_name}")

    def log_transition(self, from_state, to_state, condition):
        print(f"[SIM][t={self.env.now:.2f}] TRANSITION {from_state} -> {to_state} (reason={condition})")

    def log_end(self, final_state):
        print(f"[SIM][t={self.env.now:.2f}] END state={final_state}")

    def set_state(self, new_state, condition=""):
        if self.current_state != new_state:
            self.log_transition(self.current_state, new_state, condition)
            self.current_state = new_state
            self.log_state_entry(self.current_state)

    # State methods (generators)
    def idle(self):
        self.log_state_entry('Idle')
        if not self.elevator_requests:
            # Stay in Idle if no requests
            yield self.env.timeout(0.001) # Keep it a generator
            return

        next_request = self.elevator_requests[0] # Get the earliest request
        self.request_floor = next_request['floor']

        if self.request_floor > self.current_floor:
            self.set_state('MovingUp', f'request_floor ({self.request_floor}) > current_floor ({self.current_floor})')
        elif self.request_floor < self.current_floor:
            self.set_state('MovingDown', f'request_floor ({self.request_floor}) < current_floor ({self.current_floor})')
        else: # If already at the requested floor
            self.set_state('DoorOpen', f'current_floor ({self.current_floor}) == request_floor ({self.request_floor})')

        # Remove the processed request
        self.elevator_requests.pop(0)


    def moving_up(self):
        self.log_state_entry('MovingUp')
        self.log_wait(self.constraints['MovingUp_increment_time'], 'MovingUp_increment_time')
        yield self.env.timeout(self.constraints['MovingUp_increment_time'])
        self.current_floor += 1
        print(f"[SIM][t={self.env.now:.2f}] INFO: Elevator moved to floor {self.current_floor}")

        if self.current_floor == self.request_floor:
            self.set_state('DoorOpen', f'current_floor ({self.current_floor}) == request_floor ({self.request_floor})')
        else:
            # Continue moving up if not at the target floor
            self.set_state('MovingUp', f'current_floor ({self.current_floor}) < request_floor ({self.request_floor})')

    def moving_down(self):
        self.log_state_entry('MovingDown')
        self.log_wait(self.constraints['MovingDown_decrement_time'], 'MovingDown_decrement_time')
        yield self.env.timeout(self.constraints['MovingDown_decrement_time'])
        self.current_floor -= 1
        print(f"[SIM][t={self.env.now:.2f}] INFO: Elevator moved to floor {self.current_floor}")

        if self.current_floor == self.request_floor:
            self.set_state('DoorOpen', f'current_floor ({self.current_floor}) == request_floor ({self.request_floor})')
        else:
            # Continue moving down if not at the target floor
            self.set_state('MovingDown', f'current_floor ({self.current_floor}) > request_floor ({self.request_floor})')

    def door_open(self):
        self.log_state_entry('DoorOpen')
        door_duration = self.constraints['DoorOpen_duration']
        self.log_wait(door_duration, 'DoorOpen_duration')
        yield self.env.timeout(door_duration)

        # Check for new requests while door is open
        if self.elevator_requests:
            next_request = self.elevator_requests[0]
            new_request_floor = next_request['floor']

            if new_request_floor > self.current_floor:
                self.set_state('MovingUp', f'request_floor ({new_request_floor}) > current_floor ({self.current_floor})')
                self.request_floor = new_request_floor # Update target floor
                self.elevator_requests.pop(0) # Consume request
            elif new_request_floor < self.current_floor:
                self.set_state('MovingDown', f'request_floor ({new_request_floor}) < current_floor ({self.current_floor})')
                self.request_floor = new_request_floor # Update target floor
                self.elevator_requests.pop(0) # Consume request
            else: # Request is for the current floor
                # Stay in DoorOpen or transition back to Idle if no other requests
                self.elevator_requests.pop(0) # Consume request for current floor
                if not self.elevator_requests:
                    self.set_state('Idle', 'no requests')
                else:
                    # If there are more requests, re-evaluate from DoorOpen state.
                    # For simplicity, we transition back to Idle to re-evaluate all requests.
                    # A more complex FSM could handle this within DoorOpen.
                    self.set_state('Idle', 'more requests')
        else:
            self.set_state('Idle', 'no requests')


    def run(self):
        while True:
            if self.current_state == 'Idle':
                yield from self.idle()
            elif self.current_state == 'MovingUp':
                yield from self.moving_up()
            elif self.current_state == 'MovingDown':
                yield from self.moving_down()
            elif self.current_state == 'DoorOpen':
                yield from self.door_open()
            else:
                # Should not happen in a well-defined state machine
                yield self.env.timeout(1)


def test_scenarios(env, state_machine):
    # Initial state
    state_machine.current_floor = 1 # Elevator starts at floor 1

    # Scenario 1: Request floor 3, then floor 5, then floor 2
    yield env.timeout(1)
    print("[SIM] SCENARIO: Adding requests...")
    state_machine.elevator_requests.append({'floor': 3})
    state_machine.elevator_requests.append({'floor': 5})
    state_machine.elevator_requests.append({'floor': 2})
    yield env.timeout(5)

    # Scenario 2: No more requests for a while
    print("[SIM] SCENARIO: No more requests for now...")
    yield env.timeout(20)

    # Scenario 3: Request floor 1
    print("[SIM] SCENARIO: Requesting floor 1...")
    state_machine.elevator_requests.append({'floor': 1})
    yield env.timeout(10)
    print("[SIM] SCENARIO: Simulation proceeding...")


def run_simulation():
    print("[SIM] Starting simulation")
    env = simpy.Environment()
    state_machine = StateMachine(env)
    env.process(state_machine.run())
    env.process(test_scenarios(env, state_machine)) # Use test_scenarios for input-driven
    env.run(until=60) # Run for a total of 60 seconds
    state_machine.log_end(state_machine.current_state)
    print("[SIM] END simulation")


if __name__ == "__main__":
    run_simulation()
```
    Code Generated.
    --- Generated Code ---
import simpy

class StateMachine:
    def __init__(self, env):
        self.env = env
        self.current_state = 'Idle'
        self.request_floor = 0
        self.current_floor = 0
        self.constraints = {
            'DoorOpen_duration': 5,
            'MovingUp_increment_time': 2,
            'MovingDown_decrement_time': 2
        }
        self.elevator_requests = [] # Simulate external requests

    def log_state_entry(self, state_name):
        print(f"[SIM][t={self.env.now:.2f}] ENTER state={state_name}")

    def log_wait(self, duration, event_name):
        print(f"[SIM][t={self.env.now:.2f}] WAIT {duration:.2f}s for {event_name}")

    def log_transition(self, from_state, to_state, condition):
        print(f"[SIM][t={self.env.now:.2f}] TRANSITION {from_state} -> {to_state} (reason={condition})")

    def log_end(self, final_state):
        print(f"[SIM][t={self.env.now:.2f}] END state={final_state}")

    def set_state(self, new_state, condition=""):
        if self.current_state != new_state:
            self.log_transition(self.current_state, new_state, condition)
            self.current_state = new_state
            self.log_state_entry(self.current_state)

    # State methods (generators)
    def idle(self):
        self.log_state_entry('Idle')
        if not self.elevator_requests:
            # Stay in Idle if no requests
            yield self.env.timeout(0.001) # Keep it a generator
            return

        next_request = self.elevator_requests[0] # Get the earliest request
        self.request_floor = next_request['floor']

        if self.request_floor > self.current_floor:
            self.set_state('MovingUp', f'request_floor ({self.request_floor}) > current_floor ({self.current_floor})')
        elif self.request_floor < self.current_floor:
            self.set_state('MovingDown', f'request_floor ({self.request_floor}) < current_floor ({self.current_floor})')
        else: # If already at the requested floor
            self.set_state('DoorOpen', f'current_floor ({self.current_floor}) == request_floor ({self.request_floor})')

        # Remove the processed request
        self.elevator_requests.pop(0)


    def moving_up(self):
        self.log_state_entry('MovingUp')
        self.log_wait(self.constraints['MovingUp_increment_time'], 'MovingUp_increment_time')
        yield self.env.timeout(self.constraints['MovingUp_increment_time'])
        self.current_floor += 1
        print(f"[SIM][t={self.env.now:.2f}] INFO: Elevator moved to floor {self.current_floor}")

        if self.current_floor == self.request_floor:
            self.set_state('DoorOpen', f'current_floor ({self.current_floor}) == request_floor ({self.request_floor})')
        else:
            # Continue moving up if not at the target floor
            self.set_state('MovingUp', f'current_floor ({self.current_floor}) < request_floor ({self.request_floor})')

    def moving_down(self):
        self.log_state_entry('MovingDown')
        self.log_wait(self.constraints['MovingDown_decrement_time'], 'MovingDown_decrement_time')
        yield self.env.timeout(self.constraints['MovingDown_decrement_time'])
        self.current_floor -= 1
        print(f"[SIM][t={self.env.now:.2f}] INFO: Elevator moved to floor {self.current_floor}")

        if self.current_floor == self.request_floor:
            self.set_state('DoorOpen', f'current_floor ({self.current_floor}) == request_floor ({self.request_floor})')
        else:
            # Continue moving down if not at the target floor
            self.set_state('MovingDown', f'current_floor ({self.current_floor}) > request_floor ({self.request_floor})')

    def door_open(self):
        self.log_state_entry('DoorOpen')
        door_duration = self.constraints['DoorOpen_duration']
        self.log_wait(door_duration, 'DoorOpen_duration')
        yield self.env.timeout(door_duration)

        # Check for new requests while door is open
        if self.elevator_requests:
            next_request = self.elevator_requests[0]
            new_request_floor = next_request['floor']

            if new_request_floor > self.current_floor:
                self.set_state('MovingUp', f'request_floor ({new_request_floor}) > current_floor ({self.current_floor})')
                self.request_floor = new_request_floor # Update target floor
                self.elevator_requests.pop(0) # Consume request
            elif new_request_floor < self.current_floor:
                self.set_state('MovingDown', f'request_floor ({new_request_floor}) < current_floor ({self.current_floor})')
                self.request_floor = new_request_floor # Update target floor
                self.elevator_requests.pop(0) # Consume request
            else: # Request is for the current floor
                # Stay in DoorOpen or transition back to Idle if no other requests
                self.elevator_requests.pop(0) # Consume request for current floor
                if not self.elevator_requests:
                    self.set_state('Idle', 'no requests')
                else:
                    # If there are more requests, re-evaluate from DoorOpen state.
                    # For simplicity, we transition back to Idle to re-evaluate all requests.
                    # A more complex FSM could handle this within DoorOpen.
                    self.set_state('Idle', 'more requests')
        else:
            self.set_state('Idle', 'no requests')


    def run(self):
        while True:
            if self.current_state == 'Idle':
                yield from self.idle()
            elif self.current_state == 'MovingUp':
                yield from self.moving_up()
            elif self.current_state == 'MovingDown':
                yield from self.moving_down()
            elif self.current_state == 'DoorOpen':
                yield from self.door_open()
            else:
                # Should not happen in a well-defined state machine
                yield self.env.timeout(1)


def test_scenarios(env, state_machine):
    # Initial state
    state_machine.current_floor = 1 # Elevator starts at floor 1

    # Scenario 1: Request floor 3, then floor 5, then floor 2
    yield env.timeout(1)
    print("[SIM] SCENARIO: Adding requests...")
    state_machine.elevator_requests.append({'floor': 3})
    state_machine.elevator_requests.append({'floor': 5})
    state_machine.elevator_requests.append({'floor': 2})
    yield env.timeout(5)

    # Scenario 2: No more requests for a while
    print("[SIM] SCENARIO: No more requests for now...")
    yield env.timeout(20)

    # Scenario 3: Request floor 1
    print("[SIM] SCENARIO: Requesting floor 1...")
    state_machine.elevator_requests.append({'floor': 1})
    yield env.timeout(10)
    print("[SIM] SCENARIO: Simulation proceeding...")


def run_simulation():
    print("[SIM] Starting simulation")
    env = simpy.Environment()
    state_machine = StateMachine(env)
    env.process(state_machine.run())
    env.process(test_scenarios(env, state_machine)) # Use test_scenarios for input-driven
    env.run(until=60) # Run for a total of 60 seconds
    state_machine.log_end(state_machine.current_state)
    print("[SIM] END simulation")


if __name__ == "__main__":
    run_simulation()
    ----------------------

[3] Verifier Agent: Executing & Verifying via MCP...

 ### Created new session: debug_session_id

User > 
        Specification:
        {
  "states": [
    {
      "name": "Idle"
    },
    {
      "name": "MovingUp"
    },
    {
      "name": "MovingDown"
    },
    {
      "name": "DoorOpen"
    }
  ],
  "transitions": [
    {
      "from": "Idle",
      "to": "MovingUp",
      "condition": "request_floor > current_floor"
    },
    {
      "from": "Idle",
      "to": "MovingDown",
      "condition": "request_floor < current_floor"
    },
    {
      "from": "MovingUp",
      "to": "DoorOpen",
      "condition": "current_floor == request_floor"
    },
    {
      "from": "MovingDown",
      "to": "DoorOpen",
      "condition": "current_floor == request_floor"
    },
    {
      "from": "DoorOpen",
      "to": "Idle",
      "condition": "no requests"
    },
    {
      "from": "DoorOpen",
      "to": "MovingUp",
      "condition": "request_floor > current_floor"
    },
    {
      "from": "DoorOpen",
      "to": "MovingDown",
      "condition": "request_floor < current_floor"
    }
  ],
  "constraints": [
    {
      "param": "DoorOpen_duration",
      "value": 5
    },
    {
      "param": "MovingUp_increment_time",
      "value": 2
    },
    {
      "param": "MovingDown_decrement_time",
      "value": 2
    }
  ]
}
        
        Simulation Code:
        ```python
        import simpy

class StateMachine:
    def __init__(self, env):
        self.env = env
        self.current_state = 'Idle'
        self.request_floor = 0
        self.current_floor = 0
        self.constraints = {
            'DoorOpen_duration': 5,
            'MovingUp_increment_time': 2,
            'MovingDown_decrement_time': 2
        }
        self.elevator_requests = [] # Simulate external requests

    def log_state_entry(self, state_name):
        print(f"[SIM][t={self.env.now:.2f}] ENTER state={state_name}")

    def log_wait(self, duration, event_name):
        print(f"[SIM][t={self.env.now:.2f}] WAIT {duration:.2f}s for {event_name}")

    def log_transition(self, from_state, to_state, condition):
        print(f"[SIM][t={self.env.now:.2f}] TRANSITION {from_state} -> {to_state} (reason={condition})")

    def log_end(self, final_state):
        print(f"[SIM][t={self.env.now:.2f}] END state={final_state}")

    def set_state(self, new_state, condition=""):
        if self.current_state != new_state:
            self.log_transition(self.current_state, new_state, condition)
            self.current_state = new_state
            self.log_state_entry(self.current_state)

    # State methods (generators)
    def idle(self):
        self.log_state_entry('Idle')
        if not self.elevator_requests:
            # Stay in Idle if no requests
            yield self.env.timeout(0.001) # Keep it a generator
            return

        next_request = self.elevator_requests[0] # Get the earliest request
        self.request_floor = next_request['floor']

        if self.request_floor > self.current_floor:
            self.set_state('MovingUp', f'request_floor ({self.request_floor}) > current_floor ({self.current_floor})')
        elif self.request_floor < self.current_floor:
            self.set_state('MovingDown', f'request_floor ({self.request_floor}) < current_floor ({self.current_floor})')
        else: # If already at the requested floor
            self.set_state('DoorOpen', f'current_floor ({self.current_floor}) == request_floor ({self.request_floor})')

        # Remove the processed request
        self.elevator_requests.pop(0)


    def moving_up(self):
        self.log_state_entry('MovingUp')
        self.log_wait(self.constraints['MovingUp_increment_time'], 'MovingUp_increment_time')
        yield self.env.timeout(self.constraints['MovingUp_increment_time'])
        self.current_floor += 1
        print(f"[SIM][t={self.env.now:.2f}] INFO: Elevator moved to floor {self.current_floor}")

        if self.current_floor == self.request_floor:
            self.set_state('DoorOpen', f'current_floor ({self.current_floor}) == request_floor ({self.request_floor})')
        else:
            # Continue moving up if not at the target floor
            self.set_state('MovingUp', f'current_floor ({self.current_floor}) < request_floor ({self.request_floor})')

    def moving_down(self):
        self.log_state_entry('MovingDown')
        self.log_wait(self.constraints['MovingDown_decrement_time'], 'MovingDown_decrement_time')
        yield self.env.timeout(self.constraints['MovingDown_decrement_time'])
        self.current_floor -= 1
        print(f"[SIM][t={self.env.now:.2f}] INFO: Elevator moved to floor {self.current_floor}")

        if self.current_floor == self.request_floor:
            self.set_state('DoorOpen', f'current_floor ({self.current_floor}) == request_floor ({self.request_floor})')
        else:
            # Continue moving down if not at the target floor
            self.set_state('MovingDown', f'current_floor ({self.current_floor}) > request_floor ({self.request_floor})')

    def door_open(self):
        self.log_state_entry('DoorOpen')
        door_duration = self.constraints['DoorOpen_duration']
        self.log_wait(door_duration, 'DoorOpen_duration')
        yield self.env.timeout(door_duration)

        # Check for new requests while door is open
        if self.elevator_requests:
            next_request = self.elevator_requests[0]
            new_request_floor = next_request['floor']

            if new_request_floor > self.current_floor:
                self.set_state('MovingUp', f'request_floor ({new_request_floor}) > current_floor ({self.current_floor})')
                self.request_floor = new_request_floor # Update target floor
                self.elevator_requests.pop(0) # Consume request
            elif new_request_floor < self.current_floor:
                self.set_state('MovingDown', f'request_floor ({new_request_floor}) < current_floor ({self.current_floor})')
                self.request_floor = new_request_floor # Update target floor
                self.elevator_requests.pop(0) # Consume request
            else: # Request is for the current floor
                # Stay in DoorOpen or transition back to Idle if no other requests
                self.elevator_requests.pop(0) # Consume request for current floor
                if not self.elevator_requests:
                    self.set_state('Idle', 'no requests')
                else:
                    # If there are more requests, re-evaluate from DoorOpen state.
                    # For simplicity, we transition back to Idle to re-evaluate all requests.
                    # A more complex FSM could handle this within DoorOpen.
                    self.set_state('Idle', 'more requests')
        else:
            self.set_state('Idle', 'no requests')


    def run(self):
        while True:
            if self.current_state == 'Idle':
                yield from self.idle()
            elif self.current_state == 'MovingUp':
                yield from self.moving_up()
            elif self.current_state == 'MovingDown':
                yield from self.moving_down()
            elif self.current_state == 'DoorOpen':
                yield from self.door_open()
            else:
                # Should not happen in a well-defined state machine
                yield self.env.timeout(1)


def test_scenarios(env, state_machine):
    # Initial state
    state_machine.current_floor = 1 # Elevator starts at floor 1

    # Scenario 1: Request floor 3, then floor 5, then floor 2
    yield env.timeout(1)
    print("[SIM] SCENARIO: Adding requests...")
    state_machine.elevator_requests.append({'floor': 3})
    state_machine.elevator_requests.append({'floor': 5})
    state_machine.elevator_requests.append({'floor': 2})
    yield env.timeout(5)

    # Scenario 2: No more requests for a while
    print("[SIM] SCENARIO: No more requests for now...")
    yield env.timeout(20)

    # Scenario 3: Request floor 1
    print("[SIM] SCENARIO: Requesting floor 1...")
    state_machine.elevator_requests.append({'floor': 1})
    yield env.timeout(10)
    print("[SIM] SCENARIO: Simulation proceeding...")


def run_simulation():
    print("[SIM] Starting simulation")
    env = simpy.Environment()
    state_machine = StateMachine(env)
    env.process(state_machine.run())
    env.process(test_scenarios(env, state_machine)) # Use test_scenarios for input-driven
    env.run(until=60) # Run for a total of 60 seconds
    state_machine.log_end(state_machine.current_state)
    print("[SIM] END simulation")


if __name__ == "__main__":
    run_simulation()
        ```
        
        Please execute this code and verify the results.
        
verifier_agent > I will execute the provided Python code using the `execute_simulation_code` tool to verify the simulation results against the specification. Then, I will analyze the logs to check for any errors, missing transitions, or constraint violations.

verifier_agent > The simulation executed successfully.

Here's a breakdown of the simulation's behavior:

*   **Initialization:** The elevator starts at floor 1 in the 'Idle' state.
*   **Scenario 1:**
    *   Requests are added for floors 3, 5, and 2.
    *   The elevator moves from floor 1 to floor 3 (taking 2 seconds per floor, arriving at floor 3 at t=5.00).
    *   The door opens for 5 seconds.
*   **Scenario 2:**
    *   The elevator moves from floor 3 to floor 5 (arriving at floor 5 at t=14.00, taking 2 seconds per floor).
    *   The door opens for 5 seconds.
    *   The elevator then moves from floor 5 to floor 2 (arriving at floor 2 at t=25.00, taking 2 seconds per floor).
    *   The door opens for 5 seconds.
*   **Scenario 3:**
    *   A request for floor 1 is added.
    *   The elevator moves from floor 2 to floor 1 (arriving at floor 1 at t=32.00, taking 2 seconds).
    *   The door opens for 5 seconds.
    *   After the door closes, the elevator returns to the 'Idle' state as there are no further requests.

The simulation logs indicate that all transitions and state durations specified in the `constraints` are followed. The elevator's movement and state changes appear to be consistent with the provided specification.

```json
{
    "status": "PASS",
    "reason": "The simulation executed successfully and the logged transitions and state changes align with the provided specification and constraints.",
    "retry": false
}
```
[DEBUG] Sessions dict keys: ['InMemoryRunner']
[DEBUG] Session value type for key 'InMemoryRunner': <class 'dict'>
[DEBUG] Nested keys: ['debug_user_id']
[DEBUG] Nested value type for key 'debug_user_id': <class 'dict'>
[DEBUG] Triple nested keys: ['debug_session_id']
[DEBUG] Found session from triple nested dict: debug_session_id
[DEBUG] Session events count: 4
[DEBUG] Session events count: 4
[DEBUG] Response length: 3
[DEBUG] Event 0 type: <class 'google.adk.events.event.Event'>
[DEBUG] Event content parts: 2
[DEBUG] Part type: <class 'google.genai.types.Part'>
[DEBUG] Part text (snippet): I will execute the provided Python code using the 
[DEBUG] Part function_response: Yes
[DEBUG] Part type: <class 'google.genai.types.Part'>
[DEBUG] Part text (snippet): None
[DEBUG] Part function_response: Yes
[DEBUG] Event 1 type: <class 'google.adk.events.event.Event'>
[DEBUG] Event content parts: 1
[DEBUG] Part type: <class 'google.genai.types.Part'>
[DEBUG] Part text (snippet): None
[DEBUG] Part function_response: Yes
[DEBUG] Event 2 type: <class 'google.adk.events.event.Event'>
[DEBUG] Event content parts: 2
[DEBUG] Part type: <class 'google.genai.types.Part'>
[DEBUG] Part text (snippet): The simulation executed successfully.

Here's a br
[DEBUG] Part function_response: Yes
[DEBUG] Part type: <class 'google.genai.types.Part'>
[DEBUG] Part text (snippet): ```json
{
    "status": "PASS",
    "reason": "The
[DEBUG] Part function_response: Yes
    Verification: {'status': 'PASS', 'reason': 'The simulation executed successfully and the logged transitions and state changes align with the provided specification and constraints.', 'retry': False, 'logs': '[SIM] Starting simulation\n[SIM][t=0.00] ENTER state=Idle\n[SIM][t=0.01] ENTER state=Idle\n[SIM][t=0.02] ENTER state=Idle\n[SIM][t=0.03] ENTER state=Idle\n[SIM][t=0.04] ENTER state=Idle\n[SIM][t=0.05] ENTER state=Idle\n[SIM][t=0.06] ENTER state=Idle\n[SIM][t=0.07] ENTER state=Idle\n[SIM][t=0.08] ENTER state=Idle\n[SIM][t=0.09] ENTER state=Idle\n[SIM][t=0.10] ENTER state=Idle\n[SIM][t=0.11] ENTER state=Idle\n[SIM][t=0.12] ENTER state=Idle\n[SIM][t=0.13] ENTER state=Idle\n[SIM][t=0.14] ENTER state=Idle\n[SIM][t=0.15] ENTER state=Idle\n[SIM][t=0.16] ENTER state=Idle\n[SIM][t=0.17] ENTER state=Idle\n[SIM][t=0.18] ENTER state=Idle\n[SIM][t=0.19] ENTER state=Idle\n[SIM][t=0.20] ENTER state=Idle\n[SIM][t=0.21] ENTER state=Idle\n[SIM][t=0.22] ENTER state=Idle\n[SIM][t=0.23] ENTER state=Idle\n[SIM][t=0.24] ENTER state=Idle\n[SIM][t=0.25] ENTER state=Idle\n[SIM][t=0.26] ENTER state=Idle\n[SIM][t=0.27] ENTER state=Idle\n[SIM][t=0.28] ENTER state=Idle\n[SIM][t=0.29] ENTER state=Idle\n[SIM][t=0.30] ENTER state=Idle\n[SIM][t=0.31] ENTER state=Idle\n[SIM][t=0.32] ENTER state=Idle\n[SIM][t=0.33] ENTER state=Idle\n[SIM][t=0.34] ENTER state=Idle\n[SIM][t=0.35] ENTER state=Idle\n[SIM][t=0.36] ENTER state=Idle\n[SIM][t=0.37] ENTER state=Idle\n[SIM][t=0.38] ENTER state=Idle\n[SIM][t=0.39] ENTER state=Idle\n[SIM][t=0.40] ENTER state=Idle\n[SIM][t=0.41] ENTER state=Idle\n[SIM][t=0.42] ENTER state=Idle\n[SIM][t=0.43] ENTER state=Idle\n[SIM][t=0.44] ENTER state=Idle\n[SIM][t=0.45] ENTER state=Idle\n[SIM][t=0.46] ENTER state=Idle\n[SIM][t=0.47] ENTER state=Idle\n[SIM][t=0.48] ENTER state=Idle\n[SIM][t=0.49] ENTER state=Idle\n[SIM][t=0.50] ENTER state=Idle\n[SIM][t=0.51] ENTER state=Idle\n[SIM][t=0.52] ENTER state=Idle\n[SIM][t=0.53] ENTER state=Idle\n[SIM][t=0.54] ENTER state=Idle\n[SIM][t=0.55] ENTER state=Idle\n[SIM][t=0.56] ENTER state=Idle\n[SIM][t=0.57] ENTER state=Idle\n[SIM][t=0.58] ENTER state=Idle\n[SIM][t=0.59] ENTER state=Idle\n[SIM][t=0.60] ENTER state=Idle\n[SIM][t=0.61] ENTER state=Idle\n[SIM][t=0.62] ENTER state=Idle\n[SIM][t=0.63] ENTER state=Idle\n[SIM][t=0.64] ENTER state=Idle\n[SIM][t=0.65] ENTER state=Idle\n[SIM][t=0.66] ENTER state=Idle\n[SIM][t=0.67] ENTER state=Idle\n[SIM][t=0.68] ENTER state=Idle\n[SIM][t=0.69] ENTER state=Idle\n[SIM][t=0.70] ENTER state=Idle\n[SIM][t=0.71] ENTER state=Idle\n[SIM][t=0.72] ENTER state=Idle\n[SIM][t=0.73] ENTER state=Idle\n[SIM][t=0.74] ENTER state=Idle\n[SIM][t=0.75] ENTER state=Idle\n[SIM][t=0.76] ENTER state=Idle\n[SIM][t=0.77] ENTER state=Idle\n[SIM][t=0.78] ENTER state=Idle\n[SIM][t=0.79] ENTER state=Idle\n[SIM][t=0.80] ENTER state=Idle\n[SIM][t=0.81] ENTER state=Idle\n[SIM][t=0.82] ENTER state=Idle\n[SIM][t=0.83] ENTER state=Idle\n[SIM][t=0.84] ENTER state=Idle\n[SIM][t=0.85] ENTER state=Idle\n[SIM][t=0.86] ENTER state=Idle\n[SIM][t=0.87] ENTER state=Idle\n[SIM][t=0.88] ENTER state=Idle\n[SIM][t=0.89] ENTER state=Idle\n[SIM][t=0.90] ENTER state=Idle\n[SIM][t=0.91] ENTER state=Idle\n[SIM][t=0.92] ENTER state=Idle\n[SIM][t=0.93] ENTER state=Idle\n[SIM][t=0.94] ENTER state=Idle\n[SIM][t=0.95] ENTER state=Idle\n[SIM][t=0.96] ENTER state=Idle\n[SIM][t=0.97] ENTER state=Idle\n[SIM][t=0.98] ENTER state=Idle\n[SIM][t=0.99] ENTER state=Idle\n[SIM][t=1.00] ENTER state=Idle\n[SIM] SCENARIO: Adding requests...\n[SIM][t=1.00] TRANSITION Idle -> MovingUp (reason=request_floor (3) > current_floor (1))\n[SIM][t=1.00] ENTER state=MovingUp\n[SIM][t=1.00] WAIT 2.00s for MovingUp_increment_time\n[SIM][t=3.00] INFO: Elevator moved to floor 2\n[SIM][t=3.00] ENTER state=MovingUp\n[SIM][t=3.00] WAIT 2.00s for MovingUp_increment_time\n[SIM][t=5.00] INFO: Elevator moved to floor 3\n[SIM][t=5.00] TRANSITION MovingUp -> DoorOpen (reason=current_floor (3) == request_floor (3))\n[SIM][t=5.00] ENTER state=DoorOpen\n[SIM][t=5.00] WAIT 5.00s for DoorOpen_duration\n[SIM] SCENARIO: No more requests for now...\n[SIM][t=10.00] TRANSITION DoorOpen -> MovingUp (reason=request_floor (5) > current_floor (3))\n[SIM][t=10.00] ENTER state=MovingUp\n[SIM][t=10.00] WAIT 2.00s for MovingUp_increment_time\n[SIM][t=12.00] INFO: Elevator moved to floor 4\n[SIM][t=12.00] ENTER state=MovingUp\n[SIM][t=12.00] WAIT 2.00s for MovingUp_increment_time\n[SIM][t=14.00] INFO: Elevator moved to floor 5\n[SIM][t=14.00] TRANSITION MovingUp -> DoorOpen (reason=current_floor (5) == request_floor (5))\n[SIM][t=14.00] ENTER state=DoorOpen\n[SIM][t=14.00] WAIT 5.00s for DoorOpen_duration\n[SIM][t=19.00] TRANSITION DoorOpen -> MovingDown (reason=request_floor (2) < current_floor (5))\n[SIM][t=19.00] ENTER state=MovingDown\n[SIM][t=19.00] WAIT 2.00s for MovingDown_decrement_time\n[SIM][t=21.00] INFO: Elevator moved to floor 4\n[SIM][t=21.00] ENTER state=MovingDown\n[SIM][t=21.00] WAIT 2.00s for MovingDown_decrement_time\n[SIM][t=23.00] INFO: Elevator moved to floor 3\n[SIM][t=23.00] ENTER state=MovingDown\n[SIM][t=23.00] WAIT 2.00s for MovingDown_decrement_time\n[SIM][t=25.00] INFO: Elevator moved to floor 2\n[SIM][t=25.00] TRANSITION MovingDown -> DoorOpen (reason=current_floor (2) == request_floor (2))\n[SIM][t=25.00] ENTER state=DoorOpen\n[SIM][t=25.00] WAIT 5.00s for DoorOpen_duration\n[SIM] SCENARIO: Requesting floor 1...\n[SIM][t=30.00] TRANSITION DoorOpen -> MovingDown (reason=request_floor (1) < current_floor (2))\n[SIM][t=30.00] ENTER state=MovingDown\n[SIM][t=30.00] WAIT 2.00s for MovingDown_decrement_time\n[SIM][t=32.00] INFO: Elevator moved to floor 1\n[SIM][t=32.00] TRANSITION MovingDown -> DoorOpen (reason=current_floor (1) == request_floor (1))\n[SIM][t=32.00] ENTER state=DoorOpen\n[SIM][t=32.00] WAIT 5.00s for DoorOpen_duration\n[SIM] SCENARIO: Simulation proceeding...\n[SIM][t=37.00] TRANSITION DoorOpen -> Idle (reason=no requests)\n[SIM][t=37.00] ENTER state=Idle\n[SIM][t=37.01] ENTER state=Idle\n[SIM][t=37.02] ENTER state=Idle\n[SIM][t=37.03] ENTER state=Idle\n[SIM][t=37.04] ENTER state=Idle\n[SIM][t=37.05] ENTER state=Idle\n[SIM][t=37.06] ENTER state=Idle\n[SIM][t=37.07] ENTER state=Idle\n[SIM][t=37.08] ENTER state=Idle\n[SIM][t=37.09] ENTER state=Idle\n[SIM][t=37.10] ENTER state=Idle\n[SIM][t=37.11] ENTER state=Idle\n[SIM][t=37.12] ENTER state=Idle\n[SIM][t=37.13] ENTER state=Idle\n[SIM][t=37.14] ENTER state=Idle\n[SIM][t=37.15] ENTER state=Idle\n[SIM][t=37.16] ENTER state=Idle\n[SIM][t=37.17] ENTER state=Idle\n[SIM][t=37.18] ENTER state=Idle\n[SIM][t=37.19] ENTER state=Idle\n[SIM][t=37.20] ENTER state=Idle\n[SIM][t=37.21] ENTER state=Idle\n[SIM][t=37.22] ENTER state=Idle\n[SIM][t=37.23] ENTER state=Idle\n[SIM][t=37.24] ENTER state=Idle\n[SIM][t=37.25] ENTER state=Idle\n[SIM][t=37.26] ENTER state=Idle\n[SIM][t=37.27] ENTER state=Idle\n[SIM][t=37.28] ENTER state=Idle\n[SIM][t=37.29] ENTER state=Idle\n[SIM][t=37.30] ENTER state=Idle\n[SIM][t=37.31] ENTER state=Idle\n[SIM][t=37.32] ENTER state=Idle\n[SIM][t=37.33] ENTER state=Idle\n[SIM][t=37.34] ENTER state=Idle\n[SIM][t=37.35] ENTER state=Idle\n[SIM][t=37.36] ENTER state=Idle\n[SIM][t=37.37] ENTER state=Idle\n[SIM][t=37.38] ENTER state=Idle\n[SIM][t=37.39] ENTER state=Idle\n[SIM][t=37.40] ENTER state=Idle\n[SIM][t=37.41] ENTER state=Idle\n[SIM][t=37.42] ENTER state=Idle\n[SIM][t=37.43] ENTER state=Idle\n[SIM][t=37.44] ENTER state=Idle\n[SIM][t=37.45] ENTER state=Idle\n[SIM][t=37.46] ENTER state=Idle\n[SIM][t=37.47] ENTER state=Idle\n[SIM][t=37.48] ENTER state=Idle\n[SIM][t=37.49] ENTER state=Idle\n[SIM][t=37.50] ENTER state=Idle\n[SIM][t=37.51] ENTER state=Idle\n[SIM][t=37.52] ENTER state=Idle\n[SIM][t=37.53] ENTER state=Idle\n[SIM][t=37.54] ENTER state=Idle\n[SIM][t=37.55] ENTER state=Idle\n[SIM][t=37.56] ENTER state=Idle\n[SIM][t=37.57] ENTER state=Idle\n[SIM][t=37.58] ENTER state=Idle\n[SIM][t=37.59] ENTER state=Idle\n[SIM][t=37.60] ENTER state=Idle\n[SIM][t=37.61] ENTER state=Idle\n[SIM][t=37.62] ENTER state=Idle\n[SIM][t=37.63] ENTER state=Idle\n[SIM][t=37.64] ENTER state=Idle\n[SIM][t=37.65] ENTER state=Idle\n[SIM][t=37.66] ENTER state=Idle\n[SIM][t=37.67] ENTER state=Idle\n[SIM][t=37.68] ENTER state=Idle\n[SIM][t=37.69] ENTER state=Idle\n[SIM][t=37.70] ENTER state=Idle\n[SIM][t=37.71] ENTER state=Idle\n[SIM][t=37.72] ENTER state=Idle\n[SIM][t=37.73] ENTER state=Idle\n[SIM][t=37.74] ENTER state=Idle\n[SIM][t=37.75] ENTER state=Idle\n[SIM][t=37.76] ENTER state=Idle\n[SIM][t=37.77] ENTER state=Idle\n[SIM][t=37.78] ENTER state=Idle\n[SIM][t=37.79] ENTER state=Idle\n[SIM][t=37.80] ENTER state=Idle\n[SIM][t=37.81] ENTER state=Idle\n[SIM][t=37.82] ENTER state=Idle\n[SIM][t=37.83] ENTER state=Idle\n[SIM][t=37.84] ENTER state=Idle\n[SIM][t=37.85] ENTER state=Idle\n[SIM][t=37.86] ENTER state=Idle\n[SIM][t=37.87] ENTER state=Idle\n[SIM][t=37.88] ENTER state=Idle\n[SIM][t=37.89] ENTER state=Idle\n[SIM][t=37.90] ENTER state=Idle\n[SIM][t=37.91] ENTER state=Idle\n[SIM][t=37.92] ENTER state=Idle\n[SIM][t=37.93] ENTER state=Idle\n[SIM][t=37.94] ENTER state=Idle\n[SIM][t=37.95] ENTER state=Idle\n[SIM][t=37.96] ENTER state=Idle\n[SIM][t=37.97] ENTER state=Idle\n[SIM][t=37.98] ENTER state=Idle\n[SIM][t=37.99] ENTER state=Idle\n[SIM][t=38.00] ENTER state=Idle\n[SIM][t=38.01] ENTER state=Idle\n[SIM][t=38.02] ENTER state=Idle\n[SIM][t=38.03] ENTER state=Idle\n[SIM][t=38.04] ENTER state=Idle\n[SIM][t=38.05] ENTER state=Idle\n[SIM][t=38.06] ENTER state=Idle\n[SIM][t=38.07] ENTER state=Idle\n[SIM][t=38.08] ENTER state=Idle\n[SIM][t=38.09] ENTER state=Idle\n[SIM][t=38.10] ENTER state=Idle\n[SIM][t=38.11] ENTER state=Idle\n[SIM][t=38.12] ENTER state=Idle\n[SIM][t=38.13] ENTER state=Idle\n[SIM][t=38.14] ENTER state=Idle\n[SIM][t=38.15] ENTER state=Idle\n[SIM][t=38.16] ENTER state=Idle\n[SIM][t=38.17] ENTER state=Idle\n[SIM][t=38.18] ENTER state=Idle\n[SIM][t=38.19] ENTER state=Idle\n[SIM][t=38.20] ENTER state=Idle\n[SIM][t=38.21] ENTER state=Idle\n[SIM][t=38.22] ENTER state=Idle\n[SIM][t=38.23] ENTER state=Idle\n[SIM][t=38.24] ENTER state=Idle\n[SIM][t=38.25] ENTER state=Idle\n[SIM][t=38.26] ENTER state=Idle\n[SIM][t=38.27] ENTER state=Idle\n[SIM][t=38.28] ENTER state=Idle\n[SIM][t=38.29] ENTER state=Idle\n[SIM][t=38.30] ENTER state=Idle\n[SIM][t=38.31] ENTER state=Idle\n[SIM][t=38.32] ENTER state=Idle\n[SIM][t=38.33] ENTER state=Idle\n[SIM][t=38.34] ENTER state=Idle\n[SIM][t=38.35] ENTER state=Idle\n[SIM][t=38.36] ENTER state=Idle\n[SIM][t=38.37] ENTER state=Idle\n[SIM][t=38.38] ENTER state=Idle\n[SIM][t=38.39] ENTER state=Idle\n[SIM][t=38.40] ENTER state=Idle\n[SIM][t=38.41] ENTER state=Idle\n[SIM][t=38.42] ENTER state=Idle\n[SIM][t=38.43] ENTER state=Idle\n[SIM][t=38.44] ENTER state=Idle\n[SIM][t=38.45] ENTER state=Idle\n[SIM][t=38.46] ENTER state=Idle\n[SIM][t=38.47] ENTER state=Idle\n[SIM][t=38.48] ENTER state=Idle\n[SIM][t=38.49] ENTER state=Idle\n[SIM][t=38.50] ENTER state=Idle\n[SIM][t=38.51] ENTER state=Idle\n[SIM][t=38.52] ENTER state=Idle\n[SIM][t=38.53] ENTER state=Idle\n[SIM][t=38.54] ENTER state=Idle\n[SIM][t=38.55] ENTER state=Idle\n[SIM][t=38.56] ENTER state=Idle\n[SIM][t=38.57] ENTER state=Idle\n[SIM][t=38.58] ENTER state=Idle\n[SIM][t=38.59] ENTER state=Idle\n[SIM][t=38.60] ENTER state=Idle\n[SIM][t=38.61] ENTER state=Idle\n[SIM][t=38.62] ENTER state=Idle\n[SIM][t=38.63] ENTER state=Idle\n[SIM][t=38.64] ENTER state=Idle\n[SIM][t=38.65] ENTER state=Idle\n[SIM][t=38.66] ENTER state=Idle\n[SIM][t=38.67] ENTER state=Idle\n[SIM][t=38.68] ENTER state=Idle\n[SIM][t=38.69] ENTER state=Idle\n[SIM][t=38.70] ENTER state=Idle\n[SIM][t=38.71] ENTER state=Idle\n[SIM][t=38.72] ENTER state=Idle\n[SIM][t=38.73] ENTER state=Idle\n[SIM][t=38.74] ENTER state=Idle\n[SIM][t=38.75] ENTER state=Idle\n[SIM][t=38.76] ENTER state=Idle\n[SIM][t=38.77] ENTER state=Idle\n[SIM][t=38.78] ENTER state=Idle\n[SIM][t=38.79] ENTER state=Idle\n[SIM][t=38.80] ENTER state=Idle\n[SIM][t=38.81] ENTER state=Idle\n[SIM][t=38.82] ENTER state=Idle\n[SIM][t=38.83] ENTER state=Idle\n[SIM][t=38.84] ENTER state=Idle\n[SIM][t=38.85] ENTER state=Idle\n[SIM][t=38.86] ENTER state=Idle\n[SIM][t=38.87] ENTER state=Idle\n[SIM][t=38.88] ENTER state=Idle\n[SIM][t=38.89] ENTER state=Idle\n[SIM][t=38.90] ENTER state=Idle\n[SIM][t=38.91] ENTER state=Idle\n[SIM][t=38.92] ENTER state=Idle\n[SIM][t=38.93] ENTER state=Idle\n[SIM][t=38.94] ENTER state=Idle\n[SIM][t=38.95] ENTER state=Idle\n[SIM][t=38.96] ENTER state=Idle\n[SIM][t=38.97] ENTER state=Idle\n[SIM][t=38.98] ENTER state=Idle\n[SIM][t=38.99] ENTER state=Idle\n[SIM][t=39.00] ENTER state=Idle\n[SIM][t=39.01] ENTER state=Idle\n[SIM][t=39.02] ENTER state=Idle\n[SIM][t=39.03] ENTER state=Idle\n[SIM][t=39.04] ENTER state=Idle\n[SIM][t=39.05] ENTER state=Idle\n[SIM][t=39.06] ENTER state=Idle\n[SIM][t=39.07] ENTER state=Idle\n[SIM][t=39.08] ENTER state=Idle\n[SIM][t=39.09] ENTER state=Idle\n[SIM][t=39.10] ENTER state=Idle\n[SIM][t=39.11] ENTER state=Idle\n[SIM][t=39.12] ENTER state=Idle\n[SIM][t=39.13] ENTER state=Idle\n[SIM][t=39.14] ENTER state=Idle\n[SIM][t=39.15] ENTER state=Idle\n[SIM][t=39.16] ENTER state=Idle\n[SIM][t=39.17] ENTER state=Idle\n[SIM][t=39.18] ENTER state=Idle\n[SIM][t=39.19] ENTER state=Idle\n[SIM][t=39.20] ENTER state=Idle\n[SIM][t=39.21] ENTER state=Idle\n[SIM][t=39.22] ENTER state=Idle\n[SIM][t=39.23] ENTER state=Idle\n[SIM][t=39.24] ENTER state=Idle\n[SIM][t=39.25] ENTER state=Idle\n[SIM][t=39.26] ENTER state=Idle\n[SIM][t=39.27] ENTER state=Idle\n[SIM][t=39.28] ENTER state=Idle\n[SIM][t=39.29] ENTER state=Idle\n[SIM][t=39.30] ENTER state=Idle\n[SIM][t=39.31] ENTER state=Idle\n[SIM][t=39.32] ENTER state=Idle\n[SIM][t=39.33] ENTER state=Idle\n[SIM][t=39.34] ENTER state=Idle\n[SIM][t=39.35] ENTER state=Idle\n[SIM][t=39.36] ENTER state=Idle\n[SIM][t=39.37] ENTER state=Idle\n[SIM][t=39.38] ENTER state=Idle\n[SIM][t=39.39] ENTER state=Idle\n[SIM][t=39.40] ENTER state=Idle\n[SIM][t=39.41] ENTER state=Idle\n[SIM][t=39.42] ENTER state=Idle\n[SIM][t=39.43] ENTER state=Idle\n[SIM][t=39.44] ENTER state=Idle\n[SIM][t=39.45] ENTER state=Idle\n[SIM][t=39.46] ENTER state=Idle\n[SIM][t=39.47] ENTER state=Idle\n[SIM][t=39.48] ENTER state=Idle\n[SIM][t=39.49] ENTER state=Idle\n[SIM][t=39.50] ENTER state=Idle\n[SIM][t=39.51] ENTER state=Idle\n[SIM][t=39.52] ENTER state=Idle\n[SIM][t=39.53] ENTER state=Idle\n[SIM][t=39.54] ENTER state=Idle\n[SIM][t=39.55] ENTER state=Idle\n[SIM][t=39.56] ENTER state=Idle\n[SIM][t=39.57] ENTER state=Idle\n[SIM][t=39.58] ENTER state=Idle\n[SIM][t=39.59] ENTER state=Idle\n[SIM][t=39.60] ENTER state=Idle\n[SIM][t=39.61] ENTER state=Idle\n[SIM][t=39.62] ENTER state=Idle\n[SIM][t=39.63] ENTER state=Idle\n[SIM][t=39.64] ENTER state=Idle\n[SIM][t=39.65] ENTER state=Idle\n[SIM][t=39.66] ENTER state=Idle\n[SIM][t=39.67] ENTER state=Idle\n[SIM][t=39.68] ENTER state=Idle\n[SIM][t=39.69] ENTER state=Idle\n[SIM][t=39.70] ENTER state=Idle\n[SIM][t=39.71] ENTER state=Idle\n[SIM][t=39.72] ENTER state=Idle\n[SIM][t=39.73] ENTER state=Idle\n[SIM][t=39.74] ENTER state=Idle\n[SIM][t=39.75] ENTER state=Idle\n[SIM][t=39.76] ENTER state=Idle\n[SIM][t=39.77] ENTER state=Idle\n[SIM][t=39.78] ENTER state=Idle\n[SIM][t=39.79] ENTER state=Idle\n[SIM][t=39.80] ENTER state=Idle\n[SIM][t=39.81] ENTER state=Idle\n[SIM][t=39.82] ENTER state=Idle\n[SIM][t=39.83] ENTER state=Idle\n[SIM][t=39.84] ENTER state=Idle\n[SIM][t=39.85] ENTER state=Idle\n[SIM][t=39.86] ENTER state=Idle\n[SIM][t=39.87] ENTER state=Idle\n[SIM][t=39.88] ENTER state=Idle\n[SIM][t=39.89] ENTER state=Idle\n[SIM][t=39.90] ENTER state=Idle\n[SIM][t=39.91] ENTER state=Idle\n[SIM][t=39.92] ENTER state=Idle\n[SIM][t=39.93] ENTER state=Idle\n[SIM][t=39.94] ENTER state=Idle\n[SIM][t=39.95] ENTER state=Idle\n[SIM][t=39.96] ENTER state=Idle\n[SIM][t=39.97] ENTER state=Idle\n[SIM][t=39.98] ENTER state=Idle\n[SIM][t=39.99] ENTER state=Idle\n[SIM][t=40.00] ENTER state=Idle\n[SIM][t=40.01] ENTER state=Idle\n[SIM][t=40.02] ENTER state=Idle\n[SIM][t=40.03] ENTER state=Idle\n[SIM][t=40.04] ENTER state=Idle\n[SIM][t=40.05] ENTER state=Idle\n[SIM][t=40.06] ENTER state=Idle\n[SIM][t=40.07] ENTER state=Idle\n[SIM][t=40.08] ENTER state=Idle\n[SIM][t=40.09] ENTER state=Idle\n[SIM][t=40.10] ENTER state=Idle\n[SIM][t=40.11] ENTER state=Idle\n[SIM][t=40.12] ENTER state=Idle\n[SIM][t=40.13] ENTER state=Idle\n[SIM][t=40.14] ENTER state=Idle\n[SIM][t=40.15] ENTER state=Idle\n[SIM][t=40.16] ENTER state=Idle\n[SIM][t=40.17] ENTER state=Idle\n[SIM][t=40.18] ENTER state=Idle\n[SIM][t=40.19] ENTER state=Idle\n[SIM][t=40.20] ENTER state=Idle\n[SIM][t=40.21] ENTER state=Idle\n[SIM][t=40.22] ENTER state=Idle\n[SIM][t=40.23] ENTER state=Idle\n[SIM][t=40.24] ENTER state=Idle\n[SIM][t=40.25] ENTER state=Idle\n[SIM][t=40.26] ENTER state=Idle\n[SIM][t=40.27] ENTER state=Idle\n[SIM][t=40.28] ENTER state=Idle\n[SIM][t=40.29] ENTER state=Idle\n[SIM][t=40.30] ENTER state=Idle\n[SIM][t=40.31] ENTER state=Idle\n[SIM][t=40.32] ENTER state=Idle\n[SIM][t=40.33] ENTER state=Idle\n[SIM][t=40.34] ENTER state=Idle\n[SIM][t=40.35] ENTER state=Idle\n[SIM][t=40.36] ENTER state=Idle\n[SIM][t=40.37] ENTER state=Idle\n[SIM][t=40.38] ENTER state=Idle\n[SIM][t=40.39] ENTER state=Idle\n[SIM][t=40.40] ENTER state=Idle\n[SIM][t=40.41] ENTER state=Idle\n[SIM][t=40.42] ENTER state=Idle\n[SIM][t=40.43] ENTER state=Idle\n[SIM][t=40.44] ENTER state=Idle\n[SIM][t=40.45] ENTER state=Idle\n[SIM][t=40.46] ENTER state=Idle\n[SIM][t=40.47] ENTER state=Idle\n[SIM][t=40.48] ENTER state=Idle\n[SIM][t=40.49] ENTER state=Idle\n[SIM][t=40.50] ENTER state=Idle\n[SIM][t=40.51] ENTER state=Idle\n[SIM][t=40.52] ENTER state=Idle\n[SIM][t=40.53] ENTER state=Idle\n[SIM][t=40.54] ENTER state=Idle\n[SIM][t=40.55] ENTER state=Idle\n[SIM][t=40.56] ENTER state=Idle\n[SIM][t=40.57] ENTER state=Idle\n[SIM][t=40.58] ENTER state=Idle\n[SIM][t=40.59] ENTER state=Idle\n[SIM][t=40.60] ENTER state=Idle\n[SIM][t=40.61] ENTER state=Idle\n[SIM][t=40.62] ENTER state=Idle\n[SIM][t=40.63] ENTER state=Idle\n[SIM][t=40.64] ENTER state=Idle\n[SIM][t=40.65] ENTER state=Idle\n[SIM][t=40.66] ENTER state=Idle\n[SIM][t=40.67] ENTER state=Idle\n[SIM][t=40.68] ENTER state=Idle\n[SIM][t=40.69] ENTER state=Idle\n[SIM][t=40.70] ENTER state=Idle\n[SIM][t=40.71] ENTER state=Idle\n[SIM][t=40.72] ENTER state=Idle\n[SIM][t=40.73] ENTER state=Idle\n[SIM][t=40.74] ENTER state=Idle\n[SIM][t=40.75] ENTER state=Idle\n[SIM][t=40.76] ENTER state=Idle\n[SIM][t=40.77] ENTER state=Idle\n[SIM][t=40.78] ENTER state=Idle\n[SIM][t=40.79] ENTER state=Idle\n[SIM][t=40.80] ENTER state=Idle\n[SIM][t=40.81] ENTER state=Idle\n[SIM][t=40.82] ENTER state=Idle\n[SIM][t=40.83] ENTER state=Idle\n[SIM][t=40.84] ENTER state=Idle\n[SIM][t=40.85] ENTER state=Idle\n[SIM][t=40.86] ENTER state=Idle\n[SIM][t=40.87] ENTER state=Idle\n[SIM][t=40.88] ENTER state=Idle\n[SIM][t=40.89] ENTER state=Idle\n[SIM][t=40.90] ENTER state=Idle\n[SIM][t=40.91] ENTER state=Idle\n[SIM][t=40.92] ENTER state=Idle\n[SIM][t=40.93] ENTER state=Idle\n[SIM][t=40.94] ENTER state=Idle\n[SIM][t=40.95] ENTER state=Idle\n[SIM][t=40.96] ENTER state=Idle\n[SIM][t=40.97] ENTER state=Idle\n[SIM][t=40.98] ENTER state=Idle\n[SIM][t=40.99] ENTER state=Idle\n[SIM][t=41.00] ENTER state=Idle\n[SIM][t=41.01] ENTER state=Idle\n[SIM][t=41.02] ENTER state=Idle\n[SIM][t=41.03] ENTER state=Idle\n[SIM][t=41.04] ENTER state=Idle\n[SIM][t=41.05] ENTER state=Idle\n[SIM][t=41.06] ENTER state=Idle\n[SIM][t=41.07] ENTER state=Idle\n[SIM][t=41.08] ENTER state=Idle\n[SIM][t=41.09] ENTER state=Idle\n[SIM][t=41.10] ENTER state=Idle\n[SIM][t=41.11] ENTER state=Idle\n[SIM][t=41.12] ENTER state=Idle\n[SIM][t=41.13] ENTER state=Idle\n[SIM][t=41.14] ENTER state=Idle\n[SIM][t=41.15] ENTER state=Idle\n[SIM][t=41.16] ENTER state=Idle\n[SIM][t=41.17] ENTER state=Idle\n[SIM][t=41.18] ENTER state=Idle\n[SIM][t=41.19] ENTER state=Idle\n[SIM][t=41.20] ENTER state=Idle\n[SIM][t=41.21] ENTER state=Idle\n[SIM][t=41.22] ENTER state=Idle\n[SIM][t=41.23] ENTER state=Idle\n[SIM][t=41.24] ENTER state=Idle\n[SIM][t=41.25] ENTER state=Idle\n[SIM][t=41.26] ENTER state=Idle\n[SIM][t=41.27] ENTER state=Idle\n[SIM][t=41.28] ENTER state=Idle\n[SIM][t=41.29] ENTER state=Idle\n[SIM][t=41.30] ENTER state=Idle\n[SIM][t=41.31] ENTER state=Idle\n[SIM][t=41.32] ENTER state=Idle\n[SIM][t=41.33] ENTER state=Idle\n[SIM][t=41.34] ENTER state=Idle\n[SIM][t=41.35] ENTER state=Idle\n[SIM][t=41.36] ENTER state=Idle\n[SIM][t=41.37] ENTER state=Idle\n[SIM][t=41.38] ENTER state=Idle\n[SIM][t=41.39] ENTER state=Idle\n[SIM][t=41.40] ENTER state=Idle\n[SIM][t=41.41] ENTER state=Idle\n[SIM][t=41.42] ENTER state=Idle\n[SIM][t=41.43] ENTER state=Idle\n[SIM][t=41.44] ENTER state=Idle\n[SIM][t=41.45] ENTER state=Idle\n[SIM][t=41.46] ENTER state=Idle\n[SIM][t=41.47] ENTER state=Idle\n[SIM][t=41.48] ENTER state=Idle\n[SIM][t=41.49] ENTER state=Idle\n[SIM][t=41.50] ENTER state=Idle\n[SIM][t=41.51] ENTER state=Idle\n[SIM][t=41.52] ENTER state=Idle\n[SIM][t=41.53] ENTER state=Idle\n[SIM][t=41.54] ENTER state=Idle\n[SIM][t=41.55] ENTER state=Idle\n[SIM][t=41.56] ENTER state=Idle\n[SIM][t=41.57] ENTER state=Idle\n[SIM][t=41.58] ENTER state=Idle\n[SIM][t=41.59] ENTER state=Idle\n[SIM][t=41.60] ENTER state=Idle\n[SIM][t=41.61] ENTER state=Idle\n[SIM][t=41.62] ENTER state=Idle\n[SIM][t=41.63] ENTER state=Idle\n[SIM][t=41.64] ENTER state=Idle\n[SIM][t=41.65] ENTER state=Idle\n[SIM][t=41.66] ENTER state=Idle\n[SIM][t=41.67] ENTER state=Idle\n[SIM][t=41.68] ENTER state=Idle\n[SIM][t=41.69] ENTER state=Idle\n[SIM][t=41.70] ENTER state=Idle\n[SIM][t=41.71] ENTER state=Idle\n[SIM][t=41.72] ENTER state=Idle\n[SIM][t=41.73] ENTER state=Idle\n[SIM][t=41.74] ENTER state=Idle\n[SIM][t=41.75] ENTER state=Idle\n[SIM][t=41.76] ENTER state=Idle\n[SIM][t=41.77] ENTER state=Idle\n[SIM][t=41.78] ENTER state=Idle\n[SIM][t=41.79] ENTER state=Idle\n[SIM][t=41.80] ENTER state=Idle\n[SIM][t=41.81] ENTER state=Idle\n[SIM][t=41.82] ENTER state=Idle\n[SIM][t=41.83] ENTER state=Idle\n[SIM][t=41.84] ENTER state=Idle\n[SIM][t=41.85] ENTER state=Idle\n[SIM][t=41.86] ENTER state=Idle\n[SIM][t=41.87] ENTER state=Idle\n[SIM][t=41.88] ENTER state=Idle\n[SIM][t=41.89] ENTER state=Idle\n[SIM][t=41.90] ENTER state=Idle\n[SIM][t=41.91] ENTER state=Idle\n[SIM][t=41.92] ENTER state=Idle\n[SIM][t=41.93] ENTER state=Idle\n[SIM][t=41.94] ENTER state=Idle\n[SIM][t=41.95] ENTER state=Idle\n[SIM][t=41.96] ENTER state=Idle\n[SIM][t=41.97] ENTER state=Idle\n[SIM][t=41.98] ENTER state=Idle\n[SIM][t=41.99] ENTER state=Idle\n[SIM][t=42.00] ENTER state=Idle\n[SIM][t=42.01] ENTER state=Idle\n[SIM][t=42.02] ENTER state=Idle\n[SIM][t=42.03] ENTER state=Idle\n[SIM][t=42.04] ENTER state=Idle\n[SIM][t=42.05] ENTER state=Idle\n[SIM][t=42.06] ENTER state=Idle\n[SIM][t=42.07] ENTER state=Idle\n[SIM][t=42.08] ENTER state=Idle\n[SIM][t=42.09] ENTER state=Idle\n[SIM][t=42.10] ENTER state=Idle\n[SIM][t=42.11] ENTER state=Idle\n[SIM][t=42.12] ENTER state=Idle\n[SIM][t=42.13] ENTER state=Idle\n[SIM][t=42.14] ENTER state=Idle\n[SIM][t=42.15] ENTER state=Idle\n[SIM][t=42.16] ENTER state=Idle\n[SIM][t=42.17] ENTER state=Idle\n[SIM][t=42.18] ENTER state=Idle\n[SIM][t=42.19] ENTER state=Idle\n[SIM][t=42.20] ENTER state=Idle\n[SIM][t=42.21] ENTER state=Idle\n[SIM][t=42.22] ENTER state=Idle\n[SIM][t=42.23] ENTER state=Idle\n[SIM][t=42.24] ENTER state=Idle\n[SIM][t=42.25] ENTER state=Idle\n[SIM][t=42.26] ENTER state=Idle\n[SIM][t=42.27] ENTER state=Idle\n[SIM][t=42.28] ENTER state=Idle\n[SIM][t=42.29] ENTER state=Idle\n[SIM][t=42.30] ENTER state=Idle\n[SIM][t=42.31] ENTER state=Idle\n[SIM][t=42.32] ENTER state=Idle\n[SIM][t=42.33] ENTER state=Idle\n[SIM][t=42.34] ENTER state=Idle\n[SIM][t=42.35] ENTER state=Idle\n[SIM][t=42.36] ENTER state=Idle\n[SIM][t=42.37] ENTER state=Idle\n[SIM][t=42.38] ENTER state=Idle\n[SIM][t=42.39] ENTER state=Idle\n[SIM][t=42.40] ENTER state=Idle\n[SIM][t=42.41] ENTER state=Idle\n[SIM][t=42.42] ENTER state=Idle\n[SIM][t=42.43] ENTER state=Idle\n[SIM][t=42.44] ENTER state=Idle\n[SIM][t=42.45] ENTER state=Idle\n[SIM][t=42.46] ENTER state=Idle\n[SIM][t=42.47] ENTER state=Idle\n[SIM][t=42.48] ENTER state=Idle\n[SIM][t=42.49] ENTER state=Idle\n[SIM][t=42.50] ENTER state=Idle\n[SIM][t=42.51] ENTER state=Idle\n[SIM][t=42.52] ENTER state=Idle\n[SIM][t=42.53] ENTER state=Idle\n[SIM][t=42.54] ENTER state=Idle\n[SIM][t=42.55] ENTER state=Idle\n[SIM][t=42.56] ENTER state=Idle\n[SIM][t=42.57] ENTER state=Idle\n[SIM][t=42.58] ENTER state=Idle\n[SIM][t=42.59] ENTER state=Idle\n[SIM][t=42.60] ENTER state=Idle\n[SIM][t=42.61] ENTER state=Idle\n[SIM][t=42.62] ENTER state=Idle\n[SIM][t=42.63] ENTER state=Idle\n[SIM][t=42.64] ENTER state=Idle\n[SIM][t=42.65] ENTER state=Idle\n[SIM][t=42.66] ENTER state=Idle\n[SIM][t=42.67] ENTER state=Idle\n[SIM][t=42.68] ENTER state=Idle\n[SIM][t=42.69] ENTER state=Idle\n[SIM][t=42.70] ENTER state=Idle\n[SIM][t=42.71] ENTER state=Idle\n[SIM][t=42.72] ENTER state=Idle\n[SIM][t=42.73] ENTER state=Idle\n[SIM][t=42.74] ENTER state=Idle\n[SIM][t=42.75] ENTER state=Idle\n[SIM][t=42.76] ENTER state=Idle\n[SIM][t=42.77] ENTER state=Idle\n[SIM][t=42.78] ENTER state=Idle\n[SIM][t=42.79] ENTER state=Idle\n[SIM][t=42.80] ENTER state=Idle\n[SIM][t=42.81] ENTER state=Idle\n[SIM][t=42.82] ENTER state=Idle\n[SIM][t=42.83] ENTER state=Idle\n[SIM][t=42.84] ENTER state=Idle\n[SIM][t=42.85] ENTER state=Idle\n[SIM][t=42.86] ENTER state=Idle\n[SIM][t=42.87] ENTER state=Idle\n[SIM][t=42.88] ENTER state=Idle\n[SIM][t=42.89] ENTER state=Idle\n[SIM][t=42.90] ENTER state=Idle\n[SIM][t=42.91] ENTER state=Idle\n[SIM][t=42.92] ENTER state=Idle\n[SIM][t=42.93] ENTER state=Idle\n[SIM][t=42.94] ENTER state=Idle\n[SIM][t=42.95] ENTER state=Idle\n[SIM][t=42.96] ENTER state=Idle\n[SIM][t=42.97] ENTER state=Idle\n[SIM][t=42.98] ENTER state=Idle\n[SIM][t=42.99] ENTER state=Idle\n[SIM][t=43.00] ENTER state=Idle\n[SIM][t=43.01] ENTER state=Idle\n[SIM][t=43.02] ENTER state=Idle\n[SIM][t=43.03] ENTER state=Idle\n[SIM][t=43.04] ENTER state=Idle\n[SIM][t=43.05] ENTER state=Idle\n[SIM][t=43.06] ENTER state=Idle\n[SIM][t=43.07] ENTER state=Idle\n[SIM][t=43.08] ENTER state=Idle\n[SIM][t=43.09] ENTER state=Idle\n[SIM][t=43.10] ENTER state=Idle\n[SIM][t=43.11] ENTER state=Idle\n[SIM][t=43.12] ENTER state=Idle\n[SIM][t=43.13] ENTER state=Idle\n[SIM][t=43.14] ENTER state=Idle\n[SIM][t=43.15] ENTER state=Idle\n[SIM][t=43.16] ENTER state=Idle\n[SIM][t=43.17] ENTER state=Idle\n[SIM][t=43.18] ENTER state=Idle\n[SIM][t=43.19] ENTER state=Idle\n[SIM][t=43.20] ENTER state=Idle\n[SIM][t=43.21] ENTER state=Idle\n[SIM][t=43.22] ENTER state=Idle\n[SIM][t=43.23] ENTER state=Idle\n[SIM][t=43.24] ENTER state=Idle\n[SIM][t=43.25] ENTER state=Idle\n[SIM][t=43.26] ENTER state=Idle\n[SIM][t=43.27] ENTER state=Idle\n[SIM][t=43.28] ENTER state=Idle\n[SIM][t=43.29] ENTER state=Idle\n[SIM][t=43.30] ENTER state=Idle\n[SIM][t=43.31] ENTER state=Idle\n[SIM][t=43.32] ENTER state=Idle\n[SIM][t=43.33] ENTER state=Idle\n[SIM][t=43.34] ENTER state=Idle\n[SIM][t=43.35] ENTER state=Idle\n[SIM][t=43.36] ENTER state=Idle\n[SIM][t=43.37] ENTER state=Idle\n[SIM][t=43.38] ENTER state=Idle\n[SIM][t=43.39] ENTER state=Idle\n[SIM][t=43.40] ENTER state=Idle\n[SIM][t=43.41] ENTER state=Idle\n[SIM][t=43.42] ENTER state=Idle\n[SIM][t=43.43] ENTER state=Idle\n[SIM][t=43.44] ENTER state=Idle\n[SIM][t=43.45] ENTER state=Idle\n[SIM][t=43.46] ENTER state=Idle\n[SIM][t=43.47] ENTER state=Idle\n[SIM][t=43.48] ENTER state=Idle\n[SIM][t=43.49] ENTER state=Idle\n[SIM][t=43.50] ENTER state=Idle\n[SIM][t=43.51] ENTER state=Idle\n[SIM][t=43.52] ENTER state=Idle\n[SIM][t=43.53] ENTER state=Idle\n[SIM][t=43.54] ENTER state=Idle\n[SIM][t=43.55] ENTER state=Idle\n[SIM][t=43.56] ENTER state=Idle\n[SIM][t=43.57] ENTER state=Idle\n[SIM][t=43.58] ENTER state=Idle\n[SIM][t=43.59] ENTER state=Idle\n[SIM][t=43.60] ENTER state=Idle\n[SIM][t=43.61] ENTER state=Idle\n[SIM][t=43.62] ENTER state=Idle\n[SIM][t=43.63] ENTER state=Idle\n[SIM][t=43.64] ENTER state=Idle\n[SIM][t=43.65] ENTER state=Idle\n[SIM][t=43.66] ENTER state=Idle\n[SIM][t=43.67] ENTER state=Idle\n[SIM][t=43.68] ENTER state=Idle\n[SIM][t=43.69] ENTER state=Idle\n[SIM][t=43.70] ENTER state=Idle\n[SIM][t=43.71] ENTER state=Idle\n[SIM][t=43.72] ENTER state=Idle\n[SIM][t=43.73] ENTER state=Idle\n[SIM][t=43.74] ENTER state=Idle\n[SIM][t=43.75] ENTER state=Idle\n[SIM][t=43.76] ENTER state=Idle\n[SIM][t=43.77] ENTER state=Idle\n[SIM][t=43.78] ENTER state=Idle\n[SIM][t=43.79] ENTER state=Idle\n[SIM][t=43.80] ENTER state=Idle\n[SIM][t=43.81] ENTER state=Idle\n[SIM][t=43.82] ENTER state=Idle\n[SIM][t=43.83] ENTER state=Idle\n[SIM][t=43.84] ENTER state=Idle\n[SIM][t=43.85] ENTER state=Idle\n[SIM][t=43.86] ENTER state=Idle\n[SIM][t=43.87] ENTER state=Idle\n[SIM][t=43.88] ENTER state=Idle\n[SIM][t=43.89] ENTER state=Idle\n[SIM][t=43.90] ENTER state=Idle\n[SIM][t=43.91] ENTER state=Idle\n[SIM][t=43.92] ENTER state=Idle\n[SIM][t=43.93] ENTER state=Idle\n[SIM][t=43.94] ENTER state=Idle\n[SIM][t=43.95] ENTER state=Idle\n[SIM][t=43.96] ENTER state=Idle\n[SIM][t=43.97] ENTER state=Idle\n[SIM][t=43.98] ENTER state=Idle\n[SIM][t=43.99] ENTER state=Idle\n[SIM][t=44.00] ENTER state=Idle\n[SIM][t=44.01] ENTER state=Idle\n[SIM][t=44.02] ENTER state=Idle\n[SIM][t=44.03] ENTER state=Idle\n[SIM][t=44.04] ENTER state=Idle\n[SIM][t=44.05] ENTER state=Idle\n[SIM][t=44.06] ENTER state=Idle\n[SIM][t=44.07] ENTER state=Idle\n[SIM][t=44.08] ENTER state=Idle\n[SIM][t=44.09] ENTER state=Idle\n[SIM][t=44.10] ENTER state=Idle\n[SIM][t=44.11] ENTER state=Idle\n[SIM][t=44.12] ENTER state=Idle\n[SIM][t=44.13] ENTER state=Idle\n[SIM][t=44.14] ENTER state=Idle\n[SIM][t=44.15] ENTER state=Idle\n[SIM][t=44.16] ENTER state=Idle\n[SIM][t=44.17] ENTER state=Idle\n[SIM][t=44.18] ENTER state=Idle\n[SIM][t=44.19] ENTER state=Idle\n[SIM][t=44.20] ENTER state=Idle\n[SIM][t=44.21] ENTER state=Idle\n[SIM][t=44.22] ENTER state=Idle\n[SIM][t=44.23] ENTER state=Idle\n[SIM][t=44.24] ENTER state=Idle\n[SIM][t=44.25] ENTER state=Idle\n[SIM][t=44.26] ENTER state=Idle\n[SIM][t=44.27] ENTER state=Idle\n[SIM][t=44.28] ENTER state=Idle\n[SIM][t=44.29] ENTER state=Idle\n[SIM][t=44.30] ENTER state=Idle\n[SIM][t=44.31] ENTER state=Idle\n[SIM][t=44.32] ENTER state=Idle\n[SIM][t=44.33] ENTER state=Idle\n[SIM][t=44.34] ENTER state=Idle\n[SIM][t=44.35] ENTER state=Idle\n[SIM][t=44.36] ENTER state=Idle\n[SIM][t=44.37] ENTER state=Idle\n[SIM][t=44.38] ENTER state=Idle\n[SIM][t=44.39] ENTER state=Idle\n[SIM][t=44.40] ENTER state=Idle\n[SIM][t=44.41] ENTER state=Idle\n[SIM][t=44.42] ENTER state=Idle\n[SIM][t=44.43] ENTER state=Idle\n[SIM][t=44.44] ENTER state=Idle\n[SIM][t=44.45] ENTER state=Idle\n[SIM][t=44.46] ENTER state=Idle\n[SIM][t=44.47] ENTER state=Idle\n[SIM][t=44.48] ENTER state=Idle\n[SIM][t=44.49] ENTER state=Idle\n[SIM][t=44.50] ENTER state=Idle\n[SIM][t=44.51] ENTER state=Idle\n[SIM][t=44.52] ENTER state=Idle\n[SIM][t=44.53] ENTER state=Idle\n[SIM][t=44.54] ENTER state=Idle\n[SIM][t=44.55] ENTER state=Idle\n[SIM][t=44.56] ENTER state=Idle\n[SIM][t=44.57] ENTER state=Idle\n[SIM][t=44.58] ENTER state=Idle\n[SIM][t=44.59] ENTER state=Idle\n[SIM][t=44.60] ENTER state=Idle\n[SIM][t=44.61] ENTER state=Idle\n[SIM][t=44.62] ENTER state=Idle\n[SIM][t=44.63] ENTER state=Idle\n[SIM][t=44.64] ENTER state=Idle\n[SIM][t=44.65] ENTER state=Idle\n[SIM][t=44.66] ENTER state=Idle\n[SIM][t=44.67] ENTER state=Idle\n[SIM][t=44.68] ENTER state=Idle\n[SIM][t=44.69] ENTER state=Idle\n[SIM][t=44.70] ENTER state=Idle\n[SIM][t=44.71] ENTER state=Idle\n[SIM][t=44.72] ENTER state=Idle\n[SIM][t=44.73] ENTER state=Idle\n[SIM][t=44.74] ENTER state=Idle\n[SIM][t=44.75] ENTER state=Idle\n[SIM][t=44.76] ENTER state=Idle\n[SIM][t=44.77] ENTER state=Idle\n[SIM][t=44.78] ENTER state=Idle\n[SIM][t=44.79] ENTER state=Idle\n[SIM][t=44.80] ENTER state=Idle\n[SIM][t=44.81] ENTER state=Idle\n[SIM][t=44.82] ENTER state=Idle\n[SIM][t=44.83] ENTER state=Idle\n[SIM][t=44.84] ENTER state=Idle\n[SIM][t=44.85] ENTER state=Idle\n[SIM][t=44.86] ENTER state=Idle\n[SIM][t=44.87] ENTER state=Idle\n[SIM][t=44.88] ENTER state=Idle\n[SIM][t=44.89] ENTER state=Idle\n[SIM][t=44.90] ENTER state=Idle\n[SIM][t=44.91] ENTER state=Idle\n[SIM][t=44.92] ENTER state=Idle\n[SIM][t=44.93] ENTER state=Idle\n[SIM][t=44.94] ENTER state=Idle\n[SIM][t=44.95] ENTER state=Idle\n[SIM][t=44.96] ENTER state=Idle\n[SIM][t=44.97] ENTER state=Idle\n[SIM][t=44.98] ENTER state=Idle\n[SIM][t=44.99] ENTER state=Idle\n[SIM][t=45.00] ENTER state=Idle\n[SIM][t=45.01] ENTER state=Idle\n[SIM][t=45.02] ENTER state=Idle\n[SIM][t=45.03] ENTER state=Idle\n[SIM][t=45.04] ENTER state=Idle\n[SIM][t=45.05] ENTER state=Idle\n[SIM][t=45.06] ENTER state=Idle\n[SIM][t=45.07] ENTER state=Idle\n[SIM][t=45.08] ENTER state=Idle\n[SIM][t=45.09] ENTER state=Idle\n[SIM][t=45.10] ENTER state=Idle\n[SIM][t=45.11] ENTER state=Idle\n[SIM][t=45.12] ENTER state=Idle\n[SIM][t=45.13] ENTER state=Idle\n[SIM][t=45.14] ENTER state=Idle\n[SIM][t=45.15] ENTER state=Idle\n[SIM][t=45.16] ENTER state=Idle\n[SIM][t=45.17] ENTER state=Idle\n[SIM][t=45.18] ENTER state=Idle\n[SIM][t=45.19] ENTER state=Idle\n[SIM][t=45.20] ENTER state=Idle\n[SIM][t=45.21] ENTER state=Idle\n[SIM][t=45.22] ENTER state=Idle\n[SIM][t=45.23] ENTER state=Idle\n[SIM][t=45.24] ENTER state=Idle\n[SIM][t=45.25] ENTER state=Idle\n[SIM][t=45.26] ENTER state=Idle\n[SIM][t=45.27] ENTER state=Idle\n[SIM][t=45.28] ENTER state=Idle\n[SIM][t=45.29] ENTER state=Idle\n[SIM][t=45.30] ENTER state=Idle\n[SIM][t=45.31] ENTER state=Idle\n[SIM][t=45.32] ENTER state=Idle\n[SIM][t=45.33] ENTER state=Idle\n[SIM][t=45.34] ENTER state=Idle\n[SIM][t=45.35] ENTER state=Idle\n[SIM][t=45.36] ENTER state=Idle\n[SIM][t=45.37] ENTER state=Idle\n[SIM][t=45.38] ENTER state=Idle\n[SIM][t=45.39] ENTER state=Idle\n[SIM][t=45.40] ENTER state=Idle\n[SIM][t=45.41] ENTER state=Idle\n[SIM][t=45.42] ENTER state=Idle\n[SIM][t=45.43] ENTER state=Idle\n[SIM][t=45.44] ENTER state=Idle\n[SIM][t=45.45] ENTER state=Idle\n[SIM][t=45.46] ENTER state=Idle\n[SIM][t=45.47] ENTER state=Idle\n[SIM][t=45.48] ENTER state=Idle\n[SIM][t=45.49] ENTER state=Idle\n[SIM][t=45.50] ENTER state=Idle\n[SIM][t=45.51] ENTER state=Idle\n[SIM][t=45.52] ENTER state=Idle\n[SIM][t=45.53] ENTER state=Idle\n[SIM][t=45.54] ENTER state=Idle\n[SIM][t=45.55] ENTER state=Idle\n[SIM][t=45.56] ENTER state=Idle\n[SIM][t=45.57] ENTER state=Idle\n[SIM][t=45.58] ENTER state=Idle\n[SIM][t=45.59] ENTER state=Idle\n[SIM][t=45.60] ENTER state=Idle\n[SIM][t=45.61] ENTER state=Idle\n[SIM][t=45.62] ENTER state=Idle\n[SIM][t=45.63] ENTER state=Idle\n[SIM][t=45.64] ENTER state=Idle\n[SIM][t=45.65] ENTER state=Idle\n[SIM][t=45.66] ENTER state=Idle\n[SIM][t=45.67] ENTER state=Idle\n[SIM][t=45.68] ENTER state=Idle\n[SIM][t=45.69] ENTER state=Idle\n[SIM][t=45.70] ENTER state=Idle\n[SIM][t=45.71] ENTER state=Idle\n[SIM][t=45.72] ENTER state=Idle\n[SIM][t=45.73] ENTER state=Idle\n[SIM][t=45.74] ENTER state=Idle\n[SIM][t=45.75] ENTER state=Idle\n[SIM][t=45.76] ENTER state=Idle\n[SIM][t=45.77] ENTER state=Idle\n[SIM][t=45.78] ENTER state=Idle\n[SIM][t=45.79] ENTER state=Idle\n[SIM][t=45.80] ENTER state=Idle\n[SIM][t=45.81] ENTER state=Idle\n[SIM][t=45.82] ENTER state=Idle\n[SIM][t=45.83] ENTER state=Idle\n[SIM][t=45.84] ENTER state=Idle\n[SIM][t=45.85] ENTER state=Idle\n[SIM][t=45.86] ENTER state=Idle\n[SIM][t=45.87] ENTER state=Idle\n[SIM][t=45.88] ENTER state=Idle\n[SIM][t=45.89] ENTER state=Idle\n[SIM][t=45.90] ENTER state=Idle\n[SIM][t=45.91] ENTER state=Idle\n[SIM][t=45.92] ENTER state=Idle\n[SIM][t=45.93] ENTER state=Idle\n[SIM][t=45.94] ENTER state=Idle\n[SIM][t=45.95] ENTER state=Idle\n[SIM][t=45.96] ENTER state=Idle\n[SIM][t=45.97] ENTER state=Idle\n[SIM][t=45.98] ENTER state=Idle\n[SIM][t=45.99] ENTER state=Idle\n[SIM][t=46.00] ENTER state=Idle\n[SIM][t=46.01] ENTER state=Idle\n[SIM][t=46.02] ENTER state=Idle\n[SIM][t=46.03] ENTER state=Idle\n[SIM][t=46.04] ENTER state=Idle\n[SIM][t=46.05] ENTER state=Idle\n[SIM][t=46.06] ENTER state=Idle\n[SIM][t=46.07] ENTER state=Idle\n[SIM][t=46.08] ENTER state=Idle\n[SIM][t=46.09] ENTER state=Idle\n[SIM][t=46.10] ENTER state=Idle\n[SIM][t=46.11] ENTER state=Idle\n[SIM][t=46.12] ENTER state=Idle\n[SIM][t=46.13] ENTER state=Idle\n[SIM][t=46.14] ENTER state=Idle\n[SIM][t=46.15] ENTER state=Idle\n[SIM][t=46.16] ENTER state=Idle\n[SIM][t=46.17] ENTER state=Idle\n[SIM][t=46.18] ENTER state=Idle\n[SIM][t=46.19] ENTER state=Idle\n[SIM][t=46.20] ENTER state=Idle\n[SIM][t=46.21] ENTER state=Idle\n[SIM][t=46.22] ENTER state=Idle\n[SIM][t=46.23] ENTER state=Idle\n[SIM][t=46.24] ENTER state=Idle\n[SIM][t=46.25] ENTER state=Idle\n[SIM][t=46.26] ENTER state=Idle\n[SIM][t=46.27] ENTER state=Idle\n[SIM][t=46.28] ENTER state=Idle\n[SIM][t=46.29] ENTER state=Idle\n[SIM][t=46.30] ENTER state=Idle\n[SIM][t=46.31] ENTER state=Idle\n[SIM][t=46.32] ENTER state=Idle\n[SIM][t=46.33] ENTER state=Idle\n[SIM][t=46.34] ENTER state=Idle\n[SIM][t=46.35] ENTER state=Idle\n[SIM][t=46.36] ENTER state=Idle\n[SIM][t=46.37] ENTER state=Idle\n[SIM][t=46.38] ENTER state=Idle\n[SIM][t=46.39] ENTER state=Idle\n[SIM][t=46.40] ENTER state=Idle\n[SIM][t=46.41] ENTER state=Idle\n[SIM][t=46.42] ENTER state=Idle\n[SIM][t=46.43] ENTER state=Idle\n[SIM][t=46.44] ENTER state=Idle\n[SIM][t=46.45] ENTER state=Idle\n[SIM][t=46.46] ENTER state=Idle\n[SIM][t=46.47] ENTER state=Idle\n[SIM][t=46.48] ENTER state=Idle\n[SIM][t=46.49] ENTER state=Idle\n[SIM][t=46.50] ENTER state=Idle\n[SIM][t=46.51] ENTER state=Idle\n[SIM][t=46.52] ENTER state=Idle\n[SIM][t=46.53] ENTER state=Idle\n[SIM][t=46.54] ENTER state=Idle\n[SIM][t=46.55] ENTER state=Idle\n[SIM][t=46.56] ENTER state=Idle\n[SIM][t=46.57] ENTER state=Idle\n[SIM][t=46.58] ENTER state=Idle\n[SIM][t=46.59] ENTER state=Idle\n[SIM][t=46.60] ENTER state=Idle\n[SIM][t=46.61] ENTER state=Idle\n[SIM][t=46.62] ENTER state=Idle\n[SIM][t=46.63] ENTER state=Idle\n[SIM][t=46.64] ENTER state=Idle\n[SIM][t=46.65] ENTER state=Idle\n[SIM][t=46.66] ENTER state=Idle\n[SIM][t=46.67] ENTER state=Idle\n[SIM][t=46.68] ENTER state=Idle\n[SIM][t=46.69] ENTER state=Idle\n[SIM][t=46.70] ENTER state=Idle\n[SIM][t=46.71] ENTER state=Idle\n[SIM][t=46.72] ENTER state=Idle\n[SIM][t=46.73] ENTER state=Idle\n[SIM][t=46.74] ENTER state=Idle\n[SIM][t=46.75] ENTER state=Idle\n[SIM][t=46.76] ENTER state=Idle\n[SIM][t=46.77] ENTER state=Idle\n[SIM][t=46.78] ENTER state=Idle\n[SIM][t=46.79] ENTER state=Idle\n[SIM][t=46.80] ENTER state=Idle\n[SIM][t=46.81] ENTER state=Idle\n[SIM][t=46.82] ENTER state=Idle\n[SIM][t=46.83] ENTER state=Idle\n[SIM][t=46.84] ENTER state=Idle\n[SIM][t=46.85] ENTER state=Idle\n[SIM][t=46.86] ENTER state=Idle\n[SIM][t=46.87] ENTER state=Idle\n[SIM][t=46.88] ENTER state=Idle\n[SIM][t=46.89] ENTER state=Idle\n[SIM][t=46.90] ENTER state=Idle\n[SIM][t=46.91] ENTER state=Idle\n[SIM][t=46.92] ENTER state=Idle\n[SIM][t=46.93] ENTER state=Idle\n[SIM][t=46.94] ENTER state=Idle\n[SIM][t=46.95] ENTER state=Idle\n[SIM][t=46.96] ENTER state=Idle\n[SIM][t=46.97] ENTER state=Idle\n[SIM][t=46.98] ENTER state=Idle\n[SIM][t=46.99] ENTER state=Idle\n[SIM][t=47.00] ENTER state=Idle\n[SIM][t=47.01] ENTER state=Idle\n[SIM][t=47.02] ENTER state=Idle\n[SIM][t=47.03] ENTER state=Idle\n[SIM][t=47.04] ENTER state=Idle\n[SIM][t=47.05] ENTER state=Idle\n[SIM][t=47.06] ENTER state=Idle\n[SIM][t=47.07] ENTER state=Idle\n[SIM][t=47.08] ENTER state=Idle\n[SIM][t=47.09] ENTER state=Idle\n[SIM][t=47.10] ENTER state=Idle\n[SIM][t=47.11] ENTER state=Idle\n[SIM][t=47.12] ENTER state=Idle\n[SIM][t=47.13] ENTER state=Idle\n[SIM][t=47.14] ENTER state=Idle\n[SIM][t=47.15] ENTER state=Idle\n[SIM][t=47.16] ENTER state=Idle\n[SIM][t=47.17] ENTER state=Idle\n[SIM][t=47.18] ENTER state=Idle\n[SIM][t=47.19] ENTER state=Idle\n[SIM][t=47.20] ENTER state=Idle\n[SIM][t=47.21] ENTER state=Idle\n[SIM][t=47.22] ENTER state=Idle\n[SIM][t=47.23] ENTER state=Idle\n[SIM][t=47.24] ENTER state=Idle\n[SIM][t=47.25] ENTER state=Idle\n[SIM][t=47.26] ENTER state=Idle\n[SIM][t=47.27] ENTER state=Idle\n[SIM][t=47.28] ENTER state=Idle\n[SIM][t=47.29] ENTER state=Idle\n[SIM][t=47.30] ENTER state=Idle\n[SIM][t=47.31] ENTER state=Idle\n[SIM][t=47.32] ENTER state=Idle\n[SIM][t=47.33] ENTER state=Idle\n[SIM][t=47.34] ENTER state=Idle\n[SIM][t=47.35] ENTER state=Idle\n[SIM][t=47.36] ENTER state=Idle\n[SIM][t=47.37] ENTER state=Idle\n[SIM][t=47.38] ENTER state=Idle\n[SIM][t=47.39] ENTER state=Idle\n[SIM][t=47.40] ENTER state=Idle\n[SIM][t=47.41] ENTER state=Idle\n[SIM][t=47.42] ENTER state=Idle\n[SIM][t=47.43] ENTER state=Idle\n[SIM][t=47.44] ENTER state=Idle\n[SIM][t=47.45] ENTER state=Idle\n[SIM][t=47.46] ENTER state=Idle\n[SIM][t=47.47] ENTER state=Idle\n[SIM][t=47.48] ENTER state=Idle\n[SIM][t=47.49] ENTER state=Idle\n[SIM][t=47.50] ENTER state=Idle\n[SIM][t=47.51] ENTER state=Idle\n[SIM][t=47.52] ENTER state=Idle\n[SIM][t=47.53] ENTER state=Idle\n[SIM][t=47.54] ENTER state=Idle\n[SIM][t=47.55] ENTER state=Idle\n[SIM][t=47.56] ENTER state=Idle\n[SIM][t=47.57] ENTER state=Idle\n[SIM][t=47.58] ENTER state=Idle\n[SIM][t=47.59] ENTER state=Idle\n[SIM][t=47.60] ENTER state=Idle\n[SIM][t=47.61] ENTER state=Idle\n[SIM][t=47.62] ENTER state=Idle\n[SIM][t=47.63] ENTER state=Idle\n[SIM][t=47.64] ENTER state=Idle\n[SIM][t=47.65] ENTER state=Idle\n[SIM][t=47.66] ENTER state=Idle\n[SIM][t=47.67] ENTER state=Idle\n[SIM][t=47.68] ENTER state=Idle\n[SIM][t=47.69] ENTER state=Idle\n[SIM][t=47.70] ENTER state=Idle\n[SIM][t=47.71] ENTER state=Idle\n[SIM][t=47.72] ENTER state=Idle\n[SIM][t=47.73] ENTER state=Idle\n[SIM][t=47.74] ENTER state=Idle\n[SIM][t=47.75] ENTER state=Idle\n[SIM][t=47.76] ENTER state=Idle\n[SIM][t=47.77] ENTER state=Idle\n[SIM][t=47.78] ENTER state=Idle\n[SIM][t=47.79] ENTER state=Idle\n[SIM][t=47.80] ENTER state=Idle\n[SIM][t=47.81] ENTER state=Idle\n[SIM][t=47.82] ENTER state=Idle\n[SIM][t=47.83] ENTER state=Idle\n[SIM][t=47.84] ENTER state=Idle\n[SIM][t=47.85] ENTER state=Idle\n[SIM][t=47.86] ENTER state=Idle\n[SIM][t=47.87] ENTER state=Idle\n[SIM][t=47.88] ENTER state=Idle\n[SIM][t=47.89] ENTER state=Idle\n[SIM][t=47.90] ENTER state=Idle\n[SIM][t=47.91] ENTER state=Idle\n[SIM][t=47.92] ENTER state=Idle\n[SIM][t=47.93] ENTER state=Idle\n[SIM][t=47.94] ENTER state=Idle\n[SIM][t=47.95] ENTER state=Idle\n[SIM][t=47.96] ENTER state=Idle\n[SIM][t=47.97] ENTER state=Idle\n[SIM][t=47.98] ENTER state=Idle\n[SIM][t=47.99] ENTER state=Idle\n[SIM][t=48.00] ENTER state=Idle\n[SIM][t=48.01] ENTER state=Idle\n[SIM][t=48.02] ENTER state=Idle\n[SIM][t=48.03] ENTER state=Idle\n[SIM][t=48.04] ENTER state=Idle\n[SIM][t=48.05] ENTER state=Idle\n[SIM][t=48.06] ENTER state=Idle\n[SIM][t=48.07] ENTER state=Idle\n[SIM][t=48.08] ENTER state=Idle\n[SIM][t=48.09] ENTER state=Idle\n[SIM][t=48.10] ENTER state=Idle\n[SIM][t=48.11] ENTER state=Idle\n[SIM][t=48.12] ENTER state=Idle\n[SIM][t=48.13] ENTER state=Idle\n[SIM][t=48.14] ENTER state=Idle\n[SIM][t=48.15] ENTER state=Idle\n[SIM][t=48.16] ENTER state=Idle\n[SIM][t=48.17] ENTER state=Idle\n[SIM][t=48.18] ENTER state=Idle\n[SIM][t=48.19] ENTER state=Idle\n[SIM][t=48.20] ENTER state=Idle\n[SIM][t=48.21] ENTER state=Idle\n[SIM][t=48.22] ENTER state=Idle\n[SIM][t=48.23] ENTER state=Idle\n[SIM][t=48.24] ENTER state=Idle\n[SIM][t=48.25] ENTER state=Idle\n[SIM][t=48.26] ENTER state=Idle\n[SIM][t=48.27] ENTER state=Idle\n[SIM][t=48.28] ENTER state=Idle\n[SIM][t=48.29] ENTER state=Idle\n[SIM][t=48.30] ENTER state=Idle\n[SIM][t=48.31] ENTER state=Idle\n[SIM][t=48.32] ENTER state=Idle\n[SIM][t=48.33] ENTER state=Idle\n[SIM][t=48.34] ENTER state=Idle\n[SIM][t=48.35] ENTER state=Idle\n[SIM][t=48.36] ENTER state=Idle\n[SIM][t=48.37] ENTER state=Idle\n[SIM][t=48.38] ENTER state=Idle\n[SIM][t=48.39] ENTER state=Idle\n[SIM][t=48.40] ENTER state=Idle\n[SIM][t=48.41] ENTER state=Idle\n[SIM][t=48.42] ENTER state=Idle\n[SIM][t=48.43] ENTER state=Idle\n[SIM][t=48.44] ENTER state=Idle\n[SIM][t=48.45] ENTER state=Idle\n[SIM][t=48.46] ENTER state=Idle\n[SIM][t=48.47] ENTER state=Idle\n[SIM][t=48.48] ENTER state=Idle\n[SIM][t=48.49] ENTER state=Idle\n[SIM][t=48.50] ENTER state=Idle\n[SIM][t=48.51] ENTER state=Idle\n[SIM][t=48.52] ENTER state=Idle\n[SIM][t=48.53] ENTER state=Idle\n[SIM][t=48.54] ENTER state=Idle\n[SIM][t=48.55] ENTER state=Idle\n[SIM][t=48.56] ENTER state=Idle\n[SIM][t=48.57] ENTER state=Idle\n[SIM][t=48.58] ENTER state=Idle\n[SIM][t=48.59] ENTER state=Idle\n[SIM][t=48.60] ENTER state=Idle\n[SIM][t=48.61] ENTER state=Idle\n[SIM][t=48.62] ENTER state=Idle\n[SIM][t=48.63] ENTER state=Idle\n[SIM][t=48.64] ENTER state=Idle\n[SIM][t=48.65] ENTER state=Idle\n[SIM][t=48.66] ENTER state=Idle\n[SIM][t=48.67] ENTER state=Idle\n[SIM][t=48.68] ENTER state=Idle\n[SIM][t=48.69] ENTER state=Idle\n[SIM][t=48.70] ENTER state=Idle\n[SIM][t=48.71] ENTER state=Idle\n[SIM][t=48.72] ENTER state=Idle\n[SIM][t=48.73] ENTER state=Idle\n[SIM][t=48.74] ENTER state=Idle\n[SIM][t=48.75] ENTER state=Idle\n[SIM][t=48.76] ENTER state=Idle\n[SIM][t=48.77] ENTER state=Idle\n[SIM][t=48.78] ENTER state=Idle\n[SIM][t=48.79] ENTER state=Idle\n[SIM][t=48.80] ENTER state=Idle\n[SIM][t=48.81] ENTER state=Idle\n[SIM][t=48.82] ENTER state=Idle\n[SIM][t=48.83] ENTER state=Idle\n[SIM][t=48.84] ENTER state=Idle\n[SIM][t=48.85] ENTER state=Idle\n[SIM][t=48.86] ENTER state=Idle\n[SIM][t=48.87] ENTER state=Idle\n[SIM][t=48.88] ENTER state=Idle\n[SIM][t=48.89] ENTER state=Idle\n[SIM][t=48.90] ENTER state=Idle\n[SIM][t=48.91] ENTER state=Idle\n[SIM][t=48.92] ENTER state=Idle\n[SIM][t=48.93] ENTER state=Idle\n[SIM][t=48.94] ENTER state=Idle\n[SIM][t=48.95] ENTER state=Idle\n[SIM][t=48.96] ENTER state=Idle\n[SIM][t=48.97] ENTER state=Idle\n[SIM][t=48.98] ENTER state=Idle\n[SIM][t=48.99] ENTER state=Idle\n[SIM][t=49.00] ENTER state=Idle\n[SIM][t=49.01] ENTER state=Idle\n[SIM][t=49.02] ENTER state=Idle\n[SIM][t=49.03] ENTER state=Idle\n[SIM][t=49.04] ENTER state=Idle\n[SIM][t=49.05] ENTER state=Idle\n[SIM][t=49.06] ENTER state=Idle\n[SIM][t=49.07] ENTER state=Idle\n[SIM][t=49.08] ENTER state=Idle\n[SIM][t=49.09] ENTER state=Idle\n[SIM][t=49.10] ENTER state=Idle\n[SIM][t=49.11] ENTER state=Idle\n[SIM][t=49.12] ENTER state=Idle\n[SIM][t=49.13] ENTER state=Idle\n[SIM][t=49.14] ENTER state=Idle\n[SIM][t=49.15] ENTER state=Idle\n[SIM][t=49.16] ENTER state=Idle\n[SIM][t=49.17] ENTER state=Idle\n[SIM][t=49.18] ENTER state=Idle\n[SIM][t=49.19] ENTER state=Idle\n[SIM][t=49.20] ENTER state=Idle\n[SIM][t=49.21] ENTER state=Idle\n[SIM][t=49.22] ENTER state=Idle\n[SIM][t=49.23] ENTER state=Idle\n[SIM][t=49.24] ENTER state=Idle\n[SIM][t=49.25] ENTER state=Idle\n[SIM][t=49.26] ENTER state=Idle\n[SIM][t=49.27] ENTER state=Idle\n[SIM][t=49.28] ENTER state=Idle\n[SIM][t=49.29] ENTER state=Idle\n[SIM][t=49.30] ENTER state=Idle\n[SIM][t=49.31] ENTER state=Idle\n[SIM][t=49.32] ENTER state=Idle\n[SIM][t=49.33] ENTER state=Idle\n[SIM][t=49.34] ENTER state=Idle\n[SIM][t=49.35] ENTER state=Idle\n[SIM][t=49.36] ENTER state=Idle\n[SIM][t=49.37] ENTER state=Idle\n[SIM][t=49.38] ENTER state=Idle\n[SIM][t=49.39] ENTER state=Idle\n[SIM][t=49.40] ENTER state=Idle\n[SIM][t=49.41] ENTER state=Idle\n[SIM][t=49.42] ENTER state=Idle\n[SIM][t=49.43] ENTER state=Idle\n[SIM][t=49.44] ENTER state=Idle\n[SIM][t=49.45] ENTER state=Idle\n[SIM][t=49.46] ENTER state=Idle\n[SIM][t=49.47] ENTER state=Idle\n[SIM][t=49.48] ENTER state=Idle\n[SIM][t=49.49] ENTER state=Idle\n[SIM][t=49.50] ENTER state=Idle\n[SIM][t=49.51] ENTER state=Idle\n[SIM][t=49.52] ENTER state=Idle\n[SIM][t=49.53] ENTER state=Idle\n[SIM][t=49.54] ENTER state=Idle\n[SIM][t=49.55] ENTER state=Idle\n[SIM][t=49.56] ENTER state=Idle\n[SIM][t=49.57] ENTER state=Idle\n[SIM][t=49.58] ENTER state=Idle\n[SIM][t=49.59] ENTER state=Idle\n[SIM][t=49.60] ENTER state=Idle\n[SIM][t=49.61] ENTER state=Idle\n[SIM][t=49.62] ENTER state=Idle\n[SIM][t=49.63] ENTER state=Idle\n[SIM][t=49.64] ENTER state=Idle\n[SIM][t=49.65] ENTER state=Idle\n[SIM][t=49.66] ENTER state=Idle\n[SIM][t=49.67] ENTER state=Idle\n[SIM][t=49.68] ENTER state=Idle\n[SIM][t=49.69] ENTER state=Idle\n[SIM][t=49.70] ENTER state=Idle\n[SIM][t=49.71] ENTER state=Idle\n[SIM][t=49.72] ENTER state=Idle\n[SIM][t=49.73] ENTER state=Idle\n[SIM][t=49.74] ENTER state=Idle\n[SIM][t=49.75] ENTER state=Idle\n[SIM][t=49.76] ENTER state=Idle\n[SIM][t=49.77] ENTER state=Idle\n[SIM][t=49.78] ENTER state=Idle\n[SIM][t=49.79] ENTER state=Idle\n[SIM][t=49.80] ENTER state=Idle\n[SIM][t=49.81] ENTER state=Idle\n[SIM][t=49.82] ENTER state=Idle\n[SIM][t=49.83] ENTER state=Idle\n[SIM][t=49.84] ENTER state=Idle\n[SIM][t=49.85] ENTER state=Idle\n[SIM][t=49.86] ENTER state=Idle\n[SIM][t=49.87] ENTER state=Idle\n[SIM][t=49.88] ENTER state=Idle\n[SIM][t=49.89] ENTER state=Idle\n[SIM][t=49.90] ENTER state=Idle\n[SIM][t=49.91] ENTER state=Idle\n[SIM][t=49.92] ENTER state=Idle\n[SIM][t=49.93] ENTER state=Idle\n[SIM][t=49.94] ENTER state=Idle\n[SIM][t=49.95] ENTER state=Idle\n[SIM][t=49.96] ENTER state=Idle\n[SIM][t=49.97] ENTER state=Idle\n[SIM][t=49.98] ENTER state=Idle\n[SIM][t=49.99] ENTER state=Idle\n[SIM][t=50.00] ENTER state=Idle\n[SIM][t=50.01] ENTER state=Idle\n[SIM][t=50.02] ENTER state=Idle\n[SIM][t=50.03] ENTER state=Idle\n[SIM][t=50.04] ENTER state=Idle\n[SIM][t=50.05] ENTER state=Idle\n[SIM][t=50.06] ENTER state=Idle\n[SIM][t=50.07] ENTER state=Idle\n[SIM][t=50.08] ENTER state=Idle\n[SIM][t=50.09] ENTER state=Idle\n[SIM][t=50.10] ENTER state=Idle\n[SIM][t=50.11] ENTER state=Idle\n[SIM][t=50.12] ENTER state=Idle\n[SIM][t=50.13] ENTER state=Idle\n[SIM][t=50.14] ENTER state=Idle\n[SIM][t=50.15] ENTER state=Idle\n[SIM][t=50.16] ENTER state=Idle\n[SIM][t=50.17] ENTER state=Idle\n[SIM][t=50.18] ENTER state=Idle\n[SIM][t=50.19] ENTER state=Idle\n[SIM][t=50.20] ENTER state=Idle\n[SIM][t=50.21] ENTER state=Idle\n[SIM][t=50.22] ENTER state=Idle\n[SIM][t=50.23] ENTER state=Idle\n[SIM][t=50.24] ENTER state=Idle\n[SIM][t=50.25] ENTER state=Idle\n[SIM][t=50.26] ENTER state=Idle\n[SIM][t=50.27] ENTER state=Idle\n[SIM][t=50.28] ENTER state=Idle\n[SIM][t=50.29] ENTER state=Idle\n[SIM][t=50.30] ENTER state=Idle\n[SIM][t=50.31] ENTER state=Idle\n[SIM][t=50.32] ENTER state=Idle\n[SIM][t=50.33] ENTER state=Idle\n[SIM][t=50.34] ENTER state=Idle\n[SIM][t=50.35] ENTER state=Idle\n[SIM][t=50.36] ENTER state=Idle\n[SIM][t=50.37] ENTER state=Idle\n[SIM][t=50.38] ENTER state=Idle\n[SIM][t=50.39] ENTER state=Idle\n[SIM][t=50.40] ENTER state=Idle\n[SIM][t=50.41] ENTER state=Idle\n[SIM][t=50.42] ENTER state=Idle\n[SIM][t=50.43] ENTER state=Idle\n[SIM][t=50.44] ENTER state=Idle\n[SIM][t=50.45] ENTER state=Idle\n[SIM][t=50.46] ENTER state=Idle\n[SIM][t=50.47] ENTER state=Idle\n[SIM][t=50.48] ENTER state=Idle\n[SIM][t=50.49] ENTER state=Idle\n[SIM][t=50.50] ENTER state=Idle\n[SIM][t=50.51] ENTER state=Idle\n[SIM][t=50.52] ENTER state=Idle\n[SIM][t=50.53] ENTER state=Idle\n[SIM][t=50.54] ENTER state=Idle\n[SIM][t=50.55] ENTER state=Idle\n[SIM][t=50.56] ENTER state=Idle\n[SIM][t=50.57] ENTER state=Idle\n[SIM][t=50.58] ENTER state=Idle\n[SIM][t=50.59] ENTER state=Idle\n[SIM][t=50.60] ENTER state=Idle\n[SIM][t=50.61] ENTER state=Idle\n[SIM][t=50.62] ENTER state=Idle\n[SIM][t=50.63] ENTER state=Idle\n[SIM][t=50.64] ENTER state=Idle\n[SIM][t=50.65] ENTER state=Idle\n[SIM][t=50.66] ENTER state=Idle\n[SIM][t=50.67] ENTER state=Idle\n[SIM][t=50.68] ENTER state=Idle\n[SIM][t=50.69] ENTER state=Idle\n[SIM][t=50.70] ENTER state=Idle\n[SIM][t=50.71] ENTER state=Idle\n[SIM][t=50.72] ENTER state=Idle\n[SIM][t=50.73] ENTER state=Idle\n[SIM][t=50.74] ENTER state=Idle\n[SIM][t=50.75] ENTER state=Idle\n[SIM][t=50.76] ENTER state=Idle\n[SIM][t=50.77] ENTER state=Idle\n[SIM][t=50.78] ENTER state=Idle\n[SIM][t=50.79] ENTER state=Idle\n[SIM][t=50.80] ENTER state=Idle\n[SIM][t=50.81] ENTER state=Idle\n[SIM][t=50.82] ENTER state=Idle\n[SIM][t=50.83] ENTER state=Idle\n[SIM][t=50.84] ENTER state=Idle\n[SIM][t=50.85] ENTER state=Idle\n[SIM][t=50.86] ENTER state=Idle\n[SIM][t=50.87] ENTER state=Idle\n[SIM][t=50.88] ENTER state=Idle\n[SIM][t=50.89] ENTER state=Idle\n[SIM][t=50.90] ENTER state=Idle\n[SIM][t=50.91] ENTER state=Idle\n[SIM][t=50.92] ENTER state=Idle\n[SIM][t=50.93] ENTER state=Idle\n[SIM][t=50.94] ENTER state=Idle\n[SIM][t=50.95] ENTER state=Idle\n[SIM][t=50.96] ENTER state=Idle\n[SIM][t=50.97] ENTER state=Idle\n[SIM][t=50.98] ENTER state=Idle\n[SIM][t=50.99] ENTER state=Idle\n[SIM][t=51.00] ENTER state=Idle\n[SIM][t=51.01] ENTER state=Idle\n[SIM][t=51.02] ENTER state=Idle\n[SIM][t=51.03] ENTER state=Idle\n[SIM][t=51.04] ENTER state=Idle\n[SIM][t=51.05] ENTER state=Idle\n[SIM][t=51.06] ENTER state=Idle\n[SIM][t=51.07] ENTER state=Idle\n[SIM][t=51.08] ENTER state=Idle\n[SIM][t=51.09] ENTER state=Idle\n[SIM][t=51.10] ENTER state=Idle\n[SIM][t=51.11] ENTER state=Idle\n[SIM][t=51.12] ENTER state=Idle\n[SIM][t=51.13] ENTER state=Idle\n[SIM][t=51.14] ENTER state=Idle\n[SIM][t=51.15] ENTER state=Idle\n[SIM][t=51.16] ENTER state=Idle\n[SIM][t=51.17] ENTER state=Idle\n[SIM][t=51.18] ENTER state=Idle\n[SIM][t=51.19] ENTER state=Idle\n[SIM][t=51.20] ENTER state=Idle\n[SIM][t=51.21] ENTER state=Idle\n[SIM][t=51.22] ENTER state=Idle\n[SIM][t=51.23] ENTER state=Idle\n[SIM][t=51.24] ENTER state=Idle\n[SIM][t=51.25] ENTER state=Idle\n[SIM][t=51.26] ENTER state=Idle\n[SIM][t=51.27] ENTER state=Idle\n[SIM][t=51.28] ENTER state=Idle\n[SIM][t=51.29] ENTER state=Idle\n[SIM][t=51.30] ENTER state=Idle\n[SIM][t=51.31] ENTER state=Idle\n[SIM][t=51.32] ENTER state=Idle\n[SIM][t=51.33] ENTER state=Idle\n[SIM][t=51.34] ENTER state=Idle\n[SIM][t=51.35] ENTER state=Idle\n[SIM][t=51.36] ENTER state=Idle\n[SIM][t=51.37] ENTER state=Idle\n[SIM][t=51.38] ENTER state=Idle\n[SIM][t=51.39] ENTER state=Idle\n[SIM][t=51.40] ENTER state=Idle\n[SIM][t=51.41] ENTER state=Idle\n[SIM][t=51.42] ENTER state=Idle\n[SIM][t=51.43] ENTER state=Idle\n[SIM][t=51.44] ENTER state=Idle\n[SIM][t=51.45] ENTER state=Idle\n[SIM][t=51.46] ENTER state=Idle\n[SIM][t=51.47] ENTER state=Idle\n[SIM][t=51.48] ENTER state=Idle\n[SIM][t=51.49] ENTER state=Idle\n[SIM][t=51.50] ENTER state=Idle\n[SIM][t=51.51] ENTER state=Idle\n[SIM][t=51.52] ENTER state=Idle\n[SIM][t=51.53] ENTER state=Idle\n[SIM][t=51.54] ENTER state=Idle\n[SIM][t=51.55] ENTER state=Idle\n[SIM][t=51.56] ENTER state=Idle\n[SIM][t=51.57] ENTER state=Idle\n[SIM][t=51.58] ENTER state=Idle\n[SIM][t=51.59] ENTER state=Idle\n[SIM][t=51.60] ENTER state=Idle\n[SIM][t=51.61] ENTER state=Idle\n[SIM][t=51.62] ENTER state=Idle\n[SIM][t=51.63] ENTER state=Idle\n[SIM][t=51.64] ENTER state=Idle\n[SIM][t=51.65] ENTER state=Idle\n[SIM][t=51.66] ENTER state=Idle\n[SIM][t=51.67] ENTER state=Idle\n[SIM][t=51.68] ENTER state=Idle\n[SIM][t=51.69] ENTER state=Idle\n[SIM][t=51.70] ENTER state=Idle\n[SIM][t=51.71] ENTER state=Idle\n[SIM][t=51.72] ENTER state=Idle\n[SIM][t=51.73] ENTER state=Idle\n[SIM][t=51.74] ENTER state=Idle\n[SIM][t=51.75] ENTER state=Idle\n[SIM][t=51.76] ENTER state=Idle\n[SIM][t=51.77] ENTER state=Idle\n[SIM][t=51.78] ENTER state=Idle\n[SIM][t=51.79] ENTER state=Idle\n[SIM][t=51.80] ENTER state=Idle\n[SIM][t=51.81] ENTER state=Idle\n[SIM][t=51.82] ENTER state=Idle\n[SIM][t=51.83] ENTER state=Idle\n[SIM][t=51.84] ENTER state=Idle\n[SIM][t=51.85] ENTER state=Idle\n[SIM][t=51.86] ENTER state=Idle\n[SIM][t=51.87] ENTER state=Idle\n[SIM][t=51.88] ENTER state=Idle\n[SIM][t=51.89] ENTER state=Idle\n[SIM][t=51.90] ENTER state=Idle\n[SIM][t=51.91] ENTER state=Idle\n[SIM][t=51.92] ENTER state=Idle\n[SIM][t=51.93] ENTER state=Idle\n[SIM][t=51.94] ENTER state=Idle\n[SIM][t=51.95] ENTER state=Idle\n[SIM][t=51.96] ENTER state=Idle\n[SIM][t=51.97] ENTER state=Idle\n[SIM][t=51.98] ENTER state=Idle\n[SIM][t=51.99] ENTER state=Idle\n[SIM][t=52.00] ENTER state=Idle\n[SIM][t=52.01] ENTER state=Idle\n[SIM][t=52.02] ENTER state=Idle\n[SIM][t=52.03] ENTER state=Idle\n[SIM][t=52.04] ENTER state=Idle\n[SIM][t=52.05] ENTER state=Idle\n[SIM][t=52.06] ENTER state=Idle\n[SIM][t=52.07] ENTER state=Idle\n[SIM][t=52.08] ENTER state=Idle\n[SIM][t=52.09] ENTER state=Idle\n[SIM][t=52.10] ENTER state=Idle\n[SIM][t=52.11] ENTER state=Idle\n[SIM][t=52.12] ENTER state=Idle\n[SIM][t=52.13] ENTER state=Idle\n[SIM][t=52.14] ENTER state=Idle\n[SIM][t=52.15] ENTER state=Idle\n[SIM][t=52.16] ENTER state=Idle\n[SIM][t=52.17] ENTER state=Idle\n[SIM][t=52.18] ENTER state=Idle\n[SIM][t=52.19] ENTER state=Idle\n[SIM][t=52.20] ENTER state=Idle\n[SIM][t=52.21] ENTER state=Idle\n[SIM][t=52.22] ENTER state=Idle\n[SIM][t=52.23] ENTER state=Idle\n[SIM][t=52.24] ENTER state=Idle\n[SIM][t=52.25] ENTER state=Idle\n[SIM][t=52.26] ENTER state=Idle\n[SIM][t=52.27] ENTER state=Idle\n[SIM][t=52.28] ENTER state=Idle\n[SIM][t=52.29] ENTER state=Idle\n[SIM][t=52.30] ENTER state=Idle\n[SIM][t=52.31] ENTER state=Idle\n[SIM][t=52.32] ENTER state=Idle\n[SIM][t=52.33] ENTER state=Idle\n[SIM][t=52.34] ENTER state=Idle\n[SIM][t=52.35] ENTER state=Idle\n[SIM][t=52.36] ENTER state=Idle\n[SIM][t=52.37] ENTER state=Idle\n[SIM][t=52.38] ENTER state=Idle\n[SIM][t=52.39] ENTER state=Idle\n[SIM][t=52.40] ENTER state=Idle\n[SIM][t=52.41] ENTER state=Idle\n[SIM][t=52.42] ENTER state=Idle\n[SIM][t=52.43] ENTER state=Idle\n[SIM][t=52.44] ENTER state=Idle\n[SIM][t=52.45] ENTER state=Idle\n[SIM][t=52.46] ENTER state=Idle\n[SIM][t=52.47] ENTER state=Idle\n[SIM][t=52.48] ENTER state=Idle\n[SIM][t=52.49] ENTER state=Idle\n[SIM][t=52.50] ENTER state=Idle\n[SIM][t=52.51] ENTER state=Idle\n[SIM][t=52.52] ENTER state=Idle\n[SIM][t=52.53] ENTER state=Idle\n[SIM][t=52.54] ENTER state=Idle\n[SIM][t=52.55] ENTER state=Idle\n[SIM][t=52.56] ENTER state=Idle\n[SIM][t=52.57] ENTER state=Idle\n[SIM][t=52.58] ENTER state=Idle\n[SIM][t=52.59] ENTER state=Idle\n[SIM][t=52.60] ENTER state=Idle\n[SIM][t=52.61] ENTER state=Idle\n[SIM][t=52.62] ENTER state=Idle\n[SIM][t=52.63] ENTER state=Idle\n[SIM][t=52.64] ENTER state=Idle\n[SIM][t=52.65] ENTER state=Idle\n[SIM][t=52.66] ENTER state=Idle\n[SIM][t=52.67] ENTER state=Idle\n[SIM][t=52.68] ENTER state=Idle\n[SIM][t=52.69] ENTER state=Idle\n[SIM][t=52.70] ENTER state=Idle\n[SIM][t=52.71] ENTER state=Idle\n[SIM][t=52.72] ENTER state=Idle\n[SIM][t=52.73] ENTER state=Idle\n[SIM][t=52.74] ENTER state=Idle\n[SIM][t=52.75] ENTER state=Idle\n[SIM][t=52.76] ENTER state=Idle\n[SIM][t=52.77] ENTER state=Idle\n[SIM][t=52.78] ENTER state=Idle\n[SIM][t=52.79] ENTER state=Idle\n[SIM][t=52.80] ENTER state=Idle\n[SIM][t=52.81] ENTER state=Idle\n[SIM][t=52.82] ENTER state=Idle\n[SIM][t=52.83] ENTER state=Idle\n[SIM][t=52.84] ENTER state=Idle\n[SIM][t=52.85] ENTER state=Idle\n[SIM][t=52.86] ENTER state=Idle\n[SIM][t=52.87] ENTER state=Idle\n[SIM][t=52.88] ENTER state=Idle\n[SIM][t=52.89] ENTER state=Idle\n[SIM][t=52.90] ENTER state=Idle\n[SIM][t=52.91] ENTER state=Idle\n[SIM][t=52.92] ENTER state=Idle\n[SIM][t=52.93] ENTER state=Idle\n[SIM][t=52.94] ENTER state=Idle\n[SIM][t=52.95] ENTER state=Idle\n[SIM][t=52.96] ENTER state=Idle\n[SIM][t=52.97] ENTER state=Idle\n[SIM][t=52.98] ENTER state=Idle\n[SIM][t=52.99] ENTER state=Idle\n[SIM][t=53.00] ENTER state=Idle\n[SIM][t=53.01] ENTER state=Idle\n[SIM][t=53.02] ENTER state=Idle\n[SIM][t=53.03] ENTER state=Idle\n[SIM][t=53.04] ENTER state=Idle\n[SIM][t=53.05] ENTER state=Idle\n[SIM][t=53.06] ENTER state=Idle\n[SIM][t=53.07] ENTER state=Idle\n[SIM][t=53.08] ENTER state=Idle\n[SIM][t=53.09] ENTER state=Idle\n[SIM][t=53.10] ENTER state=Idle\n[SIM][t=53.11] ENTER state=Idle\n[SIM][t=53.12] ENTER state=Idle\n[SIM][t=53.13] ENTER state=Idle\n[SIM][t=53.14] ENTER state=Idle\n[SIM][t=53.15] ENTER state=Idle\n[SIM][t=53.16] ENTER state=Idle\n[SIM][t=53.17] ENTER state=Idle\n[SIM][t=53.18] ENTER state=Idle\n[SIM][t=53.19] ENTER state=Idle\n[SIM][t=53.20] ENTER state=Idle\n[SIM][t=53.21] ENTER state=Idle\n[SIM][t=53.22] ENTER state=Idle\n[SIM][t=53.23] ENTER state=Idle\n[SIM][t=53.24] ENTER state=Idle\n[SIM][t=53.25] ENTER state=Idle\n[SIM][t=53.26] ENTER state=Idle\n[SIM][t=53.27] ENTER state=Idle\n[SIM][t=53.28] ENTER state=Idle\n[SIM][t=53.29] ENTER state=Idle\n[SIM][t=53.30] ENTER state=Idle\n[SIM][t=53.31] ENTER state=Idle\n[SIM][t=53.32] ENTER state=Idle\n[SIM][t=53.33] ENTER state=Idle\n[SIM][t=53.34] ENTER state=Idle\n[SIM][t=53.35] ENTER state=Idle\n[SIM][t=53.36] ENTER state=Idle\n[SIM][t=53.37] ENTER state=Idle\n[SIM][t=53.38] ENTER state=Idle\n[SIM][t=53.39] ENTER state=Idle\n[SIM][t=53.40] ENTER state=Idle\n[SIM][t=53.41] ENTER state=Idle\n[SIM][t=53.42] ENTER state=Idle\n[SIM][t=53.43] ENTER state=Idle\n[SIM][t=53.44] ENTER state=Idle\n[SIM][t=53.45] ENTER state=Idle\n[SIM][t=53.46] ENTER state=Idle\n[SIM][t=53.47] ENTER state=Idle\n[SIM][t=53.48] ENTER state=Idle\n[SIM][t=53.49] ENTER state=Idle\n[SIM][t=53.50] ENTER state=Idle\n[SIM][t=53.51] ENTER state=Idle\n[SIM][t=53.52] ENTER state=Idle\n[SIM][t=53.53] ENTER state=Idle\n[SIM][t=53.54] ENTER state=Idle\n[SIM][t=53.55] ENTER state=Idle\n[SIM][t=53.56] ENTER state=Idle\n[SIM][t=53.57] ENTER state=Idle\n[SIM][t=53.58] ENTER state=Idle\n[SIM][t=53.59] ENTER state=Idle\n[SIM][t=53.60] ENTER state=Idle\n[SIM][t=53.61] ENTER state=Idle\n[SIM][t=53.62] ENTER state=Idle\n[SIM][t=53.63] ENTER state=Idle\n[SIM][t=53.64] ENTER state=Idle\n[SIM][t=53.65] ENTER state=Idle\n[SIM][t=53.66] ENTER state=Idle\n[SIM][t=53.67] ENTER state=Idle\n[SIM][t=53.68] ENTER state=Idle\n[SIM][t=53.69] ENTER state=Idle\n[SIM][t=53.70] ENTER state=Idle\n[SIM][t=53.71] ENTER state=Idle\n[SIM][t=53.72] ENTER state=Idle\n[SIM][t=53.73] ENTER state=Idle\n[SIM][t=53.74] ENTER state=Idle\n[SIM][t=53.75] ENTER state=Idle\n[SIM][t=53.76] ENTER state=Idle\n[SIM][t=53.77] ENTER state=Idle\n[SIM][t=53.78] ENTER state=Idle\n[SIM][t=53.79] ENTER state=Idle\n[SIM][t=53.80] ENTER state=Idle\n[SIM][t=53.81] ENTER state=Idle\n[SIM][t=53.82] ENTER state=Idle\n[SIM][t=53.83] ENTER state=Idle\n[SIM][t=53.84] ENTER state=Idle\n[SIM][t=53.85] ENTER state=Idle\n[SIM][t=53.86] ENTER state=Idle\n[SIM][t=53.87] ENTER state=Idle\n[SIM][t=53.88] ENTER state=Idle\n[SIM][t=53.89] ENTER state=Idle\n[SIM][t=53.90] ENTER state=Idle\n[SIM][t=53.91] ENTER state=Idle\n[SIM][t=53.92] ENTER state=Idle\n[SIM][t=53.93] ENTER state=Idle\n[SIM][t=53.94] ENTER state=Idle\n[SIM][t=53.95] ENTER state=Idle\n[SIM][t=53.96] ENTER state=Idle\n[SIM][t=53.97] ENTER state=Idle\n[SIM][t=53.98] ENTER state=Idle\n[SIM][t=53.99] ENTER state=Idle\n[SIM][t=54.00] ENTER state=Idle\n[SIM][t=54.01] ENTER state=Idle\n[SIM][t=54.02] ENTER state=Idle\n[SIM][t=54.03] ENTER state=Idle\n[SIM][t=54.04] ENTER state=Idle\n[SIM][t=54.05] ENTER state=Idle\n[SIM][t=54.06] ENTER state=Idle\n[SIM][t=54.07] ENTER state=Idle\n[SIM][t=54.08] ENTER state=Idle\n[SIM][t=54.09] ENTER state=Idle\n[SIM][t=54.10] ENTER state=Idle\n[SIM][t=54.11] ENTER state=Idle\n[SIM][t=54.12] ENTER state=Idle\n[SIM][t=54.13] ENTER state=Idle\n[SIM][t=54.14] ENTER state=Idle\n[SIM][t=54.15] ENTER state=Idle\n[SIM][t=54.16] ENTER state=Idle\n[SIM][t=54.17] ENTER state=Idle\n[SIM][t=54.18] ENTER state=Idle\n[SIM][t=54.19] ENTER state=Idle\n[SIM][t=54.20] ENTER state=Idle\n[SIM][t=54.21] ENTER state=Idle\n[SIM][t=54.22] ENTER state=Idle\n[SIM][t=54.23] ENTER state=Idle\n[SIM][t=54.24] ENTER state=Idle\n[SIM][t=54.25] ENTER state=Idle\n[SIM][t=54.26] ENTER state=Idle\n[SIM][t=54.27] ENTER state=Idle\n[SIM][t=54.28] ENTER state=Idle\n[SIM][t=54.29] ENTER state=Idle\n[SIM][t=54.30] ENTER state=Idle\n[SIM][t=54.31] ENTER state=Idle\n[SIM][t=54.32] ENTER state=Idle\n[SIM][t=54.33] ENTER state=Idle\n[SIM][t=54.34] ENTER state=Idle\n[SIM][t=54.35] ENTER state=Idle\n[SIM][t=54.36] ENTER state=Idle\n[SIM][t=54.37] ENTER state=Idle\n[SIM][t=54.38] ENTER state=Idle\n[SIM][t=54.39] ENTER state=Idle\n[SIM][t=54.40] ENTER state=Idle\n[SIM][t=54.41] ENTER state=Idle\n[SIM][t=54.42] ENTER state=Idle\n[SIM][t=54.43] ENTER state=Idle\n[SIM][t=54.44] ENTER state=Idle\n[SIM][t=54.45] ENTER state=Idle\n[SIM][t=54.46] ENTER state=Idle\n[SIM][t=54.47] ENTER state=Idle\n[SIM][t=54.48] ENTER state=Idle\n[SIM][t=54.49] ENTER state=Idle\n[SIM][t=54.50] ENTER state=Idle\n[SIM][t=54.51] ENTER state=Idle\n[SIM][t=54.52] ENTER state=Idle\n[SIM][t=54.53] ENTER state=Idle\n[SIM][t=54.54] ENTER state=Idle\n[SIM][t=54.55] ENTER state=Idle\n[SIM][t=54.56] ENTER state=Idle\n[SIM][t=54.57] ENTER state=Idle\n[SIM][t=54.58] ENTER state=Idle\n[SIM][t=54.59] ENTER state=Idle\n[SIM][t=54.60] ENTER state=Idle\n[SIM][t=54.61] ENTER state=Idle\n[SIM][t=54.62] ENTER state=Idle\n[SIM][t=54.63] ENTER state=Idle\n[SIM][t=54.64] ENTER state=Idle\n[SIM][t=54.65] ENTER state=Idle\n[SIM][t=54.66] ENTER state=Idle\n[SIM][t=54.67] ENTER state=Idle\n[SIM][t=54.68] ENTER state=Idle\n[SIM][t=54.69] ENTER state=Idle\n[SIM][t=54.70] ENTER state=Idle\n[SIM][t=54.71] ENTER state=Idle\n[SIM][t=54.72] ENTER state=Idle\n[SIM][t=54.73] ENTER state=Idle\n[SIM][t=54.74] ENTER state=Idle\n[SIM][t=54.75] ENTER state=Idle\n[SIM][t=54.76] ENTER state=Idle\n[SIM][t=54.77] ENTER state=Idle\n[SIM][t=54.78] ENTER state=Idle\n[SIM][t=54.79] ENTER state=Idle\n[SIM][t=54.80] ENTER state=Idle\n[SIM][t=54.81] ENTER state=Idle\n[SIM][t=54.82] ENTER state=Idle\n[SIM][t=54.83] ENTER state=Idle\n[SIM][t=54.84] ENTER state=Idle\n[SIM][t=54.85] ENTER state=Idle\n[SIM][t=54.86] ENTER state=Idle\n[SIM][t=54.87] ENTER state=Idle\n[SIM][t=54.88] ENTER state=Idle\n[SIM][t=54.89] ENTER state=Idle\n[SIM][t=54.90] ENTER state=Idle\n[SIM][t=54.91] ENTER state=Idle\n[SIM][t=54.92] ENTER state=Idle\n[SIM][t=54.93] ENTER state=Idle\n[SIM][t=54.94] ENTER state=Idle\n[SIM][t=54.95] ENTER state=Idle\n[SIM][t=54.96] ENTER state=Idle\n[SIM][t=54.97] ENTER state=Idle\n[SIM][t=54.98] ENTER state=Idle\n[SIM][t=54.99] ENTER state=Idle\n[SIM][t=55.00] ENTER state=Idle\n[SIM][t=55.01] ENTER state=Idle\n[SIM][t=55.02] ENTER state=Idle\n[SIM][t=55.03] ENTER state=Idle\n[SIM][t=55.04] ENTER state=Idle\n[SIM][t=55.05] ENTER state=Idle\n[SIM][t=55.06] ENTER state=Idle\n[SIM][t=55.07] ENTER state=Idle\n[SIM][t=55.08] ENTER state=Idle\n[SIM][t=55.09] ENTER state=Idle\n[SIM][t=55.10] ENTER state=Idle\n[SIM][t=55.11] ENTER state=Idle\n[SIM][t=55.12] ENTER state=Idle\n[SIM][t=55.13] ENTER state=Idle\n[SIM][t=55.14] ENTER state=Idle\n[SIM][t=55.15] ENTER state=Idle\n[SIM][t=55.16] ENTER state=Idle\n[SIM][t=55.17] ENTER state=Idle\n[SIM][t=55.18] ENTER state=Idle\n[SIM][t=55.19] ENTER state=Idle\n[SIM][t=55.20] ENTER state=Idle\n[SIM][t=55.21] ENTER state=Idle\n[SIM][t=55.22] ENTER state=Idle\n[SIM][t=55.23] ENTER state=Idle\n[SIM][t=55.24] ENTER state=Idle\n[SIM][t=55.25] ENTER state=Idle\n[SIM][t=55.26] ENTER state=Idle\n[SIM][t=55.27] ENTER state=Idle\n[SIM][t=55.28] ENTER state=Idle\n[SIM][t=55.29] ENTER state=Idle\n[SIM][t=55.30] ENTER state=Idle\n[SIM][t=55.31] ENTER state=Idle\n[SIM][t=55.32] ENTER state=Idle\n[SIM][t=55.33] ENTER state=Idle\n[SIM][t=55.34] ENTER state=Idle\n[SIM][t=55.35] ENTER state=Idle\n[SIM][t=55.36] ENTER state=Idle\n[SIM][t=55.37] ENTER state=Idle\n[SIM][t=55.38] ENTER state=Idle\n[SIM][t=55.39] ENTER state=Idle\n[SIM][t=55.40] ENTER state=Idle\n[SIM][t=55.41] ENTER state=Idle\n[SIM][t=55.42] ENTER state=Idle\n[SIM][t=55.43] ENTER state=Idle\n[SIM][t=55.44] ENTER state=Idle\n[SIM][t=55.45] ENTER state=Idle\n[SIM][t=55.46] ENTER state=Idle\n[SIM][t=55.47] ENTER state=Idle\n[SIM][t=55.48] ENTER state=Idle\n[SIM][t=55.49] ENTER state=Idle\n[SIM][t=55.50] ENTER state=Idle\n[SIM][t=55.51] ENTER state=Idle\n[SIM][t=55.52] ENTER state=Idle\n[SIM][t=55.53] ENTER state=Idle\n[SIM][t=55.54] ENTER state=Idle\n[SIM][t=55.55] ENTER state=Idle\n[SIM][t=55.56] ENTER state=Idle\n[SIM][t=55.57] ENTER state=Idle\n[SIM][t=55.58] ENTER state=Idle\n[SIM][t=55.59] ENTER state=Idle\n[SIM][t=55.60] ENTER state=Idle\n[SIM][t=55.61] ENTER state=Idle\n[SIM][t=55.62] ENTER state=Idle\n[SIM][t=55.63] ENTER state=Idle\n[SIM][t=55.64] ENTER state=Idle\n[SIM][t=55.65] ENTER state=Idle\n[SIM][t=55.66] ENTER state=Idle\n[SIM][t=55.67] ENTER state=Idle\n[SIM][t=55.68] ENTER state=Idle\n[SIM][t=55.69] ENTER state=Idle\n[SIM][t=55.70] ENTER state=Idle\n[SIM][t=55.71] ENTER state=Idle\n[SIM][t=55.72] ENTER state=Idle\n[SIM][t=55.73] ENTER state=Idle\n[SIM][t=55.74] ENTER state=Idle\n[SIM][t=55.75] ENTER state=Idle\n[SIM][t=55.76] ENTER state=Idle\n[SIM][t=55.77] ENTER state=Idle\n[SIM][t=55.78] ENTER state=Idle\n[SIM][t=55.79] ENTER state=Idle\n[SIM][t=55.80] ENTER state=Idle\n[SIM][t=55.81] ENTER state=Idle\n[SIM][t=55.82] ENTER state=Idle\n[SIM][t=55.83] ENTER state=Idle\n[SIM][t=55.84] ENTER state=Idle\n[SIM][t=55.85] ENTER state=Idle\n[SIM][t=55.86] ENTER state=Idle\n[SIM][t=55.87] ENTER state=Idle\n[SIM][t=55.88] ENTER state=Idle\n[SIM][t=55.89] ENTER state=Idle\n[SIM][t=55.90] ENTER state=Idle\n[SIM][t=55.91] ENTER state=Idle\n[SIM][t=55.92] ENTER state=Idle\n[SIM][t=55.93] ENTER state=Idle\n[SIM][t=55.94] ENTER state=Idle\n[SIM][t=55.95] ENTER state=Idle\n[SIM][t=55.96] ENTER state=Idle\n[SIM][t=55.97] ENTER state=Idle\n[SIM][t=55.98] ENTER state=Idle\n[SIM][t=55.99] ENTER state=Idle\n[SIM][t=56.00] ENTER state=Idle\n[SIM][t=56.01] ENTER state=Idle\n[SIM][t=56.02] ENTER state=Idle\n[SIM][t=56.03] ENTER state=Idle\n[SIM][t=56.04] ENTER state=Idle\n[SIM][t=56.05] ENTER state=Idle\n[SIM][t=56.06] ENTER state=Idle\n[SIM][t=56.07] ENTER state=Idle\n[SIM][t=56.08] ENTER state=Idle\n[SIM][t=56.09] ENTER state=Idle\n[SIM][t=56.10] ENTER state=Idle\n[SIM][t=56.11] ENTER state=Idle\n[SIM][t=56.12] ENTER state=Idle\n[SIM][t=56.13] ENTER state=Idle\n[SIM][t=56.14] ENTER state=Idle\n[SIM][t=56.15] ENTER state=Idle\n[SIM][t=56.16] ENTER state=Idle\n[SIM][t=56.17] ENTER state=Idle\n[SIM][t=56.18] ENTER state=Idle\n[SIM][t=56.19] ENTER state=Idle\n[SIM][t=56.20] ENTER state=Idle\n[SIM][t=56.21] ENTER state=Idle\n[SIM][t=56.22] ENTER state=Idle\n[SIM][t=56.23] ENTER state=Idle\n[SIM][t=56.24] ENTER state=Idle\n[SIM][t=56.25] ENTER state=Idle\n[SIM][t=56.26] ENTER state=Idle\n[SIM][t=56.27] ENTER state=Idle\n[SIM][t=56.28] ENTER state=Idle\n[SIM][t=56.29] ENTER state=Idle\n[SIM][t=56.30] ENTER state=Idle\n[SIM][t=56.31] ENTER state=Idle\n[SIM][t=56.32] ENTER state=Idle\n[SIM][t=56.33] ENTER state=Idle\n[SIM][t=56.34] ENTER state=Idle\n[SIM][t=56.35] ENTER state=Idle\n[SIM][t=56.36] ENTER state=Idle\n[SIM][t=56.37] ENTER state=Idle\n[SIM][t=56.38] ENTER state=Idle\n[SIM][t=56.39] ENTER state=Idle\n[SIM][t=56.40] ENTER state=Idle\n[SIM][t=56.41] ENTER state=Idle\n[SIM][t=56.42] ENTER state=Idle\n[SIM][t=56.43] ENTER state=Idle\n[SIM][t=56.44] ENTER state=Idle\n[SIM][t=56.45] ENTER state=Idle\n[SIM][t=56.46] ENTER state=Idle\n[SIM][t=56.47] ENTER state=Idle\n[SIM][t=56.48] ENTER state=Idle\n[SIM][t=56.49] ENTER state=Idle\n[SIM][t=56.50] ENTER state=Idle\n[SIM][t=56.51] ENTER state=Idle\n[SIM][t=56.52] ENTER state=Idle\n[SIM][t=56.53] ENTER state=Idle\n[SIM][t=56.54] ENTER state=Idle\n[SIM][t=56.55] ENTER state=Idle\n[SIM][t=56.56] ENTER state=Idle\n[SIM][t=56.57] ENTER state=Idle\n[SIM][t=56.58] ENTER state=Idle\n[SIM][t=56.59] ENTER state=Idle\n[SIM][t=56.60] ENTER state=Idle\n[SIM][t=56.61] ENTER state=Idle\n[SIM][t=56.62] ENTER state=Idle\n[SIM][t=56.63] ENTER state=Idle\n[SIM][t=56.64] ENTER state=Idle\n[SIM][t=56.65] ENTER state=Idle\n[SIM][t=56.66] ENTER state=Idle\n[SIM][t=56.67] ENTER state=Idle\n[SIM][t=56.68] ENTER state=Idle\n[SIM][t=56.69] ENTER state=Idle\n[SIM][t=56.70] ENTER state=Idle\n[SIM][t=56.71] ENTER state=Idle\n[SIM][t=56.72] ENTER state=Idle\n[SIM][t=56.73] ENTER state=Idle\n[SIM][t=56.74] ENTER state=Idle\n[SIM][t=56.75] ENTER state=Idle\n[SIM][t=56.76] ENTER state=Idle\n[SIM][t=56.77] ENTER state=Idle\n[SIM][t=56.78] ENTER state=Idle\n[SIM][t=56.79] ENTER state=Idle\n[SIM][t=56.80] ENTER state=Idle\n[SIM][t=56.81] ENTER state=Idle\n[SIM][t=56.82] ENTER state=Idle\n[SIM][t=56.83] ENTER state=Idle\n[SIM][t=56.84] ENTER state=Idle\n[SIM][t=56.85] ENTER state=Idle\n[SIM][t=56.86] ENTER state=Idle\n[SIM][t=56.87] ENTER state=Idle\n[SIM][t=56.88] ENTER state=Idle\n[SIM][t=56.89] ENTER state=Idle\n[SIM][t=56.90] ENTER state=Idle\n[SIM][t=56.91] ENTER state=Idle\n[SIM][t=56.92] ENTER state=Idle\n[SIM][t=56.93] ENTER state=Idle\n[SIM][t=56.94] ENTER state=Idle\n[SIM][t=56.95] ENTER state=Idle\n[SIM][t=56.96] ENTER state=Idle\n[SIM][t=56.97] ENTER state=Idle\n[SIM][t=56.98] ENTER state=Idle\n[SIM][t=56.99] ENTER state=Idle\n[SIM][t=57.00] ENTER state=Idle\n[SIM][t=57.01] ENTER state=Idle\n[SIM][t=57.02] ENTER state=Idle\n[SIM][t=57.03] ENTER state=Idle\n[SIM][t=57.04] ENTER state=Idle\n[SIM][t=57.05] ENTER state=Idle\n[SIM][t=57.06] ENTER state=Idle\n[SIM][t=57.07] ENTER state=Idle\n[SIM][t=57.08] ENTER state=Idle\n[SIM][t=57.09] ENTER state=Idle\n[SIM][t=57.10] ENTER state=Idle\n[SIM][t=57.11] ENTER state=Idle\n[SIM][t=57.12] ENTER state=Idle\n[SIM][t=57.13] ENTER state=Idle\n[SIM][t=57.14] ENTER state=Idle\n[SIM][t=57.15] ENTER state=Idle\n[SIM][t=57.16] ENTER state=Idle\n[SIM][t=57.17] ENTER state=Idle\n[SIM][t=57.18] ENTER state=Idle\n[SIM][t=57.19] ENTER state=Idle\n[SIM][t=57.20] ENTER state=Idle\n[SIM][t=57.21] ENTER state=Idle\n[SIM][t=57.22] ENTER state=Idle\n[SIM][t=57.23] ENTER state=Idle\n[SIM][t=57.24] ENTER state=Idle\n[SIM][t=57.25] ENTER state=Idle\n[SIM][t=57.26] ENTER state=Idle\n[SIM][t=57.27] ENTER state=Idle\n[SIM][t=57.28] ENTER state=Idle\n[SIM][t=57.29] ENTER state=Idle\n[SIM][t=57.30] ENTER state=Idle\n[SIM][t=57.31] ENTER state=Idle\n[SIM][t=57.32] ENTER state=Idle\n[SIM][t=57.33] ENTER state=Idle\n[SIM][t=57.34] ENTER state=Idle\n[SIM][t=57.35] ENTER state=Idle\n[SIM][t=57.36] ENTER state=Idle\n[SIM][t=57.37] ENTER state=Idle\n[SIM][t=57.38] ENTER state=Idle\n[SIM][t=57.39] ENTER state=Idle\n[SIM][t=57.40] ENTER state=Idle\n[SIM][t=57.41] ENTER state=Idle\n[SIM][t=57.42] ENTER state=Idle\n[SIM][t=57.43] ENTER state=Idle\n[SIM][t=57.44] ENTER state=Idle\n[SIM][t=57.45] ENTER state=Idle\n[SIM][t=57.46] ENTER state=Idle\n[SIM][t=57.47] ENTER state=Idle\n[SIM][t=57.48] ENTER state=Idle\n[SIM][t=57.49] ENTER state=Idle\n[SIM][t=57.50] ENTER state=Idle\n[SIM][t=57.51] ENTER state=Idle\n[SIM][t=57.52] ENTER state=Idle\n[SIM][t=57.53] ENTER state=Idle\n[SIM][t=57.54] ENTER state=Idle\n[SIM][t=57.55] ENTER state=Idle\n[SIM][t=57.56] ENTER state=Idle\n[SIM][t=57.57] ENTER state=Idle\n[SIM][t=57.58] ENTER state=Idle\n[SIM][t=57.59] ENTER state=Idle\n[SIM][t=57.60] ENTER state=Idle\n[SIM][t=57.61] ENTER state=Idle\n[SIM][t=57.62] ENTER state=Idle\n[SIM][t=57.63] ENTER state=Idle\n[SIM][t=57.64] ENTER state=Idle\n[SIM][t=57.65] ENTER state=Idle\n[SIM][t=57.66] ENTER state=Idle\n[SIM][t=57.67] ENTER state=Idle\n[SIM][t=57.68] ENTER state=Idle\n[SIM][t=57.69] ENTER state=Idle\n[SIM][t=57.70] ENTER state=Idle\n[SIM][t=57.71] ENTER state=Idle\n[SIM][t=57.72] ENTER state=Idle\n[SIM][t=57.73] ENTER state=Idle\n[SIM][t=57.74] ENTER state=Idle\n[SIM][t=57.75] ENTER state=Idle\n[SIM][t=57.76] ENTER state=Idle\n[SIM][t=57.77] ENTER state=Idle\n[SIM][t=57.78] ENTER state=Idle\n[SIM][t=57.79] ENTER state=Idle\n[SIM][t=57.80] ENTER state=Idle\n[SIM][t=57.81] ENTER state=Idle\n[SIM][t=57.82] ENTER state=Idle\n[SIM][t=57.83] ENTER state=Idle\n[SIM][t=57.84] ENTER state=Idle\n[SIM][t=57.85] ENTER state=Idle\n[SIM][t=57.86] ENTER state=Idle\n[SIM][t=57.87] ENTER state=Idle\n[SIM][t=57.88] ENTER state=Idle\n[SIM][t=57.89] ENTER state=Idle\n[SIM][t=57.90] ENTER state=Idle\n[SIM][t=57.91] ENTER state=Idle\n[SIM][t=57.92] ENTER state=Idle\n[SIM][t=57.93] ENTER state=Idle\n[SIM][t=57.94] ENTER state=Idle\n[SIM][t=57.95] ENTER state=Idle\n[SIM][t=57.96] ENTER state=Idle\n[SIM][t=57.97] ENTER state=Idle\n[SIM][t=57.98] ENTER state=Idle\n[SIM][t=57.99] ENTER state=Idle\n[SIM][t=58.00] ENTER state=Idle\n[SIM][t=58.01] ENTER state=Idle\n[SIM][t=58.02] ENTER state=Idle\n[SIM][t=58.03] ENTER state=Idle\n[SIM][t=58.04] ENTER state=Idle\n[SIM][t=58.05] ENTER state=Idle\n[SIM][t=58.06] ENTER state=Idle\n[SIM][t=58.07] ENTER state=Idle\n[SIM][t=58.08] ENTER state=Idle\n[SIM][t=58.09] ENTER state=Idle\n[SIM][t=58.10] ENTER state=Idle\n[SIM][t=58.11] ENTER state=Idle\n[SIM][t=58.12] ENTER state=Idle\n[SIM][t=58.13] ENTER state=Idle\n[SIM][t=58.14] ENTER state=Idle\n[SIM][t=58.15] ENTER state=Idle\n[SIM][t=58.16] ENTER state=Idle\n[SIM][t=58.17] ENTER state=Idle\n[SIM][t=58.18] ENTER state=Idle\n[SIM][t=58.19] ENTER state=Idle\n[SIM][t=58.20] ENTER state=Idle\n[SIM][t=58.21] ENTER state=Idle\n[SIM][t=58.22] ENTER state=Idle\n[SIM][t=58.23] ENTER state=Idle\n[SIM][t=58.24] ENTER state=Idle\n[SIM][t=58.25] ENTER state=Idle\n[SIM][t=58.26] ENTER state=Idle\n[SIM][t=58.27] ENTER state=Idle\n[SIM][t=58.28] ENTER state=Idle\n[SIM][t=58.29] ENTER state=Idle\n[SIM][t=58.30] ENTER state=Idle\n[SIM][t=58.31] ENTER state=Idle\n[SIM][t=58.32] ENTER state=Idle\n[SIM][t=58.33] ENTER state=Idle\n[SIM][t=58.34] ENTER state=Idle\n[SIM][t=58.35] ENTER state=Idle\n[SIM][t=58.36] ENTER state=Idle\n[SIM][t=58.37] ENTER state=Idle\n[SIM][t=58.38] ENTER state=Idle\n[SIM][t=58.39] ENTER state=Idle\n[SIM][t=58.40] ENTER state=Idle\n[SIM][t=58.41] ENTER state=Idle\n[SIM][t=58.42] ENTER state=Idle\n[SIM][t=58.43] ENTER state=Idle\n[SIM][t=58.44] ENTER state=Idle\n[SIM][t=58.45] ENTER state=Idle\n[SIM][t=58.46] ENTER state=Idle\n[SIM][t=58.47] ENTER state=Idle\n[SIM][t=58.48] ENTER state=Idle\n[SIM][t=58.49] ENTER state=Idle\n[SIM][t=58.50] ENTER state=Idle\n[SIM][t=58.51] ENTER state=Idle\n[SIM][t=58.52] ENTER state=Idle\n[SIM][t=58.53] ENTER state=Idle\n[SIM][t=58.54] ENTER state=Idle\n[SIM][t=58.55] ENTER state=Idle\n[SIM][t=58.56] ENTER state=Idle\n[SIM][t=58.57] ENTER state=Idle\n[SIM][t=58.58] ENTER state=Idle\n[SIM][t=58.59] ENTER state=Idle\n[SIM][t=58.60] ENTER state=Idle\n[SIM][t=58.61] ENTER state=Idle\n[SIM][t=58.62] ENTER state=Idle\n[SIM][t=58.63] ENTER state=Idle\n[SIM][t=58.64] ENTER state=Idle\n[SIM][t=58.65] ENTER state=Idle\n[SIM][t=58.66] ENTER state=Idle\n[SIM][t=58.67] ENTER state=Idle\n[SIM][t=58.68] ENTER state=Idle\n[SIM][t=58.69] ENTER state=Idle\n[SIM][t=58.70] ENTER state=Idle\n[SIM][t=58.71] ENTER state=Idle\n[SIM][t=58.72] ENTER state=Idle\n[SIM][t=58.73] ENTER state=Idle\n[SIM][t=58.74] ENTER state=Idle\n[SIM][t=58.75] ENTER state=Idle\n[SIM][t=58.76] ENTER state=Idle\n[SIM][t=58.77] ENTER state=Idle\n[SIM][t=58.78] ENTER state=Idle\n[SIM][t=58.79] ENTER state=Idle\n[SIM][t=58.80] ENTER state=Idle\n[SIM][t=58.81] ENTER state=Idle\n[SIM][t=58.82] ENTER state=Idle\n[SIM][t=58.83] ENTER state=Idle\n[SIM][t=58.84] ENTER state=Idle\n[SIM][t=58.85] ENTER state=Idle\n[SIM][t=58.86] ENTER state=Idle\n[SIM][t=58.87] ENTER state=Idle\n[SIM][t=58.88] ENTER state=Idle\n[SIM][t=58.89] ENTER state=Idle\n[SIM][t=58.90] ENTER state=Idle\n[SIM][t=58.91] ENTER state=Idle\n[SIM][t=58.92] ENTER state=Idle\n[SIM][t=58.93] ENTER state=Idle\n[SIM][t=58.94] ENTER state=Idle\n[SIM][t=58.95] ENTER state=Idle\n[SIM][t=58.96] ENTER state=Idle\n[SIM][t=58.97] ENTER state=Idle\n[SIM][t=58.98] ENTER state=Idle\n[SIM][t=58.99] ENTER state=Idle\n[SIM][t=59.00] ENTER state=Idle\n[SIM][t=59.01] ENTER state=Idle\n[SIM][t=59.02] ENTER state=Idle\n[SIM][t=59.03] ENTER state=Idle\n[SIM][t=59.04] ENTER state=Idle\n[SIM][t=59.05] ENTER state=Idle\n[SIM][t=59.06] ENTER state=Idle\n[SIM][t=59.07] ENTER state=Idle\n[SIM][t=59.08] ENTER state=Idle\n[SIM][t=59.09] ENTER state=Idle\n[SIM][t=59.10] ENTER state=Idle\n[SIM][t=59.11] ENTER state=Idle\n[SIM][t=59.12] ENTER state=Idle\n[SIM][t=59.13] ENTER state=Idle\n[SIM][t=59.14] ENTER state=Idle\n[SIM][t=59.15] ENTER state=Idle\n[SIM][t=59.16] ENTER state=Idle\n[SIM][t=59.17] ENTER state=Idle\n[SIM][t=59.18] ENTER state=Idle\n[SIM][t=59.19] ENTER state=Idle\n[SIM][t=59.20] ENTER state=Idle\n[SIM][t=59.21] ENTER state=Idle\n[SIM][t=59.22] ENTER state=Idle\n[SIM][t=59.23] ENTER state=Idle\n[SIM][t=59.24] ENTER state=Idle\n[SIM][t=59.25] ENTER state=Idle\n[SIM][t=59.26] ENTER state=Idle\n[SIM][t=59.27] ENTER state=Idle\n[SIM][t=59.28] ENTER state=Idle\n[SIM][t=59.29] ENTER state=Idle\n[SIM][t=59.30] ENTER state=Idle\n[SIM][t=59.31] ENTER state=Idle\n[SIM][t=59.32] ENTER state=Idle\n[SIM][t=59.33] ENTER state=Idle\n[SIM][t=59.34] ENTER state=Idle\n[SIM][t=59.35] ENTER state=Idle\n[SIM][t=59.36] ENTER state=Idle\n[SIM][t=59.37] ENTER state=Idle\n[SIM][t=59.38] ENTER state=Idle\n[SIM][t=59.39] ENTER state=Idle\n[SIM][t=59.40] ENTER state=Idle\n[SIM][t=59.41] ENTER state=Idle\n[SIM][t=59.42] ENTER state=Idle\n[SIM][t=59.43] ENTER state=Idle\n[SIM][t=59.44] ENTER state=Idle\n[SIM][t=59.45] ENTER state=Idle\n[SIM][t=59.46] ENTER state=Idle\n[SIM][t=59.47] ENTER state=Idle\n[SIM][t=59.48] ENTER state=Idle\n[SIM][t=59.49] ENTER state=Idle\n[SIM][t=59.50] ENTER state=Idle\n[SIM][t=59.51] ENTER state=Idle\n[SIM][t=59.52] ENTER state=Idle\n[SIM][t=59.53] ENTER state=Idle\n[SIM][t=59.54] ENTER state=Idle\n[SIM][t=59.55] ENTER state=Idle\n[SIM][t=59.56] ENTER state=Idle\n[SIM][t=59.57] ENTER state=Idle\n[SIM][t=59.58] ENTER state=Idle\n[SIM][t=59.59] ENTER state=Idle\n[SIM][t=59.60] ENTER state=Idle\n[SIM][t=59.61] ENTER state=Idle\n[SIM][t=59.62] ENTER state=Idle\n[SIM][t=59.63] ENTER state=Idle\n[SIM][t=59.64] ENTER state=Idle\n[SIM][t=59.65] ENTER state=Idle\n[SIM][t=59.66] ENTER state=Idle\n[SIM][t=59.67] ENTER state=Idle\n[SIM][t=59.68] ENTER state=Idle\n[SIM][t=59.69] ENTER state=Idle\n[SIM][t=59.70] ENTER state=Idle\n[SIM][t=59.71] ENTER state=Idle\n[SIM][t=59.72] ENTER state=Idle\n[SIM][t=59.73] ENTER state=Idle\n[SIM][t=59.74] ENTER state=Idle\n[SIM][t=59.75] ENTER state=Idle\n[SIM][t=59.76] ENTER state=Idle\n[SIM][t=59.77] ENTER state=Idle\n[SIM][t=59.78] ENTER state=Idle\n[SIM][t=59.79] ENTER state=Idle\n[SIM][t=59.80] ENTER state=Idle\n[SIM][t=59.81] ENTER state=Idle\n[SIM][t=59.82] ENTER state=Idle\n[SIM][t=59.83] ENTER state=Idle\n[SIM][t=59.84] ENTER state=Idle\n[SIM][t=59.85] ENTER state=Idle\n[SIM][t=59.86] ENTER state=Idle\n[SIM][t=59.87] ENTER state=Idle\n[SIM][t=59.88] ENTER state=Idle\n[SIM][t=59.89] ENTER state=Idle\n[SIM][t=59.90] ENTER state=Idle\n[SIM][t=59.91] ENTER state=Idle\n[SIM][t=59.92] ENTER state=Idle\n[SIM][t=59.93] ENTER state=Idle\n[SIM][t=59.94] ENTER state=Idle\n[SIM][t=59.95] ENTER state=Idle\n[SIM][t=59.96] ENTER state=Idle\n[SIM][t=59.97] ENTER state=Idle\n[SIM][t=59.98] ENTER state=Idle\n[SIM][t=59.99] ENTER state=Idle\n[SIM][t=60.00] ENTER state=Idle\n[SIM][t=60.00] END state=Idle\n[SIM] END simulation\n'}

SUCCESS: Model Verified.
